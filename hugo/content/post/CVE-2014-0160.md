---
title: "CVE-2014-0160 心脏滴血漏洞挖掘与分析"
description: "借助于libFuzzer进行Fuzzing"
date: 2022-05-20T17:57:07+08:00
tags: [ "Vulnerability", "Fuzzing" ]
Imagelink: "https://s2.loli.net/2022/05/20/atE5hjX1gbFPnUN.jpg"
---



> 漏洞编号：CVE-2014-0160
>
> 漏洞类型：内存越界访问
>
> 漏洞危害：信息泄露
>
> 影响范围：OpenSSL1.0.1、OpenSSL 1.0.1a~ OpenSSL 1.0.1f、OpenSSL 1.0.2-beta
>
> 漏洞描述：OpenSSL 在实现 TLS（传输层安全协议）和 DTLS（数据报安全传输协议）的心跳包处理逻辑时存在问题。OpenSSL 的 Heartbleed 模块在处理心跳包时没有检查心跳包中的长度字段是否与后续的数据字段一致，攻击者利用该漏洞构造异常数据包，可获取服务器内存中多达 64KB 的数据。这些数据可能会包含证书私钥、用户账号、密码、邮件内容等敏感信息。



# 背景知识

## 简介

[传输层安全性协议SSL](https://en.wikipedia.org/wiki/Transport_Layer_Security)

**SSL** 全称 Secure Sockets Layer（安全套接字层协议），要求建立在可靠的传输层协议（**TCP**）之上，主要提供机密性、认证性及数据完整性服务。SSL 最初（SSL 1.0、SSL2.0、SSL 3.0 版本）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 **TLS**（传输层安全协议，Transport Layer Security），发展至今已有 TLS 1.0、TLS1.1、TLS1.2 三个版本。

SSL/TLS 协议能够提供的安全服务主要包括：

- 认证性——使用数字证书认证服务器和客户端身份，防止身份伪造；
- 机密性——使用加密算法防止第三方窃听；
- 完整性——使用消息认证码（MAC）保障数据完整性，防止消息被篡改；
- 重放保护——通过使用隐式序列号防止重放攻击；

## SSL握手过程

客户端获取服务器的数字证书后，协商后续数据传输所使用的对称加密密钥。

![img](https://s2.loli.net/2022/05/23/v2tSmBZsi1PWHTO.png)

## SSL Heartbeat

> Heartbleed was introduced by the Heartbeat Extension in the OpenSSL version 1.0.11 . This extension enables a low-cost, keepalive mechanism for peers to know that they’re still connected and all is well at the TLS layer. Standard implementations of TLS do not require the extension as they can rely on TCP for equivalent session management. Version 1.0.1 of OpenSSL added support for the Heartbeat functionality and enabled it by default.

文档：[Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension](https://datatracker.ietf.org/doc/html/rfc6520)

SSL 协议完成握手过程后，客户端和服务器间便建立安全可靠的通信。SSL 安全协议工作在传输层的 TCP 协议之上，所以服务器和客户端需要保持持续连接的状态。由于服务器的资源有限，当连接的客户端数量较大时，服务器要维持这些连接将会消耗很多资源，因此需要及时断开完成通信的客户端以减少服务器的负载压力。服务器通过 SSL 的心跳机制可判断客户端是否已完成通信。

SSL 协议中的心跳机制工作于 SSL 记录协议之上，心跳机制中包含两种类型的消息：心跳请求消息（HeartbeatRequest Message）和心跳响应消息（HeartbeatResponse Message），这两种消息具有相同的包结构。当服务器和客户端完成 SSL 协议的握手阶段后，如果客户端一段时间没有与服务器进行数据交互，客户端需要周期性地向服务器发送心跳请求消息。服务器接收到客户端的心跳请求消息，则认为客户端还没有完成通信，继续维持客户端和服务器的连接，并向客户端发送心跳响应消息。

通信双方在建立 SSL 连接时可协商是否支持心跳机制。在 SSL 第一次握手过程中通过 Client Hello 消息和 Server Hello 消息的 Heartbeat Hello 扩展告知对方是否支持心跳机制。Heartbeat Hello 扩展的格式如下。当支持心跳机制时设置 HeartbeatMode 为 peer_allowed_to_send，可接收心跳请求消息并能返回响应包；当不支持心跳机制时设置 HeartbeatMode 为 peer_not_allowed_to_send，若对端发送心跳请求消息，将会丢弃该消息并返回 unexpected_message 警告消息。

```c
enum {
    peer_allowed_to_send(1),
    peer_not_allowed_to_send(2),
} HeartbeatMode;

struct {
    HeartbeatMode mode;
} HeartbeatExtension;
```

心跳包的结构如下图所示，前半部分为 SSL 记录头，Content Type 为消息类型（0x18 表示心跳包消息），TLS Version 为 SSL 版本信息，Record length 为记录长度；后半部分即为心跳消息。

![img](https://s2.loli.net/2022/05/23/rfcnZhoetL6jK9C.png)

其中，SSL 记录长度（Record length）为心跳消息的总长度。心跳包消息由数据包类型（type）、载荷长度（payload length）、载荷内容（payload）和填充字节（padding）组成。

```c
struct {
      HeartbeatMessageType type;    // 1 bytes，包括request和response两种类型
      uint16 payload_length;    // 2 bytes，载荷长度
      opaque payload[HeartbeatMessage.payload_length];    // payload_length bytes，载荷内容
      opaque padding[padding_length];    // 填充字节，至少为16 bytes
} HeartbeatMessage;
```

下图为心跳请求包的数据包实例，其载荷长度为 5 bytes：

![1586019909_91460635.jpg](https://s2.loli.net/2022/05/23/i6WzNbtolc4VrZn.png)

## OpenSSL

https://www.openssl.org/

查阅文档：

```sh
man 7 crypto
```

> The OpenSSL crypto library (`libcrypto`) implements a wide range of cryptographic algorithms used in various Internet standards. The services provided by this library are used by the OpenSSL implementations of TLS and CMS, and they have also been used to implement many other third party products and protocols.
>
> The functionality includes symmetric encryption, public key cryptography, key agreement, certificate handling, cryptographic hash functions, cryptographic pseudo-random number generators, message authentication codes (MACs), key derivation functions (KDFs), and various utilities.



# 漏洞分析

## 源码获取

获取含漏洞的源码：

```sh
git clone git://git.openssl.org/openssl.git
cd openssl
git checkout OpenSSL_1_0_1f
```

OpenSSL 是 SSL 协议实现的开源软件包，存在漏洞的两个文件为 ssl/d1_both.c 和 ssl/t1_lib.c，这两个文件中的 dtls1_process_heartbeat 函数和 tls1_process_heartbeat 函数分别为 DTLS（数据报安全传输协议）和 TLS（传输层安全协议）处理心跳请求包的函数。两函数的实现完全相同，此处选取 dtls1_process_heartbeat 进行分析。

## 成因预习

![Snipaste_2022-05-23_18-12-44.jpg](https://s2.loli.net/2022/05/23/7bzQV5f1GZLcCgl.jpg)

## 代码分析

预习完后首先来看看出现漏洞的函数：

```c
#ifndef OPENSSL_NO_HEARTBEATS
int
dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &s->s3->rrec.data[0], *pl;
	// ...
}
```

我们发现，为了完整弄清楚该函数中的逻辑，我们还需了解参数SSL的定义：

```c
/* crypto/ossl_tpy.h */
typedef struct ssl_st SSL;

/* ssl/ssl.h */
struct ssl_st
{
    ...
	struct ssl2_state_st *s2;  /* SSLv2 variables */
	struct ssl3_state_st *s3;  /* SSLv3 variables */
	struct dtls1_state_st *d1; /* DTLSv1 variables */
	...
};

/* ssl/ssl3.h */
typedef struct ssl3_state_st
{
	...
	SSL3_RECORD rrec;	/* each decoded record goes in here */
	...
};

/* ssl/ssl3.h */
typedef struct ssl3_record_st
{
/*r */	int type;                  /* type of record */
/*rw*/	unsigned int length;       /* How many bytes available */
/*r */	unsigned int off;          /* read/write offset into 'buf' */
/*rw*/	unsigned char *data;       /* pointer to the record data */
/*rw*/	unsigned char *input;      /* where the decode bytes are */
/*r */	unsigned char *comp;       /* only used with decompression - malloc()ed */
/*r */  unsigned long epoch;       /* epoch number, needed by DTLS1 */
/*r */  unsigned char seq_num[8];  /* sequence number, needed by DTLS1 */
} SSL3_RECORD;
```

由此可知，函数第一行的指针p，指向 SSL3 记录数据，即心跳消息。函数体即处理该心跳消息。

接下来还原函数逻辑与漏洞原因：

```c
#ifndef OPENSSL_NO_HEARTBEATS
int
dtls1_process_heartbeat(SSL *s)
{
    unsigned char *p = &s->s3->rrec.data[0], *pl; // p指向SSL3请求包中的心跳消息
    unsigned short hbtype; // 心跳包类型
    unsigned int payload; // 心跳请求包payload长度
    unsigned int padding = 16; /* Use minimum padding */ // 心跳请求包padding长度

    /* Read type and payload length first */
    hbtype = *p++; // 心跳包类型 = 1，为心跳请求包
    n2s(p, payload); // 使用n2s宏从请求包中取两个字节的载荷长度赋给变量payload，并将p指针后移2个字节，此后指针p指向心跳包载荷
    pl = p; // pl指向心跳包载荷

    if (s->msg_callback)
        s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
            &s->s3->rrec.data[0], s->s3->rrec.length,
            s, s->msg_callback_arg);

    if (hbtype == TLS1_HB_REQUEST) // 若心跳包类型为 TLS1_HB_REQUEST，是一个请求包
    {
        unsigned char *buffer, *bp;
        int r;

        /* Allocate memory for the response, size is 1 byte
         * message type, plus 2 bytes payload length, plus
         * payload, plus padding
         */
        buffer = OPENSSL_malloc(1 + 2 + payload + padding); // 依据请求包中记录的payload与padding长度，为心跳响应包分配内存
        bp = buffer;

        /* Enter response type, length and copy payload */
        *bp++ = TLS1_HB_RESPONSE; // 填充 1 byte 的心跳包类型 = 0x02，为心跳响应包
        s2n(payload, bp); // 填充 2 bytes 的载荷长度
        memcpy(bp, pl, payload); /* 填充心跳响应包载荷（由用户提供）
        						  * 由于心跳包载荷长度（payload）完全由来自请求包，由用户控制
        						  * 故此处若payload变量值大于实际payload大小
        						  * 就会导致额外的数据被拷贝至响应包
        						  * 进而造成信息泄露 */
        bp += payload; // 指针后移payload字节
        /* Random padding */
        RAND_pseudo_bytes(bp, padding); // 填充随机字节

        r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); // 将构造好的心跳响应包写入 SSL3_RECORD 中，并返回给客户端

        if (r >= 0 && s->msg_callback)
            s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
                buffer, 3 + payload + padding,
                s, s->msg_callback_arg);

        OPENSSL_free(buffer);
        
        if (r < 0)                                                                       
            return r;                                                                     
    }
    
    else if (hbtype == TLS1_HB_RESPONSE)                                                     {                                                                                     
        unsigned int seq;   
        
        /* We only send sequence numbers (2 bytes unsigned int),
         * and 16 random bytes, so we just try to read the
         * sequence number */
        n2s(pl, seq);

        if (payload == 18 && seq == s->tlsext_hb_seq)
        {
            dtls1_stop_timer(s);
            s->tlsext_hb_seq++;
            s->tlsext_hb_pending = 0;
        }
    }

    return 0;
}
```

## 漏洞修复

git 查看漏洞修复前后版本差异：

```sh
git diff OpenSSL_1_0_1f OpenSSL_1_0_1g
```

定位到`dtls1_process_heartbeat`函数，得到：

```diff
-Version: 1.0.1f
+Version: 1.0.1g
 Source0: ftp://ftp.openssl.org/source/%{name}-%{version}.tar.gz
 License: OpenSSL
 Group: System Environment/Libraries
diff --git a/ssl/d1_both.c b/ssl/d1_both.c
index 7a5596a6b3..2e8cf681ed 100644
--- a/ssl/d1_both.c
+++ b/ssl/d1_both.c
@@ -1459,26 +1459,36 @@ dtls1_process_heartbeat(SSL *s)
        unsigned int payload;
        unsigned int padding = 16; /* Use minimum padding */
 
-       /* Read type and payload length first */
-       hbtype = *p++;
-       n2s(p, payload);
-       pl = p;
-
        if (s->msg_callback)
                s->msg_callback(0, s->version, TLS1_RT_HEARTBEAT,
                        &s->s3->rrec.data[0], s->s3->rrec.length,
                        s, s->msg_callback_arg);
        # 添加的检查1：当实际心跳载荷（payload）长度为0时，函数返回0
+       /* Read type and payload length first */
+       if (1 + 2 + 16 > s->s3->rrec.length)
+               return 0; /* silently discard */

+       hbtype = *p++;
+       n2s(p, payload);
        # 添加的检查2：当计算得心跳消息长度大于SSL3数据包长度时（两者应该等同），即心跳包载荷长度（payload length）大于实际载荷（payload）的长度时，函数返回0
+       if (1 + 2 + payload + 16 > s->s3->rrec.length)
+               return 0; /* silently discard per RFC 6520 sec. 4 */
+       pl = p;
+
        if (hbtype == TLS1_HB_REQUEST)
                {
                unsigned char *buffer, *bp;
+               unsigned int write_length = 1 /* heartbeat type */ +
+                                           2 /* heartbeat length */ +
+                                           payload + padding;
                int r;
 
+               if (write_length > SSL3_RT_MAX_PLAIN_LENGTH)
+                       return 0;
+
                /* Allocate memory for the response, size is 1 byte
                 * message type, plus 2 bytes payload length, plus
                 * payload, plus padding
                 */
-               buffer = OPENSSL_malloc(1 + 2 + payload + padding);
+               buffer = OPENSSL_malloc(write_length);
                bp = buffer;
 
                /* Enter response type, length and copy payload */
@@ -1489,11 +1499,11 @@ dtls1_process_heartbeat(SSL *s)
                /* Random padding */
                RAND_pseudo_bytes(bp, padding);
 
-               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding);
+               r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length);
 
                if (r >= 0 && s->msg_callback)
                        s->msg_callback(1, s->version, TLS1_RT_HEARTBEAT,
-                               buffer, 3 + payload + padding,
+                               buffer, write_length,
                                s, s->msg_callback_arg);
 
                OPENSSL_free(buffer);
```



# Fuzzing 挖掘 CVE-2014-0160

使用Google的[fuzzer-test-suite](https://github.com/google/fuzzer-test-suite)来实践，先构建包含漏洞的openssl：

```sh
git clone https://github.com/google/fuzzer-test-suite.git
mkdir CVE-2014-0160; cd CVE-2014-0160
../fuzzer-test-suite/openssl-1.0.1f/build.sh
```

This command will download the openssl sources at the affected revision and build the fuzzer for one specific API that has the bug, see [openssl-1.0.1f/target.cc](https://github.com/google/fuzzer-test-suite/blob/master/openssl-1.0.1f/target.cc)：

```c
// Copyright 2016 Google Inc. All Rights Reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
#include <openssl/ssl.h>
#include <openssl/err.h>
#include <assert.h>
#include <stdint.h>
#include <stddef.h>

SSL_CTX *Init() {
  SSL_library_init();
  SSL_load_error_strings();
  ERR_load_BIO_strings();
  OpenSSL_add_all_algorithms();
  SSL_CTX *sctx;
  assert (sctx = SSL_CTX_new(TLSv1_method()));
  /* These two file were created with this command:
      openssl req -x509 -newkey rsa:512 -keyout server.key \
     -out server.pem -days 9999 -nodes -subj /CN=a/
  */
  assert(SSL_CTX_use_certificate_file(sctx, "runtime/server.pem",
                                      SSL_FILETYPE_PEM));
  assert(SSL_CTX_use_PrivateKey_file(sctx, "runtime/server.key",
                                     SSL_FILETYPE_PEM));
  return sctx;
}

extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) {
  static SSL_CTX *sctx = Init();
  SSL *server = SSL_new(sctx);
  BIO *sinbio = BIO_new(BIO_s_mem());
  BIO *soutbio = BIO_new(BIO_s_mem());
  SSL_set_bio(server, sinbio, soutbio);
  SSL_set_accept_state(server);
  BIO_write(sinbio, Data, Size);
  SSL_do_handshake(server);
  SSL_free(server);
  return 0;
}
```

构建完成后运行刚刚编译好的fuzzer：

```sh
./openssl-1.0.1f-fsanitize_fuzzer
```

就能跑出：

```sh
=================================================================
==2190163==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x00000051d75a bp 0x7fff7d14a450 sp 0x7fff7d149c18
READ of size 33536 at 0x629000009748 thread T0
    #0 0x51d759 in __asan_memcpy (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51d759)
    #1 0x55c283 in tls1_process_heartbeat /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/t1_lib.c:2586:3
    #2 0x5c7321 in ssl3_read_bytes /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_pkt.c:1092:4
    #3 0x5cb7f3 in ssl3_get_message /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:457:7
    #4 0x597c86 in ssl3_get_client_hello /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:941:4
    #5 0x593b21 in ssl3_accept /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:357:9
    #6 0x55052d in LLVMFuzzerTestOneInput /root/lab/fuzzing_baby/CVE-2014-0160/../fuzzer-test-suite/openssl-1.0.1f/target.cc:34:3
    #7 0x4587a1 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x4587a1)
    #8 0x457ee5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x457ee5)
    #9 0x45a187 in fuzzer::Fuzzer::MutateAndTestOne() (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45a187)
    #10 0x45ae85 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45ae85)
    #11 0x44983e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x44983e)
    #12 0x472682 in main (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x472682)
    #13 0x7f58322b0082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16
    #14 0x41e5dd in _start (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x41e5dd)

0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748)
allocated by thread T0 here:
    #0 0x51e30d in malloc (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51e30d)
    #1 0x5fab2b in CRYPTO_malloc /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/crypto/mem.c:308:8
    #2 0x5ccf07 in freelist_extract /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:708:12
    #3 0x5ccf07 in ssl3_setup_read_buffer /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:770:10
    #4 0x5cd51c in ssl3_setup_buffers /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:827:7
    #5 0x59474f in ssl3_accept /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:292:9
    #6 0x55052d in LLVMFuzzerTestOneInput /root/lab/fuzzing_baby/CVE-2014-0160/../fuzzer-test-suite/openssl-1.0.1f/target.cc:34:3
    #7 0x4587a1 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x4587a1)
    #8 0x45a4da in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45a4da)
    #9 0x45ab69 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector<fuzzer::SizedFile, fuzzer::fuzzer_allocator<fuzzer::SizedFile> >&) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45ab69)
    #10 0x44983e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x44983e)
    #11 0x472682 in main (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x472682)
    #12 0x7f58322b0082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16

SUMMARY: AddressSanitizer: heap-buffer-overflow (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51d759) in __asan_memcpy
Shadow bytes around the buggy address:
  0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00
=>0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa
  0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
  0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa
Shadow byte legend (one shadow byte represents 8 application bytes):
  Addressable:           00
  Partially addressable: 01 02 03 04 05 06 07
  Heap left redzone:       fa
  Freed heap region:       fd
  Stack left redzone:      f1
  Stack mid redzone:       f2
  Stack right redzone:     f3
  Stack after return:      f5
  Stack use after scope:   f8
  Global redzone:          f9
  Global init order:       f6
  Poisoned by user:        f7
  Container overflow:      fc
  Array cookie:            ac
  Intra object redzone:    bb
  ASan internal:           fe
  Left alloca redzone:     ca
  Right alloca redzone:    cb
  Shadow gap:              cc
==2190163==ABORTING
MS: 1 CopyPart-; base unit: 380cd810619fc15deda5a170f6bec4cfd229086b
0x18,0x3,0x29,0x0,0x1,0x1,0x0,
\x18\x03)\x00\x01\x01\x00
artifact_prefix='./'; Test unit written to ./crash-8f882413170d68fb148303a53b5208b0f2dc61cc
Base64: GAMpAAEBAA==
```
