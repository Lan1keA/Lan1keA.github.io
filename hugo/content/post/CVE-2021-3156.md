---
title: "CVE-2021-3156 sudo 提权漏洞分析"
description: "阅内核洞前先来阅阅用户态的洞吧"
date: 2022-05-13T23:02:59+08:00
tags: [ "漏洞分析" ]
imagelink: "https://s2.loli.net/2022/05/19/FeqdKtWJZ3GonMX.png"
---



> CVE-2021-3156是sudo中存在一个堆溢出漏洞。影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。可以使得任何没有特权的用户均可使用默认的sudo配置获取root权限



## 环境准备

使用apt获取软件源提供的sudo源码：

```sh
sudo apt source sudo
```

却被告知：

```tex
NOTICE: 'sudo' packaging is maintained in the 'Git' version control system at:
https://salsa.debian.org/sudo-team/sudo.git
Please use:
git clone https://salsa.debian.org/sudo-team/sudo.git
to retrieve the latest (possibly unreleased) updates to the package.
```

于是听话，从git仓库获取源码：

```sh
git clone https://salsa.debian.org/sudo-team/sudo.git
```

接下来进行构建：

```sh
# clone configure make
git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 # v1.9.5p1
CFLAGS+=-g ./configure --sysconfdir=`pwd`/examples --with-plugindir=`pwd`/plugins/sudoers/.libs
make -j`nproc`
```

构建完成后在root用户下可以执行测试：

```c
LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo
```

验证编译目标的确存在漏洞，前需事先创建名为 sudoedit 的 sudo 的软链接以绕过后续检查：

```sh
cd src/.libs
ln -s sudo sudoedit
cd ../../
```

执行验证：

```sh
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
malloc(): corrupted top size
[1]    1357050 abort (core dumped)  LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
```

说明漏洞的确存在。

## 漏洞成因

sudo.c 中的 main 函数，会调用 parse_args 函数来处理sudo的命令行参数：

```c
/* Parse command line arguments. */
sudo_mode = parse_args(argc, argv, &submit_optind, &nargc, &nargv, &settings, &env_add);
```

parse_args 函数于 parse_args.c 中实现。

当向 sudo 传入 -s 或 -i 参数时，sudo 执行如下行为：

```sh
-s, --shell                   run shell as the target user; a command may also be specified
-i, --login                   run login shell as the target user; a command may also be specified
```

-s 或 -i 后可以接实际想要在shell中执行的命令。使用举例：

```sh
sudo -s echo \$UID
0
```

在sudo处理参数的逻辑中，-s 会设定 flags 中的 MODE_SHELL 位，-i 会设定 flags 中的 MODE_LOGIN_SHELL 位：

```c
switch (ch)
{
// ...
	case 'i':
		sudo_settings[ARG_LOGIN_SHELL].value = "true";
		SET(flags, MODE_LOGIN_SHELL);
		break;
// ...
	case 's':
		sudo_settings[ARG_USER_SHELL].value = "true";
		SET(flags, MODE_SHELL);
		break;
// ...
}
```

且后续 MODE_LOGIN_SHELL 也会设置 MODE_SHELL：

```c
if (ISSET(flags, MODE_LOGIN_SHELL))
{
    // ...
    SET(flags, MODE_SHELL);
}
```

加上 mode 变量中已有的 MODE_RUN 标志位，会在其后的执行流中进入如下 if 块中，用于处理sudo在特定参数下需要处理的命令行参数中的转义符`\`：

```c
/*
 * Command line argument parsing.
 * Sets nargc and nargv which corresponds to the argc/argv we'll use
 * for the command to be run (if we are running one).
 */
int
parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv,
    struct sudo_settings **settingsp, char ***env_addp) 
{
    // ……
    // （前面是参数解析与MODE判断的一堆代码
    /*
    * For shell mode we need to rewrite argv （只关注这块if里的逻辑
    */
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        char **av, *cmnd = NULL;
        int ac = 1;
        if (argc != 0) {
            /* shell -c "command" */
            char *src, *dst;
            size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
            strlen(argv[argc - 1]) + 1;

            cmnd = dst = reallocarray(NULL, cmnd_size, 2);
            if (cmnd == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
            if (!gc_add(GC_PTR, cmnd))
            exit(EXIT_FAILURE);

          	// 从原 argv 中拷贝字符串，构建 command
            for (av = argv; *av != NULL; av++) {
            for (src = *av; *src != '\0'; src++) {
                /* quote potential meta characters */
                // 将数字、字母、_、-、$ 之外的所有字符前加上字符 \，用于转义
                if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                    *dst++ = '\\'; // C源代码中用 '\\' 表示字符 \
                *dst++ = *src;
            }
            *dst++ = ' ';
            }
            if (cmnd != dst)
            dst--;  /* replace last space with a NUL */
            *dst = '\0';

            ac += 2; /* -c cmnd */
        }

        av = reallocarray(NULL, ac + 1, sizeof(char *));
        if (av == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
        if (!gc_add(GC_PTR, av))
            exit(EXIT_FAILURE);

        av[0] = (char *)user_details.shell; /* plugin may override shell */
        if (cmnd != NULL) {
            av[1] = "-c";
            av[2] = cmnd;
        }
        av[ac] = NULL;

        argv = av;
        argc = ac;
    }
```

parse_args函数是故事的开始。虽然做好了出发漏洞的准备，但到目前为止尚且无事发生。我们需要接着向下探索。故开启调试以动态跟踪，下断点于上述 if 块的起始位置：

```sh
gdb src/.libs/sudoedit
pwndbg> set args -s /
pwndbg> set environment LD_LIBRARY_PATH=./lib/util/.libs/
pwndbg> b parse_args.c:604
pwndbg> r
```

一路向下跟踪，尽快来到本次事件的漏洞中心—— set_cmnd 函数看看。backtrace如下：

```sh
pwndbg> bt
#0  set_cmnd () at ./sudoers.c:922
#1  sudoers_policy_main (argc=argc@entry=3, argv=argv@entry=0x555555584590, pwflag=pwflag@entry=0, env_add=env_add@entry=0x0, verbose=verbose@entry=false, closure=closure@entry=0x7fffffffe1d0) at ./sudoers.c:401
#2  0x00007ffff79de5f2 in sudoers_policy_check (argc=3, argv=0x555555584590, env_add=0x0, command_infop=0x7fffffffe290, argv_out=0x7fffffffe298, user_env_out=0x7fffffffe2a0, errstr=0x7fffffffe2b8) at ./policy.c:1028
#3  0x000055555555aefa in policy_check (user_env_out=0x7fffffffe2a0, argv_out=0x7fffffffe298, command_info=0x7fffffffe290, env_add=0x0, argv=0x555555584590, argc=3) at ./sudo.c:1171
#4  main (argc=argc@entry=3, argv=argv@entry=0x7fffffffe538, envp=<optimized out>) at ./sudo.c:269
#5  0x00007ffff7da4083 in __libc_start_main (main=0x55555555aa00 <main>, argc=3, argv=0x7fffffffe538, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffe528) at ../csu/libc-start.c:308
#6  0x000055555555d06e in _start ()
```

set_cmnd 就是漏洞触发点所在的函数了，其中有如下逻辑：

```c
/*
 * Fill in user_cmnd, user_args, user_base and user_stat variables
 * and apply any command-specific defaults entries.
 */
static
int set_cmnd(void)
{
		//...
  	// 取消转义符需满足的条件1
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
        //...
        /* set user_args */
        if (NewArgc > 1) {
            char *to, *from, **av;
            size_t size, n;

            /* Alloc and build up user_args. */
            for (size = 0, av = NewArgv + 1; *av; av++)
                size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
                sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
                debug_return_int(NOT_FOUND_ERROR);
            }
          	// 取消转义符需满足的条件2
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
                /*
                 * When running a command via a shell, the sudo front-end
                 * escapes potential meta chars.  We unescape non-spaces
                 * for sudoers matching and logging purposes.
                 */
              	// 遍历传入的参数
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        // 当当前字符为 \，且其后紧跟的字符不为空格时，则跳过对当前字符 \ 的复制
                        // 即：将传入的命令参数字符串中的所有转义符舍去
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++;
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
                *--to = '\0';
            } else {
            		//...
            }
      	}
    }
	//...
}
```

回到文章开头的例子，我们可以分析其中的错误原因了：

```sh
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
malloc(): corrupted top size
[1]    1357050 abort (core dumped)  LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
```

对于这段代码：

```c
while (*from) {
    // 当当前字符为 \，且其后紧跟的字符不为空格时，则跳过对当前字符 \ 的复制
    // 即：将传入的命令参数字符串中的所有转义符舍去
    if (from[0] == '\\' && !isspace((unsigned char)from[1]))
    		from++;
    *to++ = *from++;
}
```

若传入的命令参数字符串以 \ 结尾，则会使得处理该 \ 字符时出现：

- `from[0] == '\\'`（单走一个 \ )
- `from[1] == '\x00' `（C语言字符串结尾标记字符）

导致此次循环中if条件成立，执行 from++，再加上下一行的 *to++ = *from++，使得from指针直接越过了原字符串的范围。由此导致`*from == \x00`时的一字节被略过，while继续执行，拷贝了额外的非法数据。

由此得到了程序中的错误，但这个错误是如何成为漏洞的，还需向上回溯被写入的缓冲区：

- 向to指针指向的位置写入来自from指针的数据：

```c
*to++ = *from++;
```

- to指针用于向user_args缓冲区写入数据：

```c
for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
```

- user_args缓冲区是malloc了size大小得到的堆缓冲区：

```c
if (size == 0 || (user_args = malloc(size)) == NULL) {
```

- 堆缓冲区大小size由计算存储命令参数字符串所需的总字节数得到：

```c
/* Alloc and build up user_args. */
for (size = 0, av = NewArgv + 1; *av; av++)
		size += strlen(*av) + 1;
```

那么向user_args堆块中写入过量的数据，则造成堆溢出。

且慢！单看这里的代码的确有问题，但我们假设的以单一一个 \ 结尾的字符串真的能传递到这里来吗？

毕竟如果是两个 \ 结尾的字符串，则`*from == \x00`时则正确命中while判断，程序不会出错。

而前面parse_args函数做的处理，正是会将 \ 前面再添加上一个转义符 \ 的呀。

那这里为啥会成功触发错误？先揭晓下答案，再针对其进行分析：

```sh
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
malloc(): corrupted top size
[1]    1383588 abort (core dumped)  LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo -s '\'
zsh:1: command not found: \
```

文章前半部分为sudo建立了一个符号链接sudoedit，可以看到此时使用sudoedit执行就能成功触发漏洞，但使用原本的sudo则不可以。所以代码中肯定有逻辑对于启动时不同的程序名称做出了判断，进而执行了不同逻辑。

回到源代码中，我们观察到parse_args函数添加转义符的触发条件和set_cmnd函数取消转义符的触发条件是不同的：

- parse_args

```c
if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
```

- set_cmnd

```c
if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
		if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
```

即：

- 添加转义符操作需满足mode设置了MODE_RUN，且flags设置了MODE_SHELL
- 取消转义符操作需sudo_mode设置了(MODE_RUN|MODE_EDIT|MODE_CHECK) && (MODE_SHELL|MODE_LOGIN_SHELL)

那么想要达成**不执行添加转义符的操作，执行取消转义符的操作**的目的，就需要满足：

```c
MODE_SHELL && !MODE_RUN && (MODE_EDIT || MODE_CHECK)
```

看来需要寻找MODE_EDIT与MODE_CHECK从何而来了。

从parse_args中可知，它们来自于-e和-l参数：

```c
int
parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv,
    struct sudo_settings **settingsp, char ***env_addp)
{
    // ...
    for (;;)
    {
        if ((ch = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1)
        {
            switch (ch)
            {
            // ...
            case 'e':
                if (mode && mode != MODE_EDIT)
                    usage_excl();
                // 设置 mode 为 MODE_EDIT
                mode = MODE_EDIT;
                sudo_settings[ARG_SUDOEDIT].value = "true";
                valid_flags = MODE_NONINTERACTIVE;
                break;
            // ...
            case 'l':
                if (mode)
                {
                    if (mode == MODE_LIST)
                        SET(flags, MODE_LONG_LIST);
                    else
                        usage_excl();
                }
                // 设置 mode 为 MODE_LIST
                mode = MODE_LIST;
                valid_flags = MODE_NONINTERACTIVE | MODE_LONG_LIST;
                break;
            // ...
            }
        }
        // ...
    }
    // ...
    // 在此处将 MODE_LIST 更新为 MODE_CHECK
    if (argc > 0 && mode == MODE_LIST)
        mode = MODE_CHECK;
    // ...
    // 必须绕过的特殊判断条件
    if ((flags & valid_flags) != flags)
        usage();
    // ...
}
```

它们的作用：

```c
-e, --edit                    edit files instead of running a command
-l, --list                    list user's privileges or check a specific command; use twice for longer format
```

由此看来，发现不妙：

- 从功能描述上，-e、-l参数的功能和-s、-i参数的功能是冲突的，估计没法一起用
- 从源代码上看来，的确如此。通过-e、-l参数设定valid_flags变量，并进行如下判断的手法，sudo规避了上述用法，并向用户打印了usage教你怎么用它：

```c
if ((flags & valid_flags) != flags)
    usage();
```

绕过的方法呢？上文已经揭晓过了。使用sudoedit作为程序名调用sudo，能起到和sudo -e一样的效果，却不会进入parse_args中的这段判断逻辑中：

```c
int
parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv,
    struct sudo_settings **settingsp, char ***env_addp)
{   
    /* First, check to see if we were invoked as "sudoedit". */
    // 如果以 sudoedit 作为程序名
    proglen = strlen(progname);
    if (proglen > 4 && strcmp(progname + proglen - 4, "edit") == 0)
    {
        progname = "sudoedit";
        // 则设置 mode 为 MODE_EDIT
        mode = MODE_EDIT;
        // 注意之后就没有再设置 valid_flags了
        sudo_settings[ARG_SUDOEDIT].value = "true";
    }
}
```

由此，到达漏洞点的路径就通畅了。

