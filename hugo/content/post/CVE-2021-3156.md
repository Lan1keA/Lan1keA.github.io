---
title: "CVE-2021-3156 sudo 提权漏洞分析"
description: "阅内核洞前先来阅阅用户态的洞吧"
date: 2022-05-13T23:02:59+08:00
tags: [ "漏洞分析" ]
---



> CVE-2021-3156是sudo中存在一个堆溢出漏洞。影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。可以使得任何没有特权的用户均可使用默认的sudo配置获取root权限



## 环境准备

使用apt获取软件源提供的sudo源码：

```sh
sudo apt source sudo
```

却被告知：

```tex
NOTICE: 'sudo' packaging is maintained in the 'Git' version control system at:
https://salsa.debian.org/sudo-team/sudo.git
Please use:
git clone https://salsa.debian.org/sudo-team/sudo.git
to retrieve the latest (possibly unreleased) updates to the package.
```

于是听话，从git仓库获取源码：

```sh
git clone https://salsa.debian.org/sudo-team/sudo.git
```

接下来进行构建：

```sh
# clone configure make
git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 # v1.9.5p1
CFLAGS+=-g ./configure --sysconfdir=`pwd`/examples --with-plugindir=`pwd`/plugins/sudoers/.libs
make -j`nproc`
```

构建完成后在root用户下可以执行测试：

```c
LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo
```

验证编译目标的确存在漏洞，前需事先创建名为 sudoedit 的 sudo 的软链接以绕过后续检查：

```sh
cd src/.libs
ln -s sudo sudoedit
cd ../../
```

执行验证：

```sh
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
malloc(): corrupted top size
[1]    1357050 abort (core dumped)  LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
```

说明漏洞的确存在。

## 漏洞成因

sudo.c 中的 main 函数，会调用 parse_args 函数来处理sudo的命令行参数：

```c
/* Parse command line arguments. */
sudo_mode = parse_args(argc, argv, &submit_optind, &nargc, &nargv, &settings, &env_add);
```

parse_args 函数于 parse_args.c 中实现。

当向 sudo 传入 -s 或 -i 参数时，sudo 执行如下行为：

```sh
-s, --shell                   run shell as the target user; a command may also be specified
-i, --login                   run login shell as the target user; a command may also be specified
```

-s 或 -i 后可以接实际想要在shell中执行的命令。使用举例：

```sh
sudo -s echo \$UID
0
```

在sudo处理参数的逻辑中，-s 会设定 flags 中的 MODE_SHELL 位，-i 会设定 flags 中的 MODE_LOGIN_SHELL 位：

```c
switch (ch)
{
// ...
	case 'i':
		sudo_settings[ARG_LOGIN_SHELL].value = "true";
		SET(flags, MODE_LOGIN_SHELL);
		break;
// ...
	case 's':
		sudo_settings[ARG_USER_SHELL].value = "true";
		SET(flags, MODE_SHELL);
		break;
// ...
}
```

且后续 MODE_LOGIN_SHELL 也会设置 MODE_SHELL：

```c
if (ISSET(flags, MODE_LOGIN_SHELL))
{
    // ...
    SET(flags, MODE_SHELL);
}
```

加上 mode 变量中已有的 MODE_RUN 标志位，会在其后的执行流中进入如下 if 块中，用于处理sudo在特定参数下需要处理的命令行参数中的转义符`\`：

```c
/*
 * Command line argument parsing.
 * Sets nargc and nargv which corresponds to the argc/argv we'll use
 * for the command to be run (if we are running one).
 */
int
parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv,
    struct sudo_settings **settingsp, char ***env_addp) 
{
    // ……
    // （前面是参数解析与MODE判断的一堆代码
    /*
    * For shell mode we need to rewrite argv （只关注这块if里的逻辑
    */
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        char **av, *cmnd = NULL;
        int ac = 1;
        if (argc != 0) {
            /* shell -c "command" */
            char *src, *dst;
            size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
            strlen(argv[argc - 1]) + 1;

            cmnd = dst = reallocarray(NULL, cmnd_size, 2);
            if (cmnd == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
            if (!gc_add(GC_PTR, cmnd))
            exit(EXIT_FAILURE);

          	// 从原 argv 中拷贝字符串，构建 command
            for (av = argv; *av != NULL; av++) {
            for (src = *av; *src != '\0'; src++) {
                /* quote potential meta characters */
                // 将数字、字母、_、-、$ 之外的所有字符前加上字符 \，用于转义
                if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                    *dst++ = '\\'; // C源代码中用 '\\' 表示字符 \
                *dst++ = *src;
            }
            *dst++ = ' ';
            }
            if (cmnd != dst)
            dst--;  /* replace last space with a NUL */
            *dst = '\0';

            ac += 2; /* -c cmnd */
        }

        av = reallocarray(NULL, ac + 1, sizeof(char *));
        if (av == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
        if (!gc_add(GC_PTR, av))
            exit(EXIT_FAILURE);

        av[0] = (char *)user_details.shell; /* plugin may override shell */
        if (cmnd != NULL) {
            av[1] = "-c";
            av[2] = cmnd;
        }
        av[ac] = NULL;

        argv = av;
        argc = ac;
    }
```

开始调试以动态跟踪，下断点于上述 if 块的起始位置：

```sh
gdb src/.libs/sudoedit
pwndbg> set args -s /
pwndbg> set environment LD_LIBRARY_PATH=./lib/util/.libs/
pwndbg> b parse_args.c:604
pwndbg> r
```

一直向下跟踪，来到 set_cmnd 函数。backtrace如下：

```sh
pwndbg> bt
#0  set_cmnd () at ./sudoers.c:922
#1  sudoers_policy_main (argc=argc@entry=3, argv=argv@entry=0x555555584590, pwflag=pwflag@entry=0, env_add=env_add@entry=0x0, verbose=verbose@entry=false, closure=closure@entry=0x7fffffffe1d0) at ./sudoers.c:401
#2  0x00007ffff79de5f2 in sudoers_policy_check (argc=3, argv=0x555555584590, env_add=0x0, command_infop=0x7fffffffe290, argv_out=0x7fffffffe298, user_env_out=0x7fffffffe2a0, errstr=0x7fffffffe2b8) at ./policy.c:1028
#3  0x000055555555aefa in policy_check (user_env_out=0x7fffffffe2a0, argv_out=0x7fffffffe298, command_info=0x7fffffffe290, env_add=0x0, argv=0x555555584590, argc=3) at ./sudo.c:1171
#4  main (argc=argc@entry=3, argv=argv@entry=0x7fffffffe538, envp=<optimized out>) at ./sudo.c:269
#5  0x00007ffff7da4083 in __libc_start_main (main=0x55555555aa00 <main>, argc=3, argv=0x7fffffffe538, init=<optimized out>, fini=<optimized out>, rtld_fini=<optimized out>, stack_end=0x7fffffffe528) at ../csu/libc-start.c:308
#6  0x000055555555d06e in _start ()
```

set_cmnd 就是漏洞触发点所在的函数了，其中有如下逻辑：

```c
/*
 * Fill in user_cmnd, user_args, user_base and user_stat variables
 * and apply any command-specific defaults entries.
 */
static
int set_cmnd(void)
{
		//...
  	// sudo_mode 需满足的条件1
    if (sudo_mode & (MODE_RUN | MODE_EDIT | MODE_CHECK)) {
        //...
        /* set user_args */
        if (NewArgc > 1) {
            char *to, *from, **av;
            size_t size, n;

            /* Alloc and build up user_args. */
            for (size = 0, av = NewArgv + 1; *av; av++)
                size += strlen(*av) + 1;
            if (size == 0 || (user_args = malloc(size)) == NULL) {
                sudo_warnx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
                debug_return_int(NOT_FOUND_ERROR);
            }
          	// sudo_mode 需满足的条件2
            if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) {
                /*
                 * When running a command via a shell, the sudo front-end
                 * escapes potential meta chars.  We unescape non-spaces
                 * for sudoers matching and logging purposes.
                 */
              	// 遍历传入的参数
                for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
                    while (*from) {
                        // 当当前字符为 \，且其后紧跟的字符不为空格时，则跳过对当前字符 \ 的复制
                        // 即：将传入的命令参数字符串中的所有转义符舍去
                        if (from[0] == '\\' && !isspace((unsigned char)from[1]))
                            from++;
                        *to++ = *from++;
                    }
                    *to++ = ' ';
                }
                *--to = '\0';
            } else {
            		//...
            }
      	}
    }
	//...
}
```

回到文章开头的例子，我们可以分析其中的错误原因了：

```sh
➜  sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
malloc(): corrupted top size
[1]    1357050 abort (core dumped)  LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s '\'
```

对于这段代码：

```c
while (*from) {
    // 当当前字符为 \，且其后紧跟的字符不为空格时，则跳过对当前字符 \ 的复制
    // 即：将传入的命令参数字符串中的所有转义符舍去
    if (from[0] == '\\' && !isspace((unsigned char)from[1]))
    		from++;
    *to++ = *from++;
}
```

若传入的命令参数字符串以 \ 结尾，则会使得处理该 \ 字符时出现：

- `from[0] == '\\'`（单走一个 \ )
- `from[1] == '\x00' `（C语言字符串结尾标记字符）

导致此次循环中if条件成立，执行 from++，再加上下一行的 *to++ = *from++，使得from指针直接越过了原字符串的范围。由此导致while继续执行，拷贝了额外的非法数据。

由此得到了程序中的错误，但这个错误是如何成为漏洞的，还需向上回溯被写入的缓冲区：

- 向to指针指向的位置写入来自from指针的数据：

```c
*to++ = *from++;
```

- to指针用于向user_args缓冲区写入数据：

```c
for (to = user_args, av = NewArgv + 1; (from = *av); av++) {
```

- user_args缓冲区是malloc了size大小得到的堆缓冲区：

```c
if (size == 0 || (user_args = malloc(size)) == NULL) {
```

- 堆缓冲区大小size由计算存储命令参数字符串所需的总字节数得到：

```c
/* Alloc and build up user_args. */
for (size = 0, av = NewArgv + 1; *av; av++)
		size += strlen(*av) + 1;
```

那么向user_args堆块中写入过量的数据，则造成堆溢出。
