---
title: "CVE-2021-3156 sudo 提权漏洞分析"
description: "nothing"
date: 2022-05-13T23:02:59+08:00
tags: [ "漏洞分析" ]
---



> CVE-2021-3156是sudo中存在一个堆溢出漏洞。影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。可以使得任何没有特权的用户均可使用默认的sudo配置获取root权限



## 环境准备

使用apt获取软件源提供的sudo源码：

```sh
sudo apt source sudo
```

却被告知：

```tex
NOTICE: 'sudo' packaging is maintained in the 'Git' version control system at:
https://salsa.debian.org/sudo-team/sudo.git
Please use:
git clone https://salsa.debian.org/sudo-team/sudo.git
to retrieve the latest (possibly unreleased) updates to the package.
```

于是听话，从git仓库获取源码：

```sh
git clone https://salsa.debian.org/sudo-team/sudo.git
```

接下来进行构建：

```sh
# clone configure make
git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 # v1.9.5p1
./configure --sysconfdir=`pwd`/examples --with-plugindir=`pwd`/plugins/sudoers/.libs
make -j`nproc`
```



## 漏洞成因

sudo.c 中的 main 函数，会调用 parse_args 函数来处理sudo的命令行参数：

```c
/* Parse command line arguments. */
sudo_mode = parse_args(argc, argv, &submit_optind, &nargc, &nargv, &settings, &env_add);
```

parse_args 函数于 parse_args.c 中实现。其中有如下逻辑，用于处理sudo在特定参数下需要处理的命令行参数中的转义符`\`：

```c
/*
 * Command line argument parsing.
 * Sets nargc and nargv which corresponds to the argc/argv we'll use
 * for the command to be run (if we are running one).
 */
int parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv,
    struct sudo_settings **settingsp, char ***env_addp) {
    // ……
    // （前面是参数解析与MODE判断的一堆代码
    /*
    * For shell mode we need to rewrite argv （只关注这块if里的逻辑
    */
    if (ISSET(mode, MODE_RUN) && ISSET(flags, MODE_SHELL)) {
        char **av, *cmnd = NULL;
        int ac = 1;
        if (argc != 0) {
            /* shell -c "command" */
            char *src, *dst;
            size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) +
            strlen(argv[argc - 1]) + 1;

            cmnd = dst = reallocarray(NULL, cmnd_size, 2);
            if (cmnd == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
            if (!gc_add(GC_PTR, cmnd))
            exit(EXIT_FAILURE);

            for (av = argv; *av != NULL; av++) {
            for (src = *av; *src != '\0'; src++) {
                /* quote potential meta characters */
                if (!isalnum((unsigned char)*src) && *src != '_' && *src != '-' && *src != '$')
                *dst++ = '\\';
                *dst++ = *src;
            }
            *dst++ = ' ';
            }
            if (cmnd != dst)
            dst--;  /* replace last space with a NUL */
            *dst = '\0';

            ac += 2; /* -c cmnd */
        }

        av = reallocarray(NULL, ac + 1, sizeof(char *));
        if (av == NULL)
            sudo_fatalx(U_("%s: %s"), __func__, U_("unable to allocate memory"));
        if (!gc_add(GC_PTR, av))
            exit(EXIT_FAILURE);

        av[0] = (char *)user_details.shell; /* plugin may override shell */
        if (cmnd != NULL) {
            av[1] = "-c";
            av[2] = cmnd;
        }
        av[ac] = NULL;

        argv = av;
        argc = ac;
    }
```



