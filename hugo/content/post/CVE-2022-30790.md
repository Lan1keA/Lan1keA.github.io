---
title: "对U-Boot CVE-2022-30790的跟踪"
description: "以及CVE-2022-30552"
date: 2022-06-16T10:11:14+08:00
tags: [ "Vulnerability" ]
imagelink: "https://s2.loli.net/2022/06/16/R9KWInUb6Cdyhl2.jpg"
---



# U-Boot速览

- [Das U-Boot - Wikipedia](https://en.wikipedia.org/wiki/Das_U-Boot)
- [https://github.com/u-boot/u-boot](https://github.com/u-boot/u-boot)
- [U-Boot源码在线浏览](https://elixir.bootlin.com/u-boot/latest/source)



# 村中传言

**[https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/](https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/)**

🤔Hmmm...新鲜漏洞，没有PoC。这次是出了两个漏洞，分别是：

- Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive ([CVE-2022-30790](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790))
- Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code ([CVE-2022-30552](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552))

先来分析分析出现漏洞的源码。根据：

> **May 18th 2022:** Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified. 

那么用U-Boot v2022.04应该是没有问题的。



# 漏洞源码分析

## CVE-2022-30790

漏洞影响：

> The U-Boot implementation of [RFC815](https://datatracker.ietf.org/doc/html/rfc815) IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.

### RFC815

看来需要先了解下RFC815的IP分片算法：

- 原文档：[https://datatracker.ietf.org/doc/html/rfc815](https://datatracker.ietf.org/doc/html/rfc815)
- 一篇相关论文：[http://www.ecice06.com/CN/Y2008/V34/I22/100](http://www.ecice06.com/CN/Y2008/V34/I22/100)

> RFC815 是 IETF 推荐的一种分片重组算法，该算法具有记录分片简洁，内存需求量与原 IP 数据报大小一致等优点。

该算法的作用对象是IP数据报。IPv4数据报的Header结构如下：(ref - [https://en.wikipedia.org/wiki/IPv4](https://en.wikipedia.org/wiki/IPv4)

![image.png](https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png)

其中，分片信息记录在：

- **Identification**

    - This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.

- **Flags**

    - A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):

        - bit 0: Reserved; must be zero
        - bit 1: Don't Fragment (DF)
        - bit 2: More Fragments (MF)

        If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for [path MTU discovery](https://en.wikipedia.org/wiki/Path_MTU_discovery), either automatically by the host IP software, or manually using diagnostic tools such as [ping](https://en.wikipedia.org/wiki/Ping_(networking_utility)) or [traceroute](https://en.wikipedia.org/wiki/Traceroute).

        For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.

- **Fragment Offset**

    - This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram in units of eight-byte blocks. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> – 1) × 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.

好了，简单了解过数据结构，接着来看看算法。

原文档有言：

> One of the mechanisms of IP is fragmentation and reassembly.
>
> 分片和重组是IP协议的一个主要机制。

> A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.
>
> 一个数据报——作为传输基本单元，会被切分为多个分片送达最终的目的地。





### 开始分析

漏洞位置：

> In `u-boot/net/net.c` the `__net_defragment` function line 900 through 1018.

漏洞源码：

[https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900](https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900)

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh;
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS);
	thisfrag = payload + offset8;
	start = offset8 * 8;
	len = ntohs(ip->ip_len) - IP_HDR_SIZE;

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) {
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len);
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

