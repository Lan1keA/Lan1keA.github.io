---
title: "对U-Boot CVE-2022-30790的跟踪"
description: "以及CVE-2022-30552"
date: 2022-06-16T10:11:14+08:00
categories: "漏洞分析"
tags: [ "Coreutils" ]
image: "https://s2.loli.net/2022/06/16/R9KWInUb6Cdyhl2.jpg"
---



## U-Boot速览

- [Das U-Boot - Wikipedia](https://en.wikipedia.org/wiki/Das_U-Boot)
- [https://github.com/u-boot/u-boot](https://github.com/u-boot/u-boot)
- [U-Boot源码在线浏览](https://elixir.bootlin.com/u-boot/latest/source)



## 村中传言

**[https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/](https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/)**

🤔Hmmm...新鲜漏洞，没有PoC。这次是出了两个漏洞，分别是：

- Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive ([CVE-2022-30790](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790))
- Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code ([CVE-2022-30552](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552))

先来分析分析出现漏洞的源码。根据：

> **May 18th 2022:** Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified. 

那么用U-Boot v2022.04跟踪漏洞应该是没有问题的。



## 漏洞源码分析

### CVE-2022-30790

漏洞影响：

> The U-Boot implementation of [RFC815](https://datatracker.ietf.org/doc/html/rfc815) IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.

#### RFC815

看来需要先了解下RFC815的IPv4分片算法：

- 原文档：[https://datatracker.ietf.org/doc/html/rfc815](https://datatracker.ietf.org/doc/html/rfc815)
- 一篇相关论文：[http://www.ecice06.com/CN/Y2008/V34/I22/100](http://www.ecice06.com/CN/Y2008/V34/I22/100)

> RFC815 是 IETF 推荐的一种分片重组算法，该算法具有记录分片简洁，内存需求量与原 IPv4 数据报大小一致等优点。

该算法的作用对象是IPv4数据报。IPv4数据报的Header结构如下：(ref - [https://en.wikipedia.org/wiki/IPv4](https://en.wikipedia.org/wiki/IPv4)

![image.png](https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png)

其中，分片信息记录在：

- **Identification**

    - This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.

- **Flags**

    - A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):

        - bit 0: Reserved; must be zero
        - bit 1: Don't Fragment (DF)
        - bit 2: More Fragments (MF)

        If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for [path MTU discovery](https://en.wikipedia.org/wiki/Path_MTU_discovery), either automatically by the host IP software, or manually using diagnostic tools such as [ping](https://en.wikipedia.org/wiki/Ping_(networking_utility)) or [traceroute](https://en.wikipedia.org/wiki/Traceroute).

        For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.

- **Fragment Offset**

    - This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram **in units of eight-byte blocks**. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> – 1) × 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.

注意到分片的索引单位为8字节。

好了，简单了解过数据结构，接着来看看算法。

原文档有言：

> One of the mechanisms of IP is fragmentation and reassembly.
>
> 分片和重组是IPv4协议的一个机制。(文档很老，那时还没有IPv6。In contrast, [IPv6](https://en.wikipedia.org/wiki/IPv6), the next generation of the Internet Protocol, does not allow routers to perform fragmentation; hosts must perform [Path MTU Discovery](https://en.wikipedia.org/wiki/Path_MTU_Discovery) before sending datagrams.)

> A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.
>
> 一个数据报——作为传输基本单元，会被切分为多个分片送达最终的目的地。

而RFC815所定义的，正是**reassembly——分片重组**这一步的具体实现算法。

> In  order  to  define this reassembly algorithm, it is necessary to define some terms. 
>
> A partially reassembled datagram consists of certain sequences of octets that have already arrived, and certain  areas  still to  come.

> We will refer to these missing areas as **"holes"**.
>
> Each hole can be characterized by two numbers:
>
> - **hole.first**
>     - the number of the first octet in the hole
> - **hole.last**
>     - the number of the last  octet  in  the hole
>
> This pair of numbers we will call the **"hole descriptor"**, 
>
> and we will assume that all of the hole descriptors for a  particular  datagram are gathered together in the **"hole descriptor list"**.

总体来说:

> The  general  form  of  the  algorithm  is  as follows.
>
> When a new fragment of the datagram arrives, it will possibly fill in one  or  more of  the existing holes.
>
> We will examine each of the entries in the hole descriptor list to see whether the hole in  question  is  eliminated  by this incoming fragment.
>
> If so, we will delete that entry from the list.
>
> Eventually, a fragment will arrive which eliminates every entry from the list.
>
> At this point, the datagram has been completely reassembled and can be passed to higher protocol levels for further processing.

具体的算法实现要分为两部分：

首先是**Fragment Processing Algorithm**

> We  start  the algorithm when the earliest fragment of the datagram arrives.  We begin by creating an empty data buffer area and putting one entry in its  hole  descriptor  list,  the  entry  which  describes  the datagram  as  being completely missing.  In this case, hole.first equals zero, and hole.last equals infinity. (Infinity is presumably implemented by a very large integer, greater than 576, of the implementor's choice.) The following eight steps are then used to insert each of  the  arriving fragments  into  the  buffer  area  where the complete datagram is being built up.  The arriving fragment is  described  by  fragment.first,  the first  octet  of  the fragment, and fragment.last, the last octet of the fragment.

接着进行如下流程：

1. Select the next hole  descriptor  from  the  hole  descriptor list.  If there are no more entries, go to step eight.
 2. If fragment.first is greater than hole.last, go to step one.
 2. If fragment.last is less than hole.first, go to step one.
 2. Delete the current entry from the hole descriptor list.
 2. If fragment.first is greater than hole.first, then  create  a new  hole  descriptor "new_hole" with new_hole.first equal to hole.first, and new_hole.last equal to  fragment.first  minus one.
 2. If fragment.last is less  than  hole.last  and  fragment.more fragments   is  true,  then  create  a  new  hole  descriptor "new_hole", with new_hole.first equal to  fragment.last  plus one and new_hole.last equal to hole.last.
 2. Go to step one.
 2. If the hole descriptor list is now empty, the datagram is now complete.  Pass it on to the higher level protocol  processor for further handling. Otherwise, return.

算法的第二部分是**Managing the Hole Descriptor List**

其中有规则：

> Just put each hole descriptor in the first octets of  the  hole  itself. 
>
> 将hole的描述符置于hole的前八个字节位置即可。
>
> Note  that by the definition of the reassembly algorithm, the minimum size of  a  hole  is  eight  octets.
>
> To  store hole.first  and  hole.last  will presumably require two octets each.  
>
> An additional two octets will be required to thread together the entries on the hole descriptor list.  
>
> This leaves at least two more octets to  dealwith implementation idiosyncrasies.

hole的最小大小是8字节。大小和U-Boot的实现是契合的：

```c
/*
 * this is the packet being assembled, either data or frag control.
 * Fragments go by 8 bytes, so this union must be 8 bytes long
 */
struct hole {
	/* first_byte is address of this structure */
	u16 last_byte;	/* last byte in this hole + 1 (begin of next hole) */
	u16 next_hole;	/* index of next (in 8-b blocks), 0 == none */
	u16 prev_hole;	/* index of prev, 0 == none */
	u16 unused;
};
```

但内容有些不同：U-Boot的实现并不包含`hole.first`域，因为 first_byte is address of this structure.

由此看来，这里的内存管理方式类似于Glibc堆内存管理方案。用双向链表管理了空闲区域（hole、free chunk），且在空闲区域内部记录自己的相关信息，最小大小为自身控制域（8-Bytes struct hole、free chunk header），并组成双向链表用于高效检索。但一个区别是，hole之间组成的链表，是借由字节索引而非指针实现的。

#### 开始分析

漏洞位置：

> In `u-boot/net/net.c` the `__net_defragment` function line 900 through 1018.

漏洞源码：

[https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900](https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900)

defragment即reassembly的操作，合并分片。注释与分析如下：

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); // packet_buffer ip_packet_size packet_align
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh; // payload this_fragment hole new_hole
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS); // IP_OFFS 0x1fff 0b0001111111111111，分片索引的基本单位为8字节
	thisfrag = payload + offset8; // 当前分片的索引（8字节）
	start = offset8 * 8; // 当前分片的字节索引
	len = ntohs(ip->ip_len) - IP_HDR_SIZE; // 攻击者通过构造恶意数据包，将ip->ip_len控制在21~27，使得len为1~7的值，触发后续漏洞

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) { // group of fragments of a single IP datagram不同，意味着新来的分片不属于同一数据报
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

    // 此后就是具体的reassembly算法实现了
	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8); // 计算new_hole的分片索引值。len为1~7的值时，会导致此处 newh == thisfrag
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); /* 这里向this_fragment中写入攻击者可控的数据，
							但由于 newh == thisfrag，造成new_hole中的控制数据被篡改（类似于free chunk header被篡改）。
							且当len为6时，first_hole中的last_byte、next_hole、prev_hole都被攻击者控制，
							由此，攻击者通过劫持hole的位置索引，造成任意地址写。*/
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

所以实际上是一个：盲目信任用户传入的IP数据报中的`ip_len`字段，造成hole结构被劫持，而导致的数组越界写漏洞。

由此达成的任意地址写可以用于root本地设备。但由于路由器往往会对经过自己的数据包合法性做校验并丢弃非法数据报，导致此漏洞难以于互联网上利用。



### CVE-2022-30552

漏洞出现位置和上个漏洞相同

```c
static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
{
	static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
	static u16 first_hole, total_len;
	struct hole *payload, *thisfrag, *h, *newh;
	struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff;
	uchar *indata = (uchar *)ip;
	int offset8, start, len, done = 0;
	u16 ip_off = ntohs(ip->ip_off);

	/* payload starts after IP header, this fragment is in there */
	payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
	offset8 =  (ip_off & IP_OFFS);
	thisfrag = payload + offset8;
	start = offset8 * 8;
	len = ntohs(ip->ip_len) - IP_HDR_SIZE; // ip->ip_len由攻击者控制，将其设定为小于IP_HDR_SIZE的值会使得len为负值

	if (start + len > IP_MAXUDP) /* fragment extends too far */
		return NULL;

	if (!total_len || localip->ip_id != ip->ip_id) {
		/* new (or different) packet, reset structs */
		total_len = 0xffff;
		payload[0].last_byte = ~0;
		payload[0].next_hole = 0;
		payload[0].prev_hole = 0;
		first_hole = 0;
		/* any IP header will work, copy the first we received */
		memcpy(localip, ip, IP_HDR_SIZE);
	}

	/*
	 * What follows is the reassembly algorithm. We use the payload
	 * array as a linked list of hole descriptors, as each hole starts
	 * at a multiple of 8 bytes. However, last byte can be whatever value,
	 * so it is represented as byte count, not as 8-byte blocks.
	 */

	h = payload + first_hole;
	while (h->last_byte < start) {
		if (!h->next_hole) {
			/* no hole that far away */
			return NULL;
		}
		h = payload + h->next_hole;
	}

	/* last fragment may be 1..7 bytes, the "+7" forces acceptance */
	if (offset8 + ((len + 7) / 8) <= h - payload) {
		/* no overlap with holes (dup fragment?) */
		return NULL;
	}

	if (!(ip_off & IP_FLAGS_MFRAG)) {
		/* no more fragmentss: truncate this (last) hole */
		total_len = start + len;
		h->last_byte = start + len;
	}

	/*
	 * There is some overlap: fix the hole list. This code doesn't
	 * deal with a fragment that overlaps with two different holes
	 * (thus being a superset of a previously-received fragment).
	 */

	if ((h >= thisfrag) && (h->last_byte <= start + len)) {
		/* complete overlap with hole: remove hole */
		if (!h->prev_hole && !h->next_hole) {
			/* last remaining hole */
			done = 1;
		} else if (!h->prev_hole) {
			/* first hole */
			first_hole = h->next_hole;
			payload[h->next_hole].prev_hole = 0;
		} else if (!h->next_hole) {
			/* last hole */
			payload[h->prev_hole].next_hole = 0;
		} else {
			/* in the middle of the list */
			payload[h->next_hole].prev_hole = h->prev_hole;
			payload[h->prev_hole].next_hole = h->next_hole;
		}

	} else if (h->last_byte <= start + len) {
		/* overlaps with final part of the hole: shorten this hole */
		h->last_byte = start;

	} else if (h >= thisfrag) {
		/* overlaps with initial part of the hole: move this hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h = newh;
		if (h->next_hole)
			payload[h->next_hole].prev_hole = (h - payload);
		if (h->prev_hole)
			payload[h->prev_hole].next_hole = (h - payload);
		else
			first_hole = (h - payload);

	} else {
		/* fragment sits in the middle: split the hole */
		newh = thisfrag + (len / 8);
		*newh = *h;
		h->last_byte = start;
		h->next_hole = (newh - payload);
		newh->prev_hole = (h - payload);
		if (newh->next_hole)
			payload[newh->next_hole].prev_hole = (newh - payload);
	}

	/* finally copy this fragment and possibly return whole packet */
	memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); // 由于len为负值，此处发生整数溢出，memcpy造成栈溢出
	if (!done)
		return NULL;

	localip->ip_len = htons(total_len);
	*lenp = total_len + IP_HDR_SIZE;
	return localip;
}
```

同样是因为盲信攻击者的IP数据报而未做校验，造成的整数溢出与栈溢出漏洞。



## 漏洞影响

由git仓库查看：

```sh
git clone https://github.com/u-boot/u-boot.git
cd u-boot
git log net/net.c
```

可以看到修复的commit：

```sh
commit b85d130ea0cac152c21ec38ac9417b31d41b5552
Author: Fabio Estevam <festevam@denx.de>
Date:   Thu May 26 11:14:37 2022 -0300
```

由此找到了漏洞的最晚影响版本，那么最早是什么时候被引入的呢？

```sh
git log --follow -p net/net.c
```

一直向前回溯`__net_defragment`的历史，能找到最早引入该函数的commit：

```sh
commit 5cfaa4e54d0eb8232fa1cf092d955fdaed5b673d
Author: Alessandro Rubini <rubini-list@gnudd.com>
Date:   Fri Aug 7 13:58:56 2009 +0200
```

所以这两个漏洞影响了2009/8/7～2022/5/26间开启了`CONFIG_IP_DEFRAG`编译选项的U-Boot。



## 漏洞修复

查看修复的patch：

```sh
git diff b85d130~ b85d13
```

得到：

```diff
diff --git a/include/net.h b/include/net.h
index 675bf4171b..e3889a0bc8 100644
--- a/include/net.h
+++ b/include/net.h
@@ -391,6 +391,8 @@ struct ip_hdr {

 #define IP_HDR_SIZE            (sizeof(struct ip_hdr))

+#define IP_MIN_FRAG_DATAGRAM_SIZE      (IP_HDR_SIZE + 8)
+
 /*
  *     Internet Protocol (IP) + UDP header.
  */
diff --git a/net/net.c b/net/net.c
index 034a5d6e67..81905f6315 100644
--- a/net/net.c
+++ b/net/net.c
@@ -907,6 +907,9 @@ static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
        int offset8, start, len, done = 0;
        u16 ip_off = ntohs(ip->ip_off);

+       if (ip->ip_len < IP_MIN_FRAG_DATAGRAM_SIZE)
+               return NULL;
+
        /* payload starts after IP header, this fragment is in there */
        payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
        offset8 =  (ip_off & IP_OFFS);
```

既然两个漏洞都是由盲信攻击者IP数据报中的ip->ip_len造成的，那么修复方案就对其做个校验就好啦。

修复代码就是添加限制：`ip->ip_len >= IP_HDR_SIZE + 8`
