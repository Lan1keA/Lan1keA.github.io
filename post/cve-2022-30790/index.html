<!DOCTYPE html>
<html lang="zh"><head>
    <meta charset="UTF-8">
    <title>やれやれ DA✰ZE</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="以及CVE-2022-30552" />
    <meta property="og:title" content="对U-Boot CVE-2022-30790的跟踪" />
    <meta property="og:description" content="以及CVE-2022-30552" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://cerr.cc/post/cve-2022-30790/" />
    <meta itemprop="name" content="对U-Boot CVE-2022-30790的跟踪">
    <meta itemprop="description" content="以及CVE-2022-30552">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon.png">
    
    <link rel="stylesheet" href="https://cerr.cc/scss/style.min.8cf7a5758f9d406f171a1184f6b6ec0a6175c7d809e6dd601dd4878d8acf96b1.css" >
</head>
<body>
    <header>
    <div class="header header-frame">
        <div>
          
            <h1 class="header__title">对U-Boot CVE-2022-30790的跟踪</h1>
          
            
                <div class="header__description">以及CVE-2022-30552</div>
            
        </div>
        <nav class="header-nav">
            <ul class="header-nav-list header-nav-list--menu">
                
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/about/">
                                
                                <span>About</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/board/">
                                
                                <span>Board</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/flink/">
                                
                                <span>Flink</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/utils/">
                                
                                <span>Utils</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/love/">
                                
                                <span>Love</span>
                            </a>
                        </li>
                    
                
                    
                        <li class="header-nav-list__item">
                            <a class="header-nav-list__link" href="/main/ilus/">
                                
                                <span>Ilus</span>
                            </a>
                        </li>
                    
                
            </ul>
            <button class="header-nav-list__nav-btn">~#</button>
        </nav>
        <button class="mb-header__menu-btn">
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
            <span class="mb-header__menu-btn-line"></span>
        </button>
    </div>
    <nav id="mobile-header-nav" class="mb-header-nav">
  
  
  <button class="mb-header-nav__close-btn flex-center">
    <svg
            class="mb-header-nav__svg-icon"
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            width="32"
            height="32"
            >
            <path
                d="M19 6.41L17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"
                />
            <path d="M0 0h24v24H0z" fill="none" />
        </svg>
    </button>
    
    <div class="mb-header-nav__wrapper">
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Tags
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                    
                        
                          <li class="mb-header-nav-list__item ">
                        <a class="mb-header-nav-list__link" href="https://cerr.cc/tags/vulnerability/"
                                                            >Vulnerability</a
                                                        >
                    </li>
                        
                    
                
            </ul>
        </div>
        <div class="mb-header-nav__container">
            <svg
                width="240"
                height="72"
                viewBox="0 0 240 72"
                class="mb-header-nav__title"
                >
                <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle">
                Menu
                </text>
            </svg>
            <ul class="mb-header-nav-list">
                
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/about/">
                                About
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/board/">
                                Board
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/flink/">
                                Flink
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/utils/">
                                Utils
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/love/">
                                Love
                            </a>
                        </li>
                    
                
                    
                      <li class="mb-header-nav-list__item ">
                            <a class="mb-header-nav-list__link" href="/main/ilus/">
                                Ilus
                            </a>
                        </li>
                    
                
            </ul>
        </div>
    </div>
</nav>

</header>



    <div id="content">
<article class="post">
  
    <div class="post-content"><h1 id="u-boot速览">U-Boot速览</h1>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Das_U-Boot">Das U-Boot - Wikipedia</a></li>
<li><a href="https://github.com/u-boot/u-boot">https://github.com/u-boot/u-boot</a></li>
<li><a href="https://elixir.bootlin.com/u-boot/latest/source">U-Boot源码在线浏览</a></li>
</ul>
<h1 id="村中传言">村中传言</h1>
<p><strong><a href="https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/">https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/</a></strong></p>
<p>🤔Hmmm&hellip;新鲜漏洞，没有PoC。这次是出了两个漏洞，分别是：</p>
<ul>
<li>Hole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30790">CVE-2022-30790</a>)</li>
<li>Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code (<a href="https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2022-30552">CVE-2022-30552</a>)</li>
</ul>
<p>先来分析分析出现漏洞的源码。根据：</p>
<blockquote>
<p><strong>May 18th 2022:</strong> Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified.</p>
</blockquote>
<p>那么用U-Boot v2022.04跟踪漏洞应该是没有问题的。</p>
<h1 id="漏洞源码分析">漏洞源码分析</h1>
<h2 id="cve-2022-30790">CVE-2022-30790</h2>
<p>漏洞影响：</p>
<blockquote>
<p>The U-Boot implementation of <a href="https://datatracker.ietf.org/doc/html/rfc815">RFC815</a> IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.</p>
</blockquote>
<h3 id="rfc815">RFC815</h3>
<p>看来需要先了解下RFC815的IPv4分片算法：</p>
<ul>
<li>原文档：<a href="https://datatracker.ietf.org/doc/html/rfc815">https://datatracker.ietf.org/doc/html/rfc815</a></li>
<li>一篇相关论文：<a href="http://www.ecice06.com/CN/Y2008/V34/I22/100">http://www.ecice06.com/CN/Y2008/V34/I22/100</a></li>
</ul>
<blockquote>
<p>RFC815 是 IETF 推荐的一种分片重组算法，该算法具有记录分片简洁，内存需求量与原 IPv4 数据报大小一致等优点。</p>
</blockquote>
<p>该算法的作用对象是IPv4数据报。IPv4数据报的Header结构如下：(ref - <a href="https://en.wikipedia.org/wiki/IPv4">https://en.wikipedia.org/wiki/IPv4</a></p>
<p><img src="https://s2.loli.net/2022/06/16/nlCgH1URZ7uXwQ3.png" alt="image.png"></p>
<p>其中，分片信息记录在：</p>
<ul>
<li>
<p><strong>Identification</strong></p>
<ul>
<li>This field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use.</li>
</ul>
</li>
<li>
<p><strong>Flags</strong></p>
<ul>
<li>
<p>A three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):</p>
<ul>
<li>bit 0: Reserved; must be zero</li>
<li>bit 1: Don&rsquo;t Fragment (DF)</li>
<li>bit 2: More Fragments (MF)</li>
</ul>
<p>If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for <a href="https://en.wikipedia.org/wiki/Path_MTU_discovery">path MTU discovery</a>, either automatically by the host IP software, or manually using diagnostic tools such as <a href="https://en.wikipedia.org/wiki/Ping_(networking_utility)">ping</a> or <a href="https://en.wikipedia.org/wiki/Traceroute">traceroute</a>.</p>
<p>For unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.</p>
</li>
</ul>
</li>
<li>
<p><strong>Fragment Offset</strong></p>
<ul>
<li>This field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram <strong>in units of eight-byte blocks</strong>. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (2<sup>13</sup> – 1) × 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes.</li>
</ul>
</li>
</ul>
<p>注意到分片的索引单位为8字节。</p>
<p>好了，简单了解过数据结构，接着来看看算法。</p>
<p>原文档有言：</p>
<blockquote>
<p>One of the mechanisms of IP is fragmentation and reassembly.</p>
<p>分片和重组是IPv4协议的一个机制。(文档很老，那时还没有IPv6。In contrast, <a href="https://en.wikipedia.org/wiki/IPv6">IPv6</a>, the next generation of the Internet Protocol, does not allow routers to perform fragmentation; hosts must perform <a href="https://en.wikipedia.org/wiki/Path_MTU_Discovery">Path MTU Discovery</a> before sending datagrams.)</p>
</blockquote>
<blockquote>
<p>A  datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.</p>
<p>一个数据报——作为传输基本单元，会被切分为多个分片送达最终的目的地。</p>
</blockquote>
<p>而RFC815所定义的，正是<strong>reassembly——分片重组</strong>这一步的具体实现算法。</p>
<blockquote>
<p>In  order  to  define this reassembly algorithm, it is necessary to define some terms.</p>
<p>A partially reassembled datagram consists of certain sequences of octets that have already arrived, and certain  areas  still to  come.</p>
</blockquote>
<blockquote>
<p>We will refer to these missing areas as <strong>&ldquo;holes&rdquo;</strong>.</p>
<p>Each hole can be characterized by two numbers:</p>
<ul>
<li><strong>hole.first</strong>
<ul>
<li>the number of the first octet in the hole</li>
</ul>
</li>
<li><strong>hole.last</strong>
<ul>
<li>the number of the last  octet  in  the hole</li>
</ul>
</li>
</ul>
<p>This pair of numbers we will call the <strong>&ldquo;hole descriptor&rdquo;</strong>,</p>
<p>and we will assume that all of the hole descriptors for a  particular  datagram are gathered together in the <strong>&ldquo;hole descriptor list&rdquo;</strong>.</p>
</blockquote>
<p>总体来说:</p>
<blockquote>
<p>The  general  form  of  the  algorithm  is  as follows.</p>
<p>When a new fragment of the datagram arrives, it will possibly fill in one  or  more of  the existing holes.</p>
<p>We will examine each of the entries in the hole descriptor list to see whether the hole in  question  is  eliminated  by this incoming fragment.</p>
<p>If so, we will delete that entry from the list.</p>
<p>Eventually, a fragment will arrive which eliminates every entry from the list.</p>
<p>At this point, the datagram has been completely reassembled and can be passed to higher protocol levels for further processing.</p>
</blockquote>
<p>具体的算法实现要分为两部分：</p>
<p>首先是<strong>Fragment Processing Algorithm</strong></p>
<blockquote>
<p>We  start  the algorithm when the earliest fragment of the datagram arrives.  We begin by creating an empty data buffer area and putting one entry in its  hole  descriptor  list,  the  entry  which  describes  the datagram  as  being completely missing.  In this case, hole.first equals zero, and hole.last equals infinity. (Infinity is presumably implemented by a very large integer, greater than 576, of the implementor&rsquo;s choice.) The following eight steps are then used to insert each of  the  arriving fragments  into  the  buffer  area  where the complete datagram is being built up.  The arriving fragment is  described  by  fragment.first,  the first  octet  of  the fragment, and fragment.last, the last octet of the fragment.</p>
</blockquote>
<p>接着进行如下流程：</p>
<ol>
<li>Select the next hole  descriptor  from  the  hole  descriptor list.  If there are no more entries, go to step eight.</li>
<li>If fragment.first is greater than hole.last, go to step one.</li>
<li>If fragment.last is less than hole.first, go to step one.</li>
<li>Delete the current entry from the hole descriptor list.</li>
<li>If fragment.first is greater than hole.first, then  create  a new  hole  descriptor &ldquo;new_hole&rdquo; with new_hole.first equal to hole.first, and new_hole.last equal to  fragment.first  minus one.</li>
<li>If fragment.last is less  than  hole.last  and  fragment.more fragments   is  true,  then  create  a  new  hole  descriptor &ldquo;new_hole&rdquo;, with new_hole.first equal to  fragment.last  plus one and new_hole.last equal to hole.last.</li>
<li>Go to step one.</li>
<li>If the hole descriptor list is now empty, the datagram is now complete.  Pass it on to the higher level protocol  processor for further handling. Otherwise, return.</li>
</ol>
<p>算法的第二部分是<strong>Managing the Hole Descriptor List</strong></p>
<p>其中有规则：</p>
<blockquote>
<p>Just put each hole descriptor in the first octets of  the  hole  itself.</p>
<p>将hole的描述符置于hole的前八个字节位置即可。</p>
<p>Note  that by the definition of the reassembly algorithm, the minimum size of  a  hole  is  eight  octets.</p>
<p>To  store hole.first  and  hole.last  will presumably require two octets each.</p>
<p>An additional two octets will be required to thread together the entries on the hole descriptor list.</p>
<p>This leaves at least two more octets to  dealwith implementation idiosyncrasies.</p>
</blockquote>
<p>hole的最小大小是8字节。大小和U-Boot的实现是契合的：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * this is the packet being assembled, either data or frag control.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> * Fragments go by 8 bytes, so this union must be 8 bytes long
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"> */</span>
</span></span><span style="display:flex;"><span><span style="color:#000;font-weight:bold">struct</span> hole {
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* first_byte is address of this structure */</span>
</span></span><span style="display:flex;"><span>	u16 last_byte;	<span style="color:#998;font-style:italic">/* last byte in this hole + 1 (begin of next hole) */</span>
</span></span><span style="display:flex;"><span>	u16 next_hole;	<span style="color:#998;font-style:italic">/* index of next (in 8-b blocks), 0 == none */</span>
</span></span><span style="display:flex;"><span>	u16 prev_hole;	<span style="color:#998;font-style:italic">/* index of prev, 0 == none */</span>
</span></span><span style="display:flex;"><span>	u16 unused;
</span></span><span style="display:flex;"><span>};
</span></span></code></pre></div><p>但内容有些不同：U-Boot的实现并不包含<code>hole.first</code>域，因为 first_byte is address of this structure.</p>
<p>由此看来，这里的内存管理方式类似于Glibc堆内存管理方案。用双向链表管理了空闲区域（hole、free chunk），且在空闲区域内部记录自己的相关信息，最小大小为自身控制域（8-Bytes struct hole、free chunk header），并组成双向链表用于高效检索。但一个区别是，hole之间组成的链表，是借由字节索引而非指针实现的。</p>
<h3 id="开始分析">开始分析</h3>
<p>漏洞位置：</p>
<blockquote>
<p>In <code>u-boot/net/net.c</code> the <code>__net_defragment</code> function line 900 through 1018.</p>
</blockquote>
<p>漏洞源码：</p>
<p><a href="https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900">https://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900</a></p>
<p>defragment即reassembly的操作，合并分片。注释与分析如下：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">__net_defragment</span>(<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>ip, <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>lenp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); <span style="color:#998;font-style:italic">// packet_buffer ip_packet_size packet_align
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">static</span> u16 first_hole, total_len;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>payload, <span style="color:#000;font-weight:bold">*</span>thisfrag, <span style="color:#000;font-weight:bold">*</span>h, <span style="color:#000;font-weight:bold">*</span>newh; <span style="color:#998;font-style:italic">// payload this_fragment hole new_hole
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>localip <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>)pkt_buff;
</span></span><span style="display:flex;"><span>	uchar <span style="color:#000;font-weight:bold">*</span>indata <span style="color:#000;font-weight:bold">=</span> (uchar <span style="color:#000;font-weight:bold">*</span>)ip;
</span></span><span style="display:flex;"><span>	<span style="color:#458;font-weight:bold">int</span> offset8, start, len, done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>	u16 ip_off <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* payload starts after IP header, this fragment is in there */</span>
</span></span><span style="display:flex;"><span>	payload <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>)(pkt_buff <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	offset8 <span style="color:#000;font-weight:bold">=</span>  (ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_OFFS); <span style="color:#998;font-style:italic">// IP_OFFS 0x1fff 0b0001111111111111，分片索引的基本单位为8字节
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	thisfrag <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> offset8; <span style="color:#998;font-style:italic">// 当前分片的索引（8字节）
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	start <span style="color:#000;font-weight:bold">=</span> offset8 <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">8</span>; <span style="color:#998;font-style:italic">// 当前分片的字节索引
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	len <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len) <span style="color:#000;font-weight:bold">-</span> IP_HDR_SIZE; <span style="color:#998;font-style:italic">// 攻击者通过构造恶意数据包，将ip-&gt;ip_len控制在21~27，使得len为1~7的值，触发后续漏洞
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (start <span style="color:#000;font-weight:bold">+</span> len <span style="color:#000;font-weight:bold">&gt;</span> IP_MAXUDP) <span style="color:#998;font-style:italic">/* fragment extends too far */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>total_len <span style="color:#000;font-weight:bold">||</span> localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id <span style="color:#000;font-weight:bold">!=</span> ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id) { <span style="color:#998;font-style:italic">// group of fragments of a single IP datagram不同，意味着新来的分片不属于同一数据报
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#998;font-style:italic">/* new (or different) packet, reset structs */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].last_byte <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		first_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* any IP header will work, copy the first we received */</span>
</span></span><span style="display:flex;"><span>		memcpy(localip, ip, IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#998;font-style:italic">// 此后就是具体的reassembly算法实现了
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * What follows is the reassembly algorithm. We use the payload
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * array as a linked list of hole descriptors, as each hole starts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * at a multiple of 8 bytes. However, last byte can be whatever value,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * so it is represented as byte count, not as 8-byte blocks.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> first_hole;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">while</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;</span> start) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* no hole that far away */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* last fragment may be 1..7 bytes, the &#34;+7&#34; forces acceptance */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (offset8 <span style="color:#000;font-weight:bold">+</span> ((len <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>) <span style="color:#000;font-weight:bold">&lt;=</span> h <span style="color:#000;font-weight:bold">-</span> payload) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no overlap with holes (dup fragment?) */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>(ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_FLAGS_MFRAG)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no more fragmentss: truncate this (last) hole */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * There is some overlap: fix the hole list. This code doesn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * deal with a fragment that overlaps with two different holes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * (thus being a superset of a previously-received fragment).
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> ((h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) <span style="color:#000;font-weight:bold">&amp;&amp;</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* complete overlap with hole: remove hole */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last remaining hole */</span>
</span></span><span style="display:flex;"><span>			done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* first hole */</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last hole */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* in the middle of the list */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with final part of the hole: shorten this hole */</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with initial part of the hole: move this hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>); <span style="color:#998;font-style:italic">// 计算new_hole的分片索引值。len为1~7的值时，会导致此处 newh == thisfrag
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> newh;
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* fragment sits in the middle: split the hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		newh<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* finally copy this fragment and possibly return whole packet */</span>
</span></span><span style="display:flex;"><span>	memcpy((uchar <span style="color:#000;font-weight:bold">*</span>)thisfrag, indata <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE, len); <span style="color:#998;font-style:italic">/* 这里向this_fragment中写入攻击者可控的数据，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							但由于 newh == thisfrag，造成new_hole中的控制数据被篡改（类似于free chunk header被篡改）。
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							且当len为6时，first_hole中的last_byte、next_hole、prev_hole都被攻击者控制，
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">							由此，攻击者通过劫持hole的位置索引，造成任意地址写。*/</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>done)
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len <span style="color:#000;font-weight:bold">=</span> htons(total_len);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">*</span>lenp <span style="color:#000;font-weight:bold">=</span> total_len <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> localip;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>所以实际上是一个：盲目信任用户传入的IP数据报中的<code>ip_len</code>字段，造成hole结构被劫持，而导致的数组越界写漏洞。</p>
<p>由此达成的任意地址写可以用于root本地设备。但由于路由器往往会对经过自己的数据包合法性做校验并丢弃非法数据报，导致此漏洞难以于互联网上利用。</p>
<h2 id="cve-2022-30552">CVE-2022-30552</h2>
<p>漏洞出现位置和上个漏洞相同</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-c" data-lang="c"><span style="display:flex;"><span><span style="color:#000;font-weight:bold">static</span> <span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span><span style="color:#900;font-weight:bold">__net_defragment</span>(<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>ip, <span style="color:#458;font-weight:bold">int</span> <span style="color:#000;font-weight:bold">*</span>lenp)
</span></span><span style="display:flex;"><span>{
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">static</span> u16 first_hole, total_len;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>payload, <span style="color:#000;font-weight:bold">*</span>thisfrag, <span style="color:#000;font-weight:bold">*</span>h, <span style="color:#000;font-weight:bold">*</span>newh;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>localip <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> ip_udp_hdr <span style="color:#000;font-weight:bold">*</span>)pkt_buff;
</span></span><span style="display:flex;"><span>	uchar <span style="color:#000;font-weight:bold">*</span>indata <span style="color:#000;font-weight:bold">=</span> (uchar <span style="color:#000;font-weight:bold">*</span>)ip;
</span></span><span style="display:flex;"><span>	<span style="color:#458;font-weight:bold">int</span> offset8, start, len, done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>	u16 ip_off <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* payload starts after IP header, this fragment is in there */</span>
</span></span><span style="display:flex;"><span>	payload <span style="color:#000;font-weight:bold">=</span> (<span style="color:#000;font-weight:bold">struct</span> hole <span style="color:#000;font-weight:bold">*</span>)(pkt_buff <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	offset8 <span style="color:#000;font-weight:bold">=</span>  (ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_OFFS);
</span></span><span style="display:flex;"><span>	thisfrag <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> offset8;
</span></span><span style="display:flex;"><span>	start <span style="color:#000;font-weight:bold">=</span> offset8 <span style="color:#000;font-weight:bold">*</span> <span style="color:#099">8</span>;
</span></span><span style="display:flex;"><span>	len <span style="color:#000;font-weight:bold">=</span> ntohs(ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len) <span style="color:#000;font-weight:bold">-</span> IP_HDR_SIZE; <span style="color:#998;font-style:italic">// ip-&gt;ip_len由攻击者控制，将其设定为小于IP_HDR_SIZE的值会使得len为负值
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (start <span style="color:#000;font-weight:bold">+</span> len <span style="color:#000;font-weight:bold">&gt;</span> IP_MAXUDP) <span style="color:#998;font-style:italic">/* fragment extends too far */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>total_len <span style="color:#000;font-weight:bold">||</span> localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id <span style="color:#000;font-weight:bold">!=</span> ip<span style="color:#000;font-weight:bold">-&gt;</span>ip_id) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* new (or different) packet, reset structs */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0xffff</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].last_byte <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">~</span><span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		payload[<span style="color:#099">0</span>].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		first_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* any IP header will work, copy the first we received */</span>
</span></span><span style="display:flex;"><span>		memcpy(localip, ip, IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * What follows is the reassembly algorithm. We use the payload
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * array as a linked list of hole descriptors, as each hole starts
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * at a multiple of 8 bytes. However, last byte can be whatever value,
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * so it is represented as byte count, not as 8-byte blocks.
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> first_hole;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">while</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;</span> start) {
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* no hole that far away */</span>
</span></span><span style="display:flex;"><span>			<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> payload <span style="color:#000;font-weight:bold">+</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* last fragment may be 1..7 bytes, the &#34;+7&#34; forces acceptance */</span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (offset8 <span style="color:#000;font-weight:bold">+</span> ((len <span style="color:#000;font-weight:bold">+</span> <span style="color:#099">7</span>) <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>) <span style="color:#000;font-weight:bold">&lt;=</span> h <span style="color:#000;font-weight:bold">-</span> payload) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no overlap with holes (dup fragment?) */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>(ip_off <span style="color:#000;font-weight:bold">&amp;</span> IP_FLAGS_MFRAG)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* no more fragmentss: truncate this (last) hole */</span>
</span></span><span style="display:flex;"><span>		total_len <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start <span style="color:#000;font-weight:bold">+</span> len;
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/*
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * There is some overlap: fix the hole list. This code doesn&#39;t
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * deal with a fragment that overlaps with two different holes
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 * (thus being a superset of a previously-received fragment).
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic">	 */</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">if</span> ((h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) <span style="color:#000;font-weight:bold">&amp;&amp;</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len)) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* complete overlap with hole: remove hole */</span>
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">&amp;&amp;</span> <span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last remaining hole */</span>
</span></span><span style="display:flex;"><span>			done <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">1</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* first hole */</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole) {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* last hole */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> <span style="color:#099">0</span>;
</span></span><span style="display:flex;"><span>		} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>			<span style="color:#998;font-style:italic">/* in the middle of the list */</span>
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole;
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole;
</span></span><span style="display:flex;"><span>		}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">&lt;=</span> start <span style="color:#000;font-weight:bold">+</span> len) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with final part of the hole: shorten this hole */</span>
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> <span style="color:#000;font-weight:bold">if</span> (h <span style="color:#000;font-weight:bold">&gt;=</span> thisfrag) {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* overlaps with initial part of the hole: move this hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h <span style="color:#000;font-weight:bold">=</span> newh;
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole)
</span></span><span style="display:flex;"><span>			payload[h<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole].next_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">else</span>
</span></span><span style="display:flex;"><span>			first_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	} <span style="color:#000;font-weight:bold">else</span> {
</span></span><span style="display:flex;"><span>		<span style="color:#998;font-style:italic">/* fragment sits in the middle: split the hole */</span>
</span></span><span style="display:flex;"><span>		newh <span style="color:#000;font-weight:bold">=</span> thisfrag <span style="color:#000;font-weight:bold">+</span> (len <span style="color:#000;font-weight:bold">/</span> <span style="color:#099">8</span>);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">*</span>newh <span style="color:#000;font-weight:bold">=</span> <span style="color:#000;font-weight:bold">*</span>h;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>last_byte <span style="color:#000;font-weight:bold">=</span> start;
</span></span><span style="display:flex;"><span>		h<span style="color:#000;font-weight:bold">-&gt;</span>next_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		newh<span style="color:#000;font-weight:bold">-&gt;</span>prev_hole <span style="color:#000;font-weight:bold">=</span> (h <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">if</span> (newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole)
</span></span><span style="display:flex;"><span>			payload[newh<span style="color:#000;font-weight:bold">-&gt;</span>next_hole].prev_hole <span style="color:#000;font-weight:bold">=</span> (newh <span style="color:#000;font-weight:bold">-</span> payload);
</span></span><span style="display:flex;"><span>	}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	<span style="color:#998;font-style:italic">/* finally copy this fragment and possibly return whole packet */</span>
</span></span><span style="display:flex;"><span>	memcpy((uchar <span style="color:#000;font-weight:bold">*</span>)thisfrag, indata <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE, len); <span style="color:#998;font-style:italic">// 由于len为负值，此处发生整数溢出，memcpy造成栈溢出
</span></span></span><span style="display:flex;"><span><span style="color:#998;font-style:italic"></span>	<span style="color:#000;font-weight:bold">if</span> (<span style="color:#000;font-weight:bold">!</span>done)
</span></span><span style="display:flex;"><span>		<span style="color:#000;font-weight:bold">return</span> <span style="color:#0086b3">NULL</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	localip<span style="color:#000;font-weight:bold">-&gt;</span>ip_len <span style="color:#000;font-weight:bold">=</span> htons(total_len);
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">*</span>lenp <span style="color:#000;font-weight:bold">=</span> total_len <span style="color:#000;font-weight:bold">+</span> IP_HDR_SIZE;
</span></span><span style="display:flex;"><span>	<span style="color:#000;font-weight:bold">return</span> localip;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>同样是因为盲信攻击者的IP数据报而未做校验，造成的整数溢出与栈溢出漏洞。</p>
<h1 id="漏洞影响">漏洞影响</h1>
<p>由git仓库查看：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/u-boot/u-boot.git
</span></span><span style="display:flex;"><span><span style="color:#0086b3">cd</span> u-boot
</span></span><span style="display:flex;"><span>git log net/net.c
</span></span></code></pre></div><p>可以看到修复的commit：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>commit b85d130ea0cac152c21ec38ac9417b31d41b5552
</span></span><span style="display:flex;"><span>Author: Fabio Estevam &lt;festevam@denx.de&gt;
</span></span><span style="display:flex;"><span>Date:   Thu May <span style="color:#099">26</span> 11:14:37 <span style="color:#099">2022</span> -0300
</span></span></code></pre></div><p>由此找到了漏洞的最晚影响版本，那么最早是什么时候被引入的呢？</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git log --follow -p net/net.c
</span></span></code></pre></div><p>一直向前回溯<code>__net_defragment</code>的历史，能找到最早引入该函数的commit：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>commit 5cfaa4e54d0eb8232fa1cf092d955fdaed5b673d
</span></span><span style="display:flex;"><span>Author: Alessandro Rubini &lt;rubini-list@gnudd.com&gt;
</span></span><span style="display:flex;"><span>Date:   Fri Aug <span style="color:#099">7</span> 13:58:56 <span style="color:#099">2009</span> +0200
</span></span></code></pre></div><p>所以这两个漏洞影响了2009/8/7～2022/5/26间开启了<code>CONFIG_IP_DEFRAG</code>编译选项的U-Boot。</p>
<h1 id="漏洞修复">漏洞修复</h1>
<p>查看修复的patch：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git diff b85d130~ b85d13
</span></span></code></pre></div><p>得到：</p>
<div class="highlight"><pre tabindex="0" style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-diff" data-lang="diff"><span style="display:flex;"><span><span style="color:#999">diff --git a/include/net.h b/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#999">index 675bf4171b..e3889a0bc8 100644
</span></span></span><span style="display:flex;"><span><span style="color:#999"></span><span style="color:#000;background-color:#fdd">--- a/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#fdd"></span><span style="color:#000;background-color:#dfd">+++ b/include/net.h
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span><span style="color:#aaa">@@ -391,6 +391,8 @@ struct ip_hdr {
</span></span></span><span style="display:flex;"><span><span style="color:#aaa"></span>
</span></span><span style="display:flex;"><span> #define IP_HDR_SIZE            (sizeof(struct ip_hdr))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+#define IP_MIN_FRAG_DATAGRAM_SIZE      (IP_HDR_SIZE + 8)
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span> /*
</span></span><span style="display:flex;"><span>  *     Internet Protocol (IP) + UDP header.
</span></span><span style="display:flex;"><span>  */
</span></span><span style="display:flex;"><span><span style="color:#999">diff --git a/net/net.c b/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#999">index 034a5d6e67..81905f6315 100644
</span></span></span><span style="display:flex;"><span><span style="color:#999"></span><span style="color:#000;background-color:#fdd">--- a/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#fdd"></span><span style="color:#000;background-color:#dfd">+++ b/net/net.c
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span><span style="color:#aaa">@@ -907,6 +907,9 @@ static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp)
</span></span></span><span style="display:flex;"><span><span style="color:#aaa"></span>        int offset8, start, len, done = 0;
</span></span><span style="display:flex;"><span>        u16 ip_off = ntohs(ip-&gt;ip_off);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+       if (ip-&gt;ip_len &lt; IP_MIN_FRAG_DATAGRAM_SIZE)
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+               return NULL;
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd">+
</span></span></span><span style="display:flex;"><span><span style="color:#000;background-color:#dfd"></span>        /* payload starts after IP header, this fragment is in there */
</span></span><span style="display:flex;"><span>        payload = (struct hole *)(pkt_buff + IP_HDR_SIZE);
</span></span><span style="display:flex;"><span>        offset8 =  (ip_off &amp; IP_OFFS);
</span></span></code></pre></div><p>既然两个漏洞都是由盲信攻击者IP数据报中的ip-&gt;ip_len造成的，那么修复方案就对其做个校验就好啦。</p>
<p>修复代码就是添加限制：<code>ip-&gt;ip_len &gt;= IP_HDR_SIZE + 8</code></p>
</div>
  
</article>
<button class="floating-button">
    <a class="floating-button__link" href="https://cerr.cc/">
        <span style="font-size: large; font-family: monospace; font-weight: bolder;">~</span>
    </a>
</button>


    </div>
    
    <footer class="post-footer">
    <div class="footer">
        
            <div>© 2022, Zikey Vi</div>
        
        <div class="footer__socials">


<a
  href="mailto:dev2ero@foxmail.com"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Gmail</title><path d="M24 5.457v13.909c0 .904-.732 1.636-1.636 1.636h-3.819V11.73L12 16.64l-6.545-4.91v9.273H1.636A1.636 1.636 0 0 1 0 19.366V5.457c0-2.023 2.309-3.178 3.927-1.964L5.455 4.64 12 9.548l6.545-4.91 1.528-1.145C21.69 2.28 24 3.434 24 5.457z"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://github.com/dev2ero"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>GitHub</title><path d="M12 .297c-6.63 0-12 5.373-12 12 0 5.303 3.438 9.8 8.205 11.385.6.113.82-.258.82-.577 0-.285-.01-1.04-.015-2.04-3.338.724-4.042-1.61-4.042-1.61C4.422 18.07 3.633 17.7 3.633 17.7c-1.087-.744.084-.729.084-.729 1.205.084 1.838 1.236 1.838 1.236 1.07 1.835 2.809 1.305 3.495.998.108-.776.417-1.305.76-1.605-2.665-.3-5.466-1.332-5.466-5.93 0-1.31.465-2.38 1.235-3.22-.135-.303-.54-1.523.105-3.176 0 0 1.005-.322 3.3 1.23.96-.267 1.98-.399 3-.405 1.02.006 2.04.138 3 .405 2.28-1.552 3.285-1.23 3.285-1.23.645 1.653.24 2.873.12 3.176.765.84 1.23 1.91 1.23 3.22 0 4.61-2.805 5.625-5.475 5.92.42.36.81 1.096.81 2.22 0 1.606-.015 2.896-.015 3.286 0 .315.21.69.825.57C20.565 22.092 24 17.592 24 12.297c0-6.627-5.373-12-12-12"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://twitter.com/dev2ero"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Twitter</title><path d="M23.953 4.57a10 10 0 01-2.825.775 4.958 4.958 0 002.163-2.723c-.951.555-2.005.959-3.127 1.184a4.92 4.92 0 00-8.384 4.482C7.69 8.095 4.067 6.13 1.64 3.162a4.822 4.822 0 00-.666 2.475c0 1.71.87 3.213 2.188 4.096a4.904 4.904 0 01-2.228-.616v.06a4.923 4.923 0 003.946 4.827 4.996 4.996 0 01-2.212.085 4.936 4.936 0 004.604 3.417 9.867 9.867 0 01-6.102 2.105c-.39 0-.779-.023-1.17-.067a13.995 13.995 0 007.557 2.209c9.053 0 13.998-7.496 13.998-13.985 0-.21 0-.42-.015-.63A9.935 9.935 0 0024 4.59z"/></svg>
</a>&nbsp;&nbsp;



<a
  href="https://space.bilibili.com/210892014"
  target="_blank"
  class="social-link"
  rel="noopener"
>
  <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><title>Bilibili</title><path d="M17.813 4.653h.854c1.51.054 2.769.578 3.773 1.574 1.004.995 1.524 2.249 1.56 3.76v7.36c-.036 1.51-.556 2.769-1.56 3.773s-2.262 1.524-3.773 1.56H5.333c-1.51-.036-2.769-.556-3.773-1.56S.036 18.858 0 17.347v-7.36c.036-1.511.556-2.765 1.56-3.76 1.004-.996 2.262-1.52 3.773-1.574h.774l-1.174-1.12a1.234 1.234 0 0 1-.373-.906c0-.356.124-.658.373-.907l.027-.027c.267-.249.573-.373.92-.373.347 0 .653.124.92.373L9.653 4.44c.071.071.134.142.187.213h4.267a.836.836 0 0 1 .16-.213l2.853-2.747c.267-.249.573-.373.92-.373.347 0 .662.151.929.4.267.249.391.551.391.907 0 .355-.124.657-.373.906zM5.333 7.24c-.746.018-1.373.276-1.88.773-.506.498-.769 1.13-.786 1.894v7.52c.017.764.28 1.395.786 1.893.507.498 1.134.756 1.88.773h13.334c.746-.017 1.373-.275 1.88-.773.506-.498.769-1.129.786-1.893v-7.52c-.017-.765-.28-1.396-.786-1.894-.507-.497-1.134-.755-1.88-.773zM8 11.107c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c0-.373.129-.689.386-.947.258-.257.574-.386.947-.386zm8 0c.373 0 .684.124.933.373.25.249.383.569.4.96v1.173c-.017.391-.15.711-.4.96-.249.25-.56.374-.933.374s-.684-.125-.933-.374c-.25-.249-.383-.569-.4-.96V12.44c.017-.391.15-.711.4-.96.249-.249.56-.373.933-.373Z"/></svg>
</a>

</div>
    </div>
</footer>


    
    
      
<script src="https://cerr.cc/js/script.js"></script>

    
  </body>
</html>
