<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Zikey Vi</title>
    <link>https://dev2ero.github.io/post/</link>
    <description>Recent content in Posts on Zikey Vi</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh</language>
    <copyright>© 2022, Zikey Vi</copyright>
    <lastBuildDate>Thu, 26 May 2022 15:51:22 +0800</lastBuildDate><atom:link href="https://dev2ero.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>记一次qemu-system-arm的排错</title>
      <link>https://dev2ero.github.io/post/qemu_armv8_dbg/</link>
      <pubDate>Thu, 26 May 2022 15:51:22 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/qemu_armv8_dbg/</guid>
      <description>探案 在一次尝试使用qemu-system-arm对于asuswrt的固件进行仿真运行时，出现了十分诡异的问题：整个qemu-system、linux内核、固件文件系统运行完全正常，除了在使用到openssl时：
admin@(none):/tmp/home/root# openssl [ 9.765639] openssl (274): undefined instruction: pc=b6cf31a8 [ 9.765770] CPU: 0 PID: 274 Comm: openssl Tainted: G W 4.1.17+ #10 [ 9.766031] Hardware name: Generic DT based system [ 9.766149] task: cef58b40 ti: cef80000 task.ti: cef80000 [ 9.766367] PC is at 0xb6cf31a8 [ 9.766423] LR is at 0xb6dcedb0 [ 9.766475] pc : [&amp;lt;b6cf31a8&amp;gt;] lr : [&amp;lt;b6dcedb0&amp;gt;] psr: 200b0010 [ 9.766475] sp : bee2c7c8 ip : 00000000 fp : 00000000 [ 9.</description>
    </item>
    
    <item>
      <title>CVE-2016-5195 Linux DirtyCOW漏洞分析</title>
      <link>https://dev2ero.github.io/post/cve-2016-5195/</link>
      <pubDate>Tue, 24 May 2022 17:43:25 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/cve-2016-5195/</guid>
      <description>https://dirtycow.ninja/</description>
    </item>
    
    <item>
      <title>关于Linux下的网卡与网络设备</title>
      <link>https://dev2ero.github.io/post/nic/</link>
      <pubDate>Mon, 23 May 2022 23:21:12 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/nic/</guid>
      <description>ip与ifconfig命令输出 ~$ ip a eth0: &amp;lt;BROADCAST,MULTICAST,UP,LOWER_UP&amp;gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000  link/ether 00:0c:29:02:e4:a7 brd ff:ff:ff:ff:ff:ff  inet 192.168.188.129/24 brd 192.168.188.255 scope global dynamic noprefixroute eth0  valid_lft 1126sec preferred_lft 1126sec  inet6 fe80::20c:29ff:fe02:e4a7/64 scope link noprefixroute  valid_lft forever preferred_lft forever  ~$ ifconfig eth0: flags=4163&amp;lt;UP,BROADCAST,RUNNING,MULTICAST&amp;gt; mtu 1500  inet 192.168.188.129 netmask 255.255.255.0 broadcast 192.168.188.255  inet6 fe80::20c:29ff:fe02:e4a7 prefixlen 64 scopeid 0x20&amp;lt;link&amp;gt;  ether 00:0c:29:02:e4:a7 txqueuelen 1000 (Ethernet)  RX packets 959 bytes 62153 (60.</description>
    </item>
    
    <item>
      <title>CVE-2014-0160 心脏滴血漏洞挖掘与分析</title>
      <link>https://dev2ero.github.io/post/cve-2014-0160/</link>
      <pubDate>Fri, 20 May 2022 17:57:07 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/cve-2014-0160/</guid>
      <description>漏洞编号：CVE-2014-0160
漏洞类型：内存越界访问
漏洞危害：信息泄露
影响范围：OpenSSL1.0.1、OpenSSL 1.0.1a~ OpenSSL 1.0.1f、OpenSSL 1.0.2-beta
漏洞描述：OpenSSL 在实现 TLS（传输层安全协议）和 DTLS（数据报安全传输协议）的心跳包处理逻辑时存在问题。OpenSSL 的 Heartbleed 模块在处理心跳包时没有检查心跳包中的长度字段是否与后续的数据字段一致，攻击者利用该漏洞构造异常数据包，可获取服务器内存中多达 64KB 的数据。这些数据可能会包含证书私钥、用户账号、密码、邮件内容等敏感信息。
 背景知识 简介 传输层安全性协议SSL
SSL 全称 Secure Sockets Layer（安全套接字层协议），要求建立在可靠的传输层协议（TCP）之上，主要提供机密性、认证性及数据完整性服务。SSL 最初（SSL 1.0、SSL2.0、SSL 3.0 版本）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 TLS（传输层安全协议，Transport Layer Security），发展至今已有 TLS 1.0、TLS1.1、TLS1.2 三个版本。
SSL/TLS 协议能够提供的安全服务主要包括：
 认证性——使用数字证书认证服务器和客户端身份，防止身份伪造； 机密性——使用加密算法防止第三方窃听； 完整性——使用消息认证码（MAC）保障数据完整性，防止消息被篡改； 重放保护——通过使用隐式序列号防止重放攻击；  SSL握手过程 客户端获取服务器的数字证书后，协商后续数据传输所使用的对称加密密钥。
SSL Heartbeat  Heartbleed was introduced by the Heartbeat Extension in the OpenSSL version 1.0.11 . This extension enables a low-cost, keepalive mechanism for peers to know that they’re still connected and all is well at the TLS layer.</description>
    </item>
    
    <item>
      <title>CVE-2021-3156 sudo 提权漏洞分析</title>
      <link>https://dev2ero.github.io/post/cve-2021-3156/</link>
      <pubDate>Fri, 13 May 2022 23:02:59 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/cve-2021-3156/</guid>
      <description>CVE-2021-3156是sudo中存在一个堆溢出漏洞。影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。可以使得任何没有特权的用户均可使用默认的sudo配置获取root权限
 环境准备 使用apt获取软件源提供的sudo源码：
sudo apt source sudo 却被告知：
NOTICE: &amp;#39;sudo&amp;#39; packaging is maintained in the &amp;#39;Git&amp;#39; version control system at: https://salsa.debian.org/sudo-team/sudo.git Please use: git clone https://salsa.debian.org/sudo-team/sudo.git to retrieve the latest (possibly unreleased) updates to the package. 于是听话，从git仓库获取源码：
git clone https://salsa.debian.org/sudo-team/sudo.git 接下来进行构建：
# clone configure make git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 # v1.9.5p1 CFLAGS+=-g ./configure --sysconfdir=`pwd`/examples --with-plugindir=`pwd`/plugins/sudoers/.libs make -j`nproc` 构建完成后在root用户下可以执行测试：
LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo 验证编译目标的确存在漏洞，前需事先创建名为 sudoedit 的 sudo 的软链接以绕过后续检查：
cd src/.libs ln -s sudo sudoedit cd .</description>
    </item>
    
    <item>
      <title>QEMU guest的网络配置</title>
      <link>https://dev2ero.github.io/post/qemu-system_net_config/</link>
      <pubDate>Thu, 12 May 2022 16:35:52 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/qemu-system_net_config/</guid>
      <description>首先准备网桥与tun/tap虚拟网卡：
创建网桥br0：
sudo brctl addbr br0 为当前用户创建tun/tap虚拟网卡tap0：
tunctl -t tap0 -u ${USER} 若发现brctl与tunctl命令未找到，则需要先安装相应软件包。这里推荐一个网站，可以方便的查询一个命令在不同软件源中对应的包名：https://command-not-found.com/（专治command not found 20 年）</description>
    </item>
    
    <item>
      <title>华硕梅林固件的编译</title>
      <link>https://dev2ero.github.io/post/compile_asuswrt-merlin/</link>
      <pubDate>Wed, 11 May 2022 16:27:10 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/compile_asuswrt-merlin/</guid>
      <description>获取梅林 官网如下：asuswrt-merlin.net
新梅林：https://github.com/RMerl/asuswrt-merlin.ng
旧梅林（停止开发）：https://github.com/RMerl/asuswrt-merlin
这里选用asuswrt-merlin.ng进行编译构建
wget https://github.com/RMerl/asuswrt-merlin.ng/archive/refs/heads/master.zip （下载zip而非clone仓库，节省.git的占用
环境准备 README.txt 给出了编译方式：https://github.com/RMerl/asuswrt-merlin.ng/blob/master/README.TXT
包依赖非常多，所以尽力将本地环境贴合它的编译说明，以避免未知错误。
所以选取 ubuntu:16.04 作为编译平台。
故首先安装docker，快速安装cheatsheet在此：http://zikey.vip/post/some_installation/
拉取ubuntu 16.04镜像并设定共享文件夹：
sudo docker run -it -v /home/zkv/docker_share/:/share ubuntu:16.04 依赖安装 进入docker ubuntu环境后，下载并解压梅林ng：
apt install wget unzip wget https://github.com/RMerl/asuswrt-merlin.ng/archive/refs/heads/master.zip unzip master.zip README.txt 中提到，需安装部分32位依赖包，故先添加32位软件源：
dpkg --add-architecture i386 apt update 此后便可以直接依照说明安装所有依赖包：
apt install libncurses5 libncurses5-dev m4 bison gawk flex libstdc++6-4.7-dev g++-4.7 g++ gengetopt git gitk zlib1g-dev autoconf autopoint libtool-bin shtool autogen mtd-utils intltool sharutils docbook-xsl-* libstdc++5 texinfo dos2unix xsltproc u-boot-tools device-tree-compiler qemu gperf liblzo2-dev uuid-dev build-essential lzma-dev liblzma-dev lzma binutils-dev patch cmake intltool libglib2.</description>
    </item>
    
    <item>
      <title>ZKV的Fuzzing早教</title>
      <link>https://dev2ero.github.io/post/fuzzer_zkv/</link>
      <pubDate>Wed, 11 May 2022 13:57:01 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/fuzzer_zkv/</guid>
      <description>\x00 早教教程 教程 谷歌的Fuzzing教程
Fuzzingbook
课程 南京大学：软件分析
南京大学：软件分析课程视频
博文 Fuzzing战争: 从刀剑弓斧到星球大战
Fuzzing战争系列之二：不畏浮云遮望眼
练兵场 Fuzzing101
兵器 AFL
AFLplusplus
\x01 学步车AFL 最简单的 fuzzing demo 使用AFL，故先安装：
git clone https://github.com/google/AFL.git cd AFL make -j`nproc` sudo make install 接着准备被测程序源码：
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt; #include &amp;lt;signal.h&amp;gt; int vuln(char *str) {  int len = strlen(str);  if(str[0] == &amp;#39;A&amp;#39; &amp;amp;&amp;amp; len == 66)  raise(SIGSEGV);  else if(str[0] == &amp;#39;F&amp;#39; &amp;amp;&amp;amp; len == 6)  raise(SIGSEGV);  else  puts(&amp;#34;\nnothing happened&amp;#34;);  return 0; } int main(int argc, char *argv[]) {  char buf[100]={0};  gets(buf);  printf(buf);  vuln(buf);  return 0; } 使用afl-gcc插装编译：</description>
    </item>
    
    <item>
      <title>一些配环境的cheasheet</title>
      <link>https://dev2ero.github.io/post/some_installation/</link>
      <pubDate>Tue, 10 May 2022 21:13:54 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/some_installation/</guid>
      <description>作为一个系统重装爱好者和硬件收集拾荒人，为了减少在环境配置上浪费的生命，记录常用环境配置命令用以直接复制粘贴
 个人 apt 源 Linux 初始环境软件安装 sudo apt install zsh git man man-db manpages ssh neovim tmux \ 	gcc g++ gdb gdb-multiarch gdbserver flex bison \ 	curl wget netcat net-tools nmap tcpdump \ 	python3 ipython3 python-is-python3 python3-pip \ 	build-essential binutils xxd strace libncurses5 \ 	neofetch zip unzip ncdu htop dotfiles 快速就位 git clone https://github.com/dev2ero/dotfiles.git sh -c &amp;#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)&amp;#34; git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.</description>
    </item>
    
    <item>
      <title>构建与运行嵌入式linux虚拟机</title>
      <link>https://dev2ero.github.io/post/build_run_embeded_linux_vm/</link>
      <pubDate>Tue, 10 May 2022 20:59:43 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/build_run_embeded_linux_vm/</guid>
      <description>Easymode 通过git或http获取buildroot：
官网：https://buildroot.org/
git：git clone https://git.busybox.net/buildroot
进入buildroot根目录，可以看到一个叫configs的文件夹，其中记录了许多硬件平台和部分qemu虚拟平台的默认配置参数。执行 ls configs | grep qemu，可以看到：
qemu_aarch64_sbsa_defconfig qemu_aarch64_virt_defconfig qemu_arm_versatile_defconfig qemu_arm_versatile_nommu_defconfig qemu_arm_vexpress_defconfig qemu_arm_vexpress_tz_defconfig qemu_m68k_mcf5208_defconfig qemu_m68k_q800_defconfig qemu_microblazebe_mmu_defconfig qemu_microblazeel_mmu_defconfig qemu_mips32r2el_malta_defconfig qemu_mips32r2_malta_defconfig qemu_mips32r6el_malta_defconfig qemu_mips32r6_malta_defconfig qemu_mips64el_malta_defconfig qemu_mips64_malta_defconfig qemu_mips64r6el_malta_defconfig qemu_mips64r6_malta_defconfig qemu_nios2_10m50_defconfig qemu_or1k_defconfig qemu_ppc64_e5500_defconfig qemu_ppc64le_powernv8_defconfig qemu_ppc64le_pseries_defconfig qemu_ppc64_pseries_defconfig qemu_ppc_bamboo_defconfig qemu_ppc_e500mc_defconfig qemu_ppc_g3beige_defconfig qemu_ppc_mac99_defconfig qemu_ppc_mpc8544ds_defconfig qemu_riscv32_virt_defconfig qemu_riscv64_virt_defconfig qemu_s390x_defconfig qemu_sh4eb_r2d_defconfig qemu_sh4_r2d_defconfig qemu_sparc64_sun4u_defconfig qemu_sparc_ss10_defconfig qemu_x86_64_defconfig qemu_x86_defconfig qemu_xtensa_lx60_defconfig qemu_xtensa_lx60_nommu_defconfig 举例来讲，我们使用 make qemu_arm_vexpress_defconfig，将qemu模拟的vexperss平台设为编译目标：
make qemu_arm_vexpress_defconfig make 或者使用 make menuconfig 手动配置。
等待编译完成，即可在output文件夹中拿到相应目标文件：
output/images/zImage # 内核 output/images/rootfs.ext2 # ext2根文件系统镜像 output/images/vexpress-v2p-ca9.dtb # arm设备树 使用qemu-system-arm运行得到的linux：</description>
    </item>
    
    <item>
      <title>Fuck the Great Fire Wall</title>
      <link>https://dev2ero.github.io/post/fgfw/</link>
      <pubDate>Mon, 09 May 2022 11:03:28 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/fgfw/</guid>
      <description>当我老了，回顾一生，就会发觉，我三分之一的生命，都浪费在和GFW作斗争上了。
呜呼！何等宏伟啊！两千年多前的巨石，砌就秦帝国的坚不可摧；今日那日夜呼啸的服务器集群，彰显共和国非凡的制度自信。
 Top-level solution selection In terms of the ways I have tried myself:
 Use a VPN application Rent an overseas server Subscribe to an airport service  The last option strikes the best balance between price and convenience.
As for the first two option:
 Beware of phishing High cost in time or money Stability is a concern  个人客户端解决方案  具体使用方面就大白话讲了
 垃机佬出身的我，手里硬件设备的数量经常令得旁人惊异。即使到了渐渐退烧的今天，我手中也是保有了各个主流操作系统平台的物理机。
顶层协议方面，v2ray和ssr都有使用，未尝试过自行编写或改进加密协议。服务端一年200左右的机场全够用了。客户端目前使用方案如下：
 Windows  v2rayNG：https://github.</description>
    </item>
    
    <item>
      <title>Linux系统调用大全</title>
      <link>https://dev2ero.github.io/post/linux_syscalls/</link>
      <pubDate>Sun, 08 May 2022 21:45:00 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/linux_syscalls/</guid>
      <description>传参规则    arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5     arm r7 r0 r0 r1 r2 r3 r4 r5   arm64 x8 x0 x0 x1 x2 x3 x4 x5   x86 eax eax ebx ecx edx esi edi ebp   x86_64 rax rax rdi rsi rdx r10 r8 r9    x86_64 系统调用表  以下调用表皆基于linux4.14.0
    NR syscall name %rax arg0 (%rdi) arg1 (%rsi) arg2 (%rdx)     0 read 0x00 unsigned int fd char *buf size_t count   1 write 0x01 unsigned int fd const char *buf size_t count   2 open 0x02 const char *filename int flags umode_t mode   3 close 0x03 unsigned int fd - -   4 stat 0x04 const char *filename struct __old_kernel_stat *statbuf -   5 fstat 0x05 unsigned int fd struct __old_kernel_stat *statbuf -   6 lstat 0x06 const char *filename struct __old_kernel_stat *statbuf -   7 poll 0x07 struct pollfd *ufds unsigned int nfds int timeout   8 lseek 0x08 unsigned int fd off_t offset unsigned int whence   9 mmap 0x09 ?</description>
    </item>
    
    <item>
      <title>Cross debug kernel using qemu-system</title>
      <link>https://dev2ero.github.io/post/qemu_dbg_kernel/</link>
      <pubDate>Sun, 08 May 2022 19:35:11 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/qemu_dbg_kernel/</guid>
      <description>From this post, our goal is tracing the execution procedure from kernel entry to userspace process (busybox init) by using qemu-system and gdb-multiarch. (The concept of ring exists only on x86. Called EL in arm.)
 Preparation qemu-system-arm Compile it from source code or just use sudo apt install qemu-system-arm.
kernel Linux kernel v4.1 for armel as an example. Compiling a linux kernel requires a matched version of gcc. For example, the linux kernel v4.</description>
    </item>
    
    <item>
      <title>嵌入式软件环境搭建一把梭</title>
      <link>https://dev2ero.github.io/post/embeded_env/</link>
      <pubDate>Sun, 08 May 2022 14:08:16 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/embeded_env/</guid>
      <description>\x01 构建 编译工具链  命名遵循 arch-vendor-(os-)abi 的格式
 获取编译工具链的方式，可以直接从这些地方下载到：
  arm cortex-a:The GNU Toolchain for the Cortex-A Family Downloads
  arm cortex-m:GNU Arm Embedded Toolchain Downloads
  Linaro:arm:https://www.linaro.org/downloads/
  risc-v:https://github.com/riscv/riscv-gnu-toolchain/releases
  mips:https://www.mips.com/develop/tools/compilers/linux-toolchain/
  uclibc:https://www.uclibc.org/downloads/binaries/
  http://download.ronetix.info/toolchains/
  也可以使用buildroot手动构建：
 https://buildroot.org/  OS/ABI的匹配 通常情况下，选取编译交叉编译工具链时，指令集、平台之类的内容是不容易弄错的。但 OS/ABI 却是个容易造成故障的点。
举例来讲，在我一次对libnvram.so的编译时，得到的目标ELF文件为：
~$ file libnvram.so libnvram.so: ELF 32-bit LSB shared object, ARM, version 1 (ARM), dynamically linked, not stripped  ~$ armv5l-readelf -h libnvram.</description>
    </item>
    
    <item>
      <title>Awesome Colors</title>
      <link>https://dev2ero.github.io/post/awesome_colors/</link>
      <pubDate>Sat, 07 May 2022 22:53:05 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/awesome_colors/</guid>
      <description>Awesome colors 波尔多红#4f0009克莱因蓝#002FA7普鲁士蓝#003153勃艮第红#800020邦迪蓝#0095b6木乃伊棕#8f4b28卡布里蓝#1a5599提香红#b05923蒂芙尼蓝#81d8d0覆盆子红#9e2e24虎皮黄#e2af42薄荷绿#407d52草黄#cfb64a星蓝#9ab4cd鸢尾蓝#418ab4苋菜紫#8e2961钢蓝#101420云峰白#dae3e6岩石棕#8c502c橄榄石绿#b8ce8e竹绿#4fa485钴蓝#4692b9月影白#c2c4c3笋皮棕#6b331a琉璃蓝#22406a黛蓝#3f4f65青白#bee0d0墨色#4e606c黯#3f545b玄青#3b3a4e漆黑#141722玄色#370708</description>
    </item>
    
    <item>
      <title>关于Linux桌面的美化工作</title>
      <link>https://dev2ero.github.io/post/beautify_de/</link>
      <pubDate>Sat, 07 May 2022 22:50:57 +0800</pubDate>
      
      <guid>https://dev2ero.github.io/post/beautify_de/</guid>
      <description>GNU/Linux 的桌面生态，开放虽是好事，但却由此带来了混乱。没有像微软这样的赛博中央政府制定规则，就产生了眼下这般群雄割据的态势。作为用户的我能做的，也只是择巨木而栖 —— 唯二的自由巨头 KDE 与 Gnome，二选其一。幼年气盛，爱好折腾，留下了些许美化的经验。时至今日，能回忆起的已然不多。尽力而为做些记录，为日后回归赛博左派留些盘缠。
KDE plasma UI的（乡土风）现代感，很大部分要归因与透明化的效果。一年前的我也是透明化爱好者，恰逢那时使用 Archlinux + KDE，故记录如下KDE透明化配置方法。KDE自身本就具有各大DE中最为强大的视觉效果定制功能，所以如下所述只是KDE本身能力之外的美化方法：
窗口边框透明化 使用
 https://github.com/ishovkun/SierraBreeze  或
 https://github.com/alex47/BreezeBlurred  在Archlinux上若出现编译错误，可以使用这位老哥打包好的安装包  https://github.com/alex47/BreezeBlurred/issues/24      面板透明化 需要自己魔改，参考如下大佬留下的教程：
https://www.joxrays.com/kde-panel-transparency/
原始论坛帖子：
https://forum.manjaro.org/t/where-can-the-transparency-of-the-kde-panel-be-set/50219
组件透明化 这一需求有现成的工具Kvantum，亦有大佬教程如下：
https://blog.firerain.me/article/4
此外，便是一些其它的效果组件
MacOS风的Dock栏 状态、菜单、任务栏的呈现方式，我个人更倾向与MacOS的方案。比起Windows，牺牲了些许效率，换取美感。
KDE下使用 latte-dock 来获取MacOS风的Dock栏，这样就可以将本身的Panel变为MacOS下的常驻状态栏。
仓库地址：https://github.com/KDE/latte-dock
同时其是可以直接从KDE store一键下载安装的。
音乐可视化 Windows下可以使用Wallpaper engine，Linux就没有这个福分了，只能另寻替代方案。
KDE插件 panon 能达到尚且凑活的效果，可以直接从插件商店一键安装。
Gnome Gnome不像KDE，它没有向用户直接呈现UI定制接口，而是需要用户自行配置。好在Gnome同时也提供了美化总站：https://www.gnome-look.org/
网站中基本涵盖了所有美化选项与资源。但在此之前需要有一些预先配置（出于DE稳定性考虑，默认不将定制接口提供给小白用户）：
安装 gnome-tweaks
sudo apt install gnome-tweaks 使用gnome-tweaks就可以做一些此前没有的定制化了，同时作为后续美化的基本依赖。
接下来安装gnome插件管理器 GNOME Shell Extensions：
插件管理器的用户接口是基于浏览器提供的，需安装对应的Chrome或Firefox插件即可。
对于Chrome，除了可以从Chrome商店下载外，也可以直接使用软件源里的包安装：
sudo apt install chrome-gnome-shell Firefox插件地址为：https://addons.</description>
    </item>
    
  </channel>
</rss>
