<header>
    <title>XV6-RISCV</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/lib/page.css">
    <style> html * { color: #f2f2f2 !important; font-family: Terminus; } </style>
</header>

<body>
    <h1>Bootloader</h1>
<pre>
既然题目是Bootloader，那这里的目的自然是研究内核启动前的第一行代码。
和ucore不同且比它更简单的是 -- XV6甚至没有实际意义上的bootloader程序（即装载器）而是直接借助了qemu提供的boot ROM进行装载。
现在来看看XV6的第一行代码。
no no no，在此之前我们需要先看看kernel的链接脚本，以确定第一行代码的位置和地址。所以先来到/kernel/kernel.ld中：

    OUTPUT_ARCH( "riscv" )  // 指令集：RISC-V
    ENTRY( _entry )         // 入口点：_entry

    SECTIONS                // 内核ELF的sections
    {
        /*
        * ensure that entry.S / _entry is at 0x80000000,
        * where qemu's -kernel jumps.
        */
        . = 0x80000000;     // 入口点，即_entry的地址为物理地址的0x80000000

        .text : {
            *(.text .text.*)
            . = ALIGN(0x1000);  // .text section为4KB页对齐
            _trampoline = .;
            *(trampsec)
            . = ALIGN(0x1000);
            ASSERT(. - _trampoline == 0x1000, "error: trampoline larger than one page");
            PROVIDE(etext = .);
        }

        .rodata : {
            . = ALIGN(16);      // 其余section为16字节对齐
            *(.srodata .srodata.*) /* do not need to distinguish this from .rodata */
            . = ALIGN(16);
            *(.rodata .rodata.*)
        }

        .data : {
            . = ALIGN(16);      // 其余section为16字节对齐
            *(.sdata .sdata.*) /* do not need to distinguish this from .data */
            . = ALIGN(16);
            *(.data .data.*)
        }

        .bss : {
            . = ALIGN(16);      // 其余section为16字节对齐
            *(.sbss .sbss.*) /* do not need to distinguish this from .bss */
            . = ALIGN(16);
            *(.bss .bss.*)
        }

        PROVIDE(end = .);
    }

由此确定了内核入口点为_entry，它位于/kernel/entry.S中：

        # qemu -kernel loads the kernel at 0x80000000
        # and causes each CPU to jump there.
        # kernel.ld causes the following code to
        # be placed at 0x80000000.
    .section .text
    .global _entry
    _entry:
        # set up a stack for C. C语言写就的内核代码遵循函数调用栈的规则，所以entry.S的任务是使用汇编为后续C代码建立函数调用栈
        # stack0 is declared in start.c, 内核的初始栈为stack0，定义在/kernel/start.c中
        # with a 4096-byte stack per CPU. 每一个CPU获得4KB（一页）的栈空间，详见下方stack0的定义
        # sp = stack0 + (hartid * 4096) 
        la sp, stack0       # 栈顶指针存储于sp寄存器，初始化为stack0
        li a0, 1024*4
        csrr a1, mhartid
        addi a1, a1, 1      # 算出CPU核心数，存放在a1
        mul a0, a0, a1      # 4KB*a1算出总共需要的栈空间
        add sp, sp, a0      # 为以上栈空间抬栈顶
        # jump to start() in start.c
        call start          # 内核栈初始化完毕，跳转到C语言的初始化函数start
    spin:
        j spin

由此完成了跳转到C代码的准备工作，接下来的进入C语言的初始化函数start。但在分析start函数前，先看看stack0的定义，它们都位于/kernel/strat.c中：

    // entry.S needs one stack per CPU.
    __attribute__ ((aligned (16))) char stack0[4096 * NCPU];

注释说的很好，entry.S needs one stack per CPU. 和前面的汇编逻辑匹配上了。
start函数实现如下：

    // entry.S jumps here in machine mode on stack0.
    void
    start()
    {
        // set M Previous Privilege mode to Supervisor, for mret.
        unsigned long x = r_mstatus();
        x &= ~MSTATUS_MPP_MASK;
        x |= MSTATUS_MPP_S;
        w_mstatus(x);

        // set M Exception Program Counter to main, for mret.
        // requires gcc -mcmodel=medany
        w_mepc((uint64)main);

        // disable paging for now.
        w_satp(0);

        // delegate all interrupts and exceptions to supervisor mode.
        w_medeleg(0xffff);
        w_mideleg(0xffff);
        w_sie(r_sie() | SIE_SEIE | SIE_STIE | SIE_SSIE);

        // configure Physical Memory Protection to give supervisor mode
        // access to all of physical memory.
        w_pmpaddr0(0x3fffffffffffffull);
        w_pmpcfg0(0xf);

        // ask for clock interrupts.
        timerinit();

        // keep each CPU's hartid in its tp register, for cpuid().
        int id = r_mhartid();
        w_tp(id);

        // switch to supervisor mode and jump to main().
        asm volatile("mret");
    }

start主要完成将CPU从machine mode切换到supervisor mode的工作，涉及到大量后续代码，学完回来再更新。
最后使用一个mret指令跳转到main函数，初始化物理内存与切换CPU工作模式的准备工作由此完成，流程如下。后面开始初始化内核。

<pre style="font-family: 'Lucida Console';">
    ┌────────────────┐
    │entry.S - _entry│   setup stack0
    └────────┬───────┘
             │
    ┌────────▼───────┐
    │start.c - start │   switch CPU mode
    └────────┬───────┘
             │
    ┌────────▼───────┐
    │ main.c - main  │   setup kernel
    └────────┬───────┘
             │
             ▼
           .....
</pre>
</pre>

</body>