<header>
    <title>XV6-RISCV</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/lib/page.css">
    <style> html * { color: #f2f2f2 !important; font-family: Terminus !important; } </style>
</header>

<body>
    <h1>自旋锁的实现</h1>
<pre>
XV6中自旋锁的实现位于/kernel/spinlock.h与/kernel/spinlock.c中。
自旋锁，顾名思义，a spinlock is a lock that causes a thread trying to acquire it to simply wait in a loop ("spin") while repeatedly checking whether the lock is available.
先来/kernel/spinlock.h中看看spinlock的结构体定义：

    // Mutual exclusion lock.
    struct spinlock {
        uint locked;       // Is the lock held?

        // For debugging:
        char *name;        // Name of lock.
        struct cpu *cpu;   // The cpu holding the lock.
    };

基本的功能成员就只有uint locked，用于表示当前spinlock是否处于被占用的状态。
剩下的name（spinlock的名称）和cpu（因为XV6支持多核处理器，故此处记录当前占用此spinlock的核心）则都是用于debug的。

来到/kernel/spinlock.c中查看spinlock的具体功能实现：
首先是初始化函数：

    void
    initlock(struct spinlock *lk, char *name)
    {
        lk->name = name;
        lk->locked = 0;
        lk->cpu = 0;
    }

没什么特别的，就是赋予了spinlock名称、占用状态为否、占用核心为空。

请求锁的函数acquire：

    // Acquire the lock.
    // Loops (spins) until the lock is acquired.
    void
    acquire(struct spinlock *lk)
    {
        push_off();         // disable interrupts to avoid deadlock. 关中断，以避免死锁的出现
        if(holding(lk))     // 若当前cpu已得到该lk，则panic
            panic("acquire");

        // On RISC-V, sync_lock_test_and_set turns into an atomic swap:
        //   a5 = 1
        //   s1 = &lk->locked
        //   amoswap.w.aq a5, a5, (s1)
        while(__sync_lock_test_and_set(&lk->locked, 1) != 0)    // 若lk是锁定状态，则原地spin死循环等待
            ;

        // Tell the C compiler and the processor to not move loads or stores
        // past this point, to ensure that the critical section's memory
        // references happen strictly after the lock is acquired.
        // On RISC-V, this emits a fence instruction.
        __sync_synchronize();                                   // ？？？

        // Record info about lock acquisition for holding() and debugging.
        lk->cpu = mycpu();  // 当前cpu终于等到了lk，锁名和占用状态不变，持有者cpu改变即可
    }

释放锁的函数release：

    // Release the lock.
    void
    release(struct spinlock *lk)
    {
        if(!holding(lk))    // "lk都不在我手里那还释放个啥？panic！"
            panic("release");

        lk->cpu = 0;        // lk持有者cpu先设为空，准备迎接下个主人

        // Tell the C compiler and the CPU to not move loads or stores
        // past this point, to ensure that all the stores in the critical
        // section are visible to other CPUs before the lock is released,
        // and that loads in the critical section occur strictly before
        // the lock is released.
        // On RISC-V, this emits a fence instruction.
        __sync_synchronize();   // ？？？

        // Release the lock, equivalent to lk->locked = 0.
        // This code doesn't use a C assignment, since the C standard
        // implies that an assignment might be implemented with
        // multiple store instructions.
        // On RISC-V, sync_lock_release turns into an atomic swap:
        //   s1 = &lk->locked
        //   amoswap.w zero, zero, (s1)
        __sync_lock_release(&lk->locked);   // lk的锁定状态关闭

        pop_off();  // ？？？ 与 push_off() 配对
    }

检查当前cpu是否持有该自旋锁的函数holding：

    // Check whether this cpu is holding the lock.
    // Interrupts must be off.
    int
    holding(struct spinlock *lk)
    {
        int r;
        r = (lk->locked && lk->cpu == mycpu());     // lk锁定 && lk的主人该cpu
        return r;
    }

余下两个中断与同步函数学到了再更新

</pre>

</body>