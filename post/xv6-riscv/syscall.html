<header>
    <title>XV6-RISCV</title>
    <meta charset="utf-8">
</header>

<body style="margin-top: 64px; margin-left: 64px; background-color:#282C34;">
    <h1>系统调用</h1>
<pre>
首先要弄清楚XV6定义了那些系统调用，所以先看看/kernel/syscall.h：

    // System call numbers
    #define SYS_fork    1
    #define SYS_exit    2
    #define SYS_wait    3
    #define SYS_pipe    4
    #define SYS_read    5
    #define SYS_kill    6
    #define SYS_exec    7
    #define SYS_fstat   8
    #define SYS_chdir   9
    #define SYS_dup    10
    #define SYS_getpid 11
    #define SYS_sbrk   12
    #define SYS_sleep  13
    #define SYS_uptime 14
    #define SYS_open   15
    #define SYS_write  16
    #define SYS_mknod  17
    #define SYS_unlink 18
    #define SYS_link   19
    #define SYS_mkdir  20
    #define SYS_close  21

那么相应的系统调用内核实现函数在哪里呢？答案是分散在各个地方了。
那/kernel/syscall.c是用来干啥的？答案是仅仅做了用户态系统调用请求到内核实现代码的转换。
在/kernel/syscall.c中，我们可以看到系统调用的实现函数的一系列声明：

    extern uint64 sys_chdir(void);
    extern uint64 sys_close(void);
    extern uint64 sys_dup(void);
    extern uint64 sys_exec(void);
    extern uint64 sys_exit(void);
    extern uint64 sys_fork(void);
    extern uint64 sys_fstat(void);
    extern uint64 sys_getpid(void);
    extern uint64 sys_kill(void);
    extern uint64 sys_link(void);
    extern uint64 sys_mkdir(void);
    extern uint64 sys_mknod(void);
    extern uint64 sys_open(void);
    extern uint64 sys_pipe(void);
    extern uint64 sys_read(void);
    extern uint64 sys_sbrk(void);
    extern uint64 sys_sleep(void);
    extern uint64 sys_unlink(void);
    extern uint64 sys_wait(void);
    extern uint64 sys_write(void);
    extern uint64 sys_uptime(void);

extern声明表明了它们的函数实现在其它文件中。函数参数全部为void是由于系统调用由中断实现，由固定寄存器传参 -- 这和函数调用栈完全不是一套东西。
好，有了上面的系统调用号和系统调用内核函数，接下来就要完成/kernel/syscall.c的首要工作了 -- 将它们映射起来：

    static uint64 (*syscalls[])(void) = {
        [SYS_fork]    sys_fork,
        [SYS_exit]    sys_exit,
        [SYS_wait]    sys_wait,
        [SYS_pipe]    sys_pipe,
        [SYS_read]    sys_read,
        [SYS_kill]    sys_kill,
        [SYS_exec]    sys_exec,
        [SYS_fstat]   sys_fstat,
        [SYS_chdir]   sys_chdir,
        [SYS_dup]     sys_dup,
        [SYS_getpid]  sys_getpid,
        [SYS_sbrk]    sys_sbrk,
        [SYS_sleep]   sys_sleep,
        [SYS_uptime]  sys_uptime,
        [SYS_open]    sys_open,
        [SYS_write]   sys_write,
        [SYS_mknod]   sys_mknod,
        [SYS_unlink]  sys_unlink,
        [SYS_link]    sys_link,
        [SYS_mkdir]   sys_mkdir,
        [SYS_close]   sys_close,
    };

映射的重任交给了数组完成。由数组索引代表系统调用号，由相应索引下的元素保存对于的内核函数的地址。
同时该数组声明为static，且数组元素类型为函数指针，其中的内核函数原型为uint64 (*syscall)(void)。
数组初始化的写法是GNU C标准定义的，所以对于ANSI C er来说可能有些陌生。GNU C对于ANSI C的扩展也不太多，简单搜搜就能学完。

然后便是系统调用的入口函数syscall：

    void
    syscall(void)
    {
        int num;
        struct proc *p = myproc();

        num = p->trapframe->a7;                                 // 进行系统调用的用户程序所请求的系统调用号
        if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // num处于数组索引范围内，且相应内核函数存在时
            p->trapframe->a0 = syscalls[num]();                 // 执行对于的系统调用函数，返回值存储于p->trapframe->a0
        } else {                                                // 不然则不存在该系统调用
            printf("%d %s: unknown sys call %d\n",
                    p->pid, p->name, num);
            p->trapframe->a0 = -1;                              // 返回错误码-1
        }
    }

系统调用号搞定了：它位于trapframe->a7中，那么系统调用的参数呢？
The kernel functions argint, argaddr, and argstr retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a string. 
They all call argraw to retrieve the appropriate saved user register.

目前可以公开的情报：
<pre style="font-family: 'Lucida Console';">
                               ┌───────┐
    ┌───────┐    ┌────────┐    │argint │    ┌──────┐
    │syscall├────►sys_xxxx├────►argaddr├────►argraw│
    └───────┘    └────────┘    │argstr │    └──────┘
                               └───────┘
</pre>
那么来看看argint、argaddr、argstr的实现吧：

    // Fetch the nth 32-bit system call argument.
    int
    argint(int n, int *ip)
    {
        *ip = argraw(n);        // 直接取p->trapframe->an中的值为int型参数
        return 0;
    }

    // Retrieve an argument as a pointer.
    // Doesn't check for legality, since
    // copyin/copyout will do that.
    int
    argaddr(int n, uint64 *ip)
    {
        *ip = argraw(n);        // 直接取p->trapframe->an中的值为uint64型地址值
        return 0;
    }

    // Fetch the nth word-sized system call argument as a null-terminated string.
    // Copies into buf, at most max.
    // Returns string length if OK (including nul), -1 if error.
    int
    argstr(int n, char *buf, int max)
    {
        uint64 addr;
        if(argaddr(n, &addr) < 0)
            return -1;
        return fetchstr(addr, buf, max);    // 将p->trapframe->an中的值当作地址，从其指向的位置取字符串
    }

它们仨就是依据特点数据类型从用户态下来的trapframe中取参数，被各个系统调用实现函数按需取用。
来继续看看它们仨的上游函数argraw：

    static uint64
    argraw(int n)
    {
        struct proc *p = myproc();      // 先看看是谁申请的系统调用
        switch (n) {                    // 按需从trapframe中取参数值，不关心数据类型
        case 0:
            return p->trapframe->a0;
        case 1:
            return p->trapframe->a1;
        case 2:
            return p->trapframe->a2;
        case 3:
            return p->trapframe->a3;
        case 4:
            return p->trapframe->a4;
        case 5:
            return p->trapframe->a5;
        }
        panic("argraw");                // switch无default，超出范围则panic并返回错误码
        return -1;
    }

至此名为syscall.c的胶水完成了它历史使命。

接下来看看真正干活儿的函数们，也就是各个系统调用的实现函数。
进程相关的系统调用函数分布在了/kernel/sysproc.c中：

    uint64
    sys_exit(void)
    {
        int n;
        if(argint(0, &n) < 0)
            return -1;
        exit(n);    // 终止进程的任务实际由exit函数实现，sys_exit仅为入口，做参数解析
        return 0;   // not reached
    }

    uint64
    sys_getpid(void)
    {
        return myproc()->pid;   // 直接返回pid即可
    }

    uint64
    sys_fork(void)
    {
        return fork();  // fork的任务实际由fork函数实现，sys_fork仅为入口
    }

    uint64
    sys_wait(void)
    {
        uint64 p;
        if(argaddr(0, &p) < 0)
            return -1;
        return wait(p);   // wait的任务实际由wait函数实现，sys_wait仅为入口，做参数解析
    }

    uint64
    sys_sbrk(void)
    {
        int addr;
        int n;

        if(argint(0, &n) < 0)
            return -1;
        addr = myproc()->sz;    // addr = Size of process memory (bytes)
        if(growproc(n) < 0)     // 扩展内存空间的任务实际由growproc函数实现
            return -1;
        return addr;
    }

    // 与锁和计时器相关，学完回来更
    uint64
    sys_sleep(void)
    {
        int n;
        uint ticks0;

        if(argint(0, &n) < 0)
            return -1;
        acquire(&tickslock);
        ticks0 = ticks;
        while(ticks - ticks0 < n){
            if(myproc()->killed){
                release(&tickslock);
                return -1;
            }
            sleep(&ticks, &tickslock);
        }
        release(&tickslock);
        return 0;
    }

    uint64
    sys_kill(void)
    {
        int pid;

        if(argint(0, &pid) < 0)
            return -1;
        return kill(pid);
    }

    // return how many clock tick interrupts have occurred
    // since start.
    uint64
    sys_uptime(void)
    {
        uint xticks;

        acquire(&tickslock);
        xticks = ticks;
        release(&tickslock);
        return xticks;
    }

文件系统相关的系统调用函数分布在了/kernel/sysfile.c中：

    uint64
    sys_dup(void)
    {
        struct file *f;
        int fd;

        if(argfd(0, 0, &f) < 0)
            return -1;
        if((fd=fdalloc(f)) < 0)
            return -1;
        filedup(f);
        return fd;
    }

    uint64
    sys_read(void)
    {
        struct file *f;
        int n;
        uint64 p;

        if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
            return -1;
        return fileread(f, p, n);
    }

    uint64
    sys_write(void)
    {
        struct file *f;
        int n;
        uint64 p;

        if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
            return -1;

        return filewrite(f, p, n);
    }

    uint64
    sys_close(void)
    {
        int fd;
        struct file *f;

        if(argfd(0, &fd, &f) < 0)
            return -1;
        myproc()->ofile[fd] = 0;
        fileclose(f);
        return 0;
    }

    uint64
    sys_fstat(void)
    {
        struct file *f;
        uint64 st; // user pointer to struct stat

        if(argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
            return -1;
        return filestat(f, st);
    }

    // Create the path new as a link to the same inode as old.
    uint64
    sys_link(void)
    {
        char name[DIRSIZ], new[MAXPATH], old[MAXPATH];
        struct inode *dp, *ip;

        if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
            return -1;

        begin_op();
        if((ip = namei(old)) == 0){
            end_op();
            return -1;
        }

        ilock(ip);
        if(ip->type == T_DIR){
            iunlockput(ip);
            end_op();
            return -1;
        }

        ip->nlink++;
        iupdate(ip);
        iunlock(ip);

        if((dp = nameiparent(new, name)) == 0)
            goto bad;
        ilock(dp);
        if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
            iunlockput(dp);
            goto bad;
        }
        iunlockput(dp);
        iput(ip);

        end_op();

        return 0;

        bad:
        ilock(ip);
        ip->nlink--;
        iupdate(ip);
        iunlockput(ip);
        end_op();
        return -1;
    }

    uint64
    sys_unlink(void)
    {
        struct inode *ip, *dp;
        struct dirent de;
        char name[DIRSIZ], path[MAXPATH];
        uint off;

        if(argstr(0, path, MAXPATH) < 0)
            return -1;

        begin_op();
        if((dp = nameiparent(path, name)) == 0){
            end_op();
            return -1;
        }

        ilock(dp);

        // Cannot unlink "." or "..".
        if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
            goto bad;

        if((ip = dirlookup(dp, name, &off)) == 0)
            goto bad;
        ilock(ip);

        if(ip->nlink < 1)
            panic("unlink: nlink < 1");
        if(ip->type == T_DIR && !isdirempty(ip)){
            iunlockput(ip);
            goto bad;
        }

        memset(&de, 0, sizeof(de));
        if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
            panic("unlink: writei");
        if(ip->type == T_DIR){
            dp->nlink--;
            iupdate(dp);
        }
        iunlockput(dp);

        ip->nlink--;
        iupdate(ip);
        iunlockput(ip);

        end_op();

        return 0;

        bad:
        iunlockput(dp);
        end_op();
        return -1;
    }

    uint64
    sys_open(void)
    {
        char path[MAXPATH];
        int fd, omode;
        struct file *f;
        struct inode *ip;
        int n;

        if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
            return -1;

        begin_op();

        if(omode & O_CREATE){
            ip = create(path, T_FILE, 0, 0);
            if(ip == 0){
            end_op();
            return -1;
            }
        } else {
            if((ip = namei(path)) == 0){
            end_op();
            return -1;
            }
            ilock(ip);
            if(ip->type == T_DIR && omode != O_RDONLY){
            iunlockput(ip);
            end_op();
            return -1;
            }
        }

        if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
            iunlockput(ip);
            end_op();
            return -1;
        }

        if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
            if(f)
            fileclose(f);
            iunlockput(ip);
            end_op();
            return -1;
        }

        if(ip->type == T_DEVICE){
            f->type = FD_DEVICE;
            f->major = ip->major;
        } else {
            f->type = FD_INODE;
            f->off = 0;
        }
        f->ip = ip;
        f->readable = !(omode & O_WRONLY);
        f->writable = (omode & O_WRONLY) || (omode & O_RDWR);

        if((omode & O_TRUNC) && ip->type == T_FILE){
            itrunc(ip);
        }

        iunlock(ip);
        end_op();

        return fd;
    }

    uint64
    sys_mkdir(void)
    {
        char path[MAXPATH];
        struct inode *ip;

        begin_op();
        if(argstr(0, path, MAXPATH) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
            end_op();
            return -1;
        }
        iunlockput(ip);
        end_op();
        return 0;
    }

    uint64
    sys_mknod(void)
    {
        struct inode *ip;
        char path[MAXPATH];
        int major, minor;

        begin_op();
        if((argstr(0, path, MAXPATH)) < 0 ||
            argint(1, &major) < 0 ||
            argint(2, &minor) < 0 ||
            (ip = create(path, T_DEVICE, major, minor)) == 0){
            end_op();
            return -1;
        }
        iunlockput(ip);
        end_op();
        return 0;
    }

    uint64
    sys_chdir(void)
    {
        char path[MAXPATH];
        struct inode *ip;
        struct proc *p = myproc();
        
        begin_op();
        if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){
            end_op();
            return -1;
        }
        ilock(ip);
        if(ip->type != T_DIR){
            iunlockput(ip);
            end_op();
            return -1;
        }
        iunlock(ip);
        iput(p->cwd);
        end_op();
        p->cwd = ip;
        return 0;
    }

    uint64
    sys_exec(void)
    {
        char path[MAXPATH], *argv[MAXARG];
        int i;
        uint64 uargv, uarg;

        if(argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0){
            return -1;
        }
        memset(argv, 0, sizeof(argv));
        for(i=0;; i++){
            if(i >= NELEM(argv)){
            goto bad;
            }
            if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
            goto bad;
            }
            if(uarg == 0){
            argv[i] = 0;
            break;
            }
            argv[i] = kalloc();
            if(argv[i] == 0)
            goto bad;
            if(fetchstr(uarg, argv[i], PGSIZE) < 0)
            goto bad;
        }

        int ret = exec(path, argv);

        for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
            kfree(argv[i]);

        return ret;

        bad:
        for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
            kfree(argv[i]);
        return -1;
    }

    uint64
    sys_pipe(void)
    {
        uint64 fdarray; // user pointer to array of two integers
        struct file *rf, *wf;
        int fd0, fd1;
        struct proc *p = myproc();

        if(argaddr(0, &fdarray) < 0)
            return -1;
        if(pipealloc(&rf, &wf) < 0)
            return -1;
        fd0 = -1;
        if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
            if(fd0 >= 0)
            p->ofile[fd0] = 0;
            fileclose(rf);
            fileclose(wf);
            return -1;
        }
        if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
            copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
            p->ofile[fd0] = 0;
            p->ofile[fd1] = 0;
            fileclose(rf);
            fileclose(wf);
            return -1;
        }
        return 0;
    }

学完文件系统回来更

XV6将所以系统调用就分为了这两类 -- sysproc和sysfile。全都在这里了。
</pre>

</body>

<style>
    html *
    {
        color: #f2f2f2;
        font-family: Terminus;
    }
    @font-face {
        font-family: Terminus;
        src: url("data:font/woff2;base64,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") format('woff2');
    }
</style>