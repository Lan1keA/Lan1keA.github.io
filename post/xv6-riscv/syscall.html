<header>
    <title>XV6-RISCV</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="/lib/page.css">
    <style> html * { color: #f2f2f2 !important; font-family: Terminus !important; } </style>
</header>

<body>
    <h1>系统调用</h1>
<pre>
首先要弄清楚XV6定义了那些系统调用，所以先看看/kernel/syscall.h：

    // System call numbers
    #define SYS_fork    1
    #define SYS_exit    2
    #define SYS_wait    3
    #define SYS_pipe    4
    #define SYS_read    5
    #define SYS_kill    6
    #define SYS_exec    7
    #define SYS_fstat   8
    #define SYS_chdir   9
    #define SYS_dup    10
    #define SYS_getpid 11
    #define SYS_sbrk   12
    #define SYS_sleep  13
    #define SYS_uptime 14
    #define SYS_open   15
    #define SYS_write  16
    #define SYS_mknod  17
    #define SYS_unlink 18
    #define SYS_link   19
    #define SYS_mkdir  20
    #define SYS_close  21

那么相应的系统调用内核实现函数在哪里呢？答案是分散在各个地方了。
那/kernel/syscall.c是用来干啥的？答案是仅仅做了用户态系统调用请求到内核实现代码的转换。
在/kernel/syscall.c中，我们可以看到系统调用的实现函数的一系列声明：

    extern uint64 sys_chdir(void);
    extern uint64 sys_close(void);
    extern uint64 sys_dup(void);
    extern uint64 sys_exec(void);
    extern uint64 sys_exit(void);
    extern uint64 sys_fork(void);
    extern uint64 sys_fstat(void);
    extern uint64 sys_getpid(void);
    extern uint64 sys_kill(void);
    extern uint64 sys_link(void);
    extern uint64 sys_mkdir(void);
    extern uint64 sys_mknod(void);
    extern uint64 sys_open(void);
    extern uint64 sys_pipe(void);
    extern uint64 sys_read(void);
    extern uint64 sys_sbrk(void);
    extern uint64 sys_sleep(void);
    extern uint64 sys_unlink(void);
    extern uint64 sys_wait(void);
    extern uint64 sys_write(void);
    extern uint64 sys_uptime(void);

extern声明表明了它们的函数实现在其它文件中。函数参数全部为void是由于系统调用由中断实现，由固定寄存器传参 -- 这和函数调用栈完全不是一套东西。
好，有了上面的系统调用号和系统调用内核函数，接下来就要完成/kernel/syscall.c的首要工作了 -- 将它们映射起来：

    static uint64 (*syscalls[])(void) = {
        [SYS_fork]    sys_fork,
        [SYS_exit]    sys_exit,
        [SYS_wait]    sys_wait,
        [SYS_pipe]    sys_pipe,
        [SYS_read]    sys_read,
        [SYS_kill]    sys_kill,
        [SYS_exec]    sys_exec,
        [SYS_fstat]   sys_fstat,
        [SYS_chdir]   sys_chdir,
        [SYS_dup]     sys_dup,
        [SYS_getpid]  sys_getpid,
        [SYS_sbrk]    sys_sbrk,
        [SYS_sleep]   sys_sleep,
        [SYS_uptime]  sys_uptime,
        [SYS_open]    sys_open,
        [SYS_write]   sys_write,
        [SYS_mknod]   sys_mknod,
        [SYS_unlink]  sys_unlink,
        [SYS_link]    sys_link,
        [SYS_mkdir]   sys_mkdir,
        [SYS_close]   sys_close,
    };

映射的重任交给了数组完成。由数组索引代表系统调用号，由相应索引下的元素保存对于的内核函数的地址。
同时该数组声明为static，且数组元素类型为函数指针，其中的内核函数原型为uint64 (*syscall)(void)。
数组初始化的写法是GNU C标准定义的，所以对于ANSI C er来说可能有些陌生。GNU C对于ANSI C的扩展也不太多，简单搜搜就能学完。

然后便是系统调用的入口函数syscall：

    void
    syscall(void)
    {
        int num;
        struct proc *p = myproc();

        num = p->trapframe->a7;                                 // 进行系统调用的用户程序所请求的系统调用号
        if(num > 0 && num < NELEM(syscalls) && syscalls[num]) { // num处于数组索引范围内，且相应内核函数存在时
            p->trapframe->a0 = syscalls[num]();                 // 执行对于的系统调用函数，返回值存储于p->trapframe->a0
        } else {                                                // 不然则不存在该系统调用
            printf("%d %s: unknown sys call %d\n",
                    p->pid, p->name, num);
            p->trapframe->a0 = -1;                              // 返回错误码-1
        }
    }

系统调用号搞定了：它位于trapframe->a7中，那么系统调用的参数呢？
The kernel functions argint, argaddr, and argstr retrieve the n ’th system call argument from the trap frame as an integer, pointer, or a string. 
They all call argraw to retrieve the appropriate saved user register.

目前可以公开的情报：
<pre style="font-family: 'Lucida Console';">
                               ┌───────┐
    ┌───────┐    ┌────────┐    │argint │    ┌──────┐
    │syscall├────►sys_xxxx├────►argaddr├────►argraw│
    └───────┘    └────────┘    │argstr │    └──────┘
                               └───────┘
</pre>
那么来看看argint、argaddr、argstr的实现吧：

    // Fetch the nth 32-bit system call argument.
    int
    argint(int n, int *ip)
    {
        *ip = argraw(n);        // 直接取p->trapframe->an中的值为int型参数
        return 0;
    }

    // Retrieve an argument as a pointer.
    // Doesn't check for legality, since
    // copyin/copyout will do that.
    int
    argaddr(int n, uint64 *ip)
    {
        *ip = argraw(n);        // 直接取p->trapframe->an中的值为uint64型地址值
        return 0;
    }

    // Fetch the nth word-sized system call argument as a null-terminated string.
    // Copies into buf, at most max.
    // Returns string length if OK (including nul), -1 if error.
    int
    argstr(int n, char *buf, int max)
    {
        uint64 addr;
        if(argaddr(n, &addr) < 0)
            return -1;
        return fetchstr(addr, buf, max);    // 将p->trapframe->an中的值当作地址，从其指向的位置取字符串
    }

它们仨就是依据特点数据类型从用户态下来的trapframe中取参数，被各个系统调用实现函数按需取用。
来继续看看它们仨的上游函数argraw：

    static uint64
    argraw(int n)
    {
        struct proc *p = myproc();      // 先看看是谁申请的系统调用
        switch (n) {                    // 按需从trapframe中取参数值，不关心数据类型
        case 0:
            return p->trapframe->a0;
        case 1:
            return p->trapframe->a1;
        case 2:
            return p->trapframe->a2;
        case 3:
            return p->trapframe->a3;
        case 4:
            return p->trapframe->a4;
        case 5:
            return p->trapframe->a5;
        }
        panic("argraw");                // switch无default，超出范围则panic并返回错误码
        return -1;
    }

至此名为syscall.c的胶水完成了它历史使命。

接下来看看真正干活儿的函数们，也就是各个系统调用的实现函数。
进程相关的系统调用函数分布在了/kernel/sysproc.c中：

    uint64
    sys_exit(void)
    {
        int n;
        if(argint(0, &n) < 0)
            return -1;
        exit(n);    // 终止进程的任务实际由exit函数实现，sys_exit仅为入口，做参数解析
        return 0;   // not reached
    }

    uint64
    sys_getpid(void)
    {
        return myproc()->pid;   // 直接返回pid即可
    }

    uint64
    sys_fork(void)
    {
        return fork();  // fork的任务实际由fork函数实现，sys_fork仅为入口
    }

    uint64
    sys_wait(void)
    {
        uint64 p;
        if(argaddr(0, &p) < 0)
            return -1;
        return wait(p);   // wait的任务实际由wait函数实现，sys_wait仅为入口，做参数解析
    }

    uint64
    sys_sbrk(void)
    {
        int addr;
        int n;

        if(argint(0, &n) < 0)
            return -1;
        addr = myproc()->sz;    // addr = Size of process memory (bytes)
        if(growproc(n) < 0)     // 扩展内存空间的任务实际由growproc函数实现
            return -1;
        return addr;
    }

    // 与锁和计时器相关，学完回来更
    uint64
    sys_sleep(void)
    {
        int n;
        uint ticks0;

        if(argint(0, &n) < 0)
            return -1;
        acquire(&tickslock);
        ticks0 = ticks;
        while(ticks - ticks0 < n){
            if(myproc()->killed){
                release(&tickslock);
                return -1;
            }
            sleep(&ticks, &tickslock);
        }
        release(&tickslock);
        return 0;
    }

    uint64
    sys_kill(void)
    {
        int pid;

        if(argint(0, &pid) < 0)
            return -1;
        return kill(pid);
    }

    // return how many clock tick interrupts have occurred
    // since start.
    uint64
    sys_uptime(void)
    {
        uint xticks;

        acquire(&tickslock);
        xticks = ticks;
        release(&tickslock);
        return xticks;
    }

文件系统相关的系统调用函数分布在了/kernel/sysfile.c中：

    uint64
    sys_dup(void)
    {
        struct file *f;
        int fd;

        if(argfd(0, 0, &f) < 0)
            return -1;
        if((fd=fdalloc(f)) < 0)
            return -1;
        filedup(f);
        return fd;
    }

    uint64
    sys_read(void)
    {
        struct file *f;
        int n;
        uint64 p;

        if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
            return -1;
        return fileread(f, p, n);
    }

    uint64
    sys_write(void)
    {
        struct file *f;
        int n;
        uint64 p;

        if(argfd(0, 0, &f) < 0 || argint(2, &n) < 0 || argaddr(1, &p) < 0)
            return -1;

        return filewrite(f, p, n);
    }

    uint64
    sys_close(void)
    {
        int fd;
        struct file *f;

        if(argfd(0, &fd, &f) < 0)
            return -1;
        myproc()->ofile[fd] = 0;
        fileclose(f);
        return 0;
    }

    uint64
    sys_fstat(void)
    {
        struct file *f;
        uint64 st; // user pointer to struct stat

        if(argfd(0, 0, &f) < 0 || argaddr(1, &st) < 0)
            return -1;
        return filestat(f, st);
    }

    // Create the path new as a link to the same inode as old.
    uint64
    sys_link(void)
    {
        char name[DIRSIZ], new[MAXPATH], old[MAXPATH];
        struct inode *dp, *ip;

        if(argstr(0, old, MAXPATH) < 0 || argstr(1, new, MAXPATH) < 0)
            return -1;

        begin_op();
        if((ip = namei(old)) == 0){
            end_op();
            return -1;
        }

        ilock(ip);
        if(ip->type == T_DIR){
            iunlockput(ip);
            end_op();
            return -1;
        }

        ip->nlink++;
        iupdate(ip);
        iunlock(ip);

        if((dp = nameiparent(new, name)) == 0)
            goto bad;
        ilock(dp);
        if(dp->dev != ip->dev || dirlink(dp, name, ip->inum) < 0){
            iunlockput(dp);
            goto bad;
        }
        iunlockput(dp);
        iput(ip);

        end_op();

        return 0;

        bad:
        ilock(ip);
        ip->nlink--;
        iupdate(ip);
        iunlockput(ip);
        end_op();
        return -1;
    }

    uint64
    sys_unlink(void)
    {
        struct inode *ip, *dp;
        struct dirent de;
        char name[DIRSIZ], path[MAXPATH];
        uint off;

        if(argstr(0, path, MAXPATH) < 0)
            return -1;

        begin_op();
        if((dp = nameiparent(path, name)) == 0){
            end_op();
            return -1;
        }

        ilock(dp);

        // Cannot unlink "." or "..".
        if(namecmp(name, ".") == 0 || namecmp(name, "..") == 0)
            goto bad;

        if((ip = dirlookup(dp, name, &off)) == 0)
            goto bad;
        ilock(ip);

        if(ip->nlink < 1)
            panic("unlink: nlink < 1");
        if(ip->type == T_DIR && !isdirempty(ip)){
            iunlockput(ip);
            goto bad;
        }

        memset(&de, 0, sizeof(de));
        if(writei(dp, 0, (uint64)&de, off, sizeof(de)) != sizeof(de))
            panic("unlink: writei");
        if(ip->type == T_DIR){
            dp->nlink--;
            iupdate(dp);
        }
        iunlockput(dp);

        ip->nlink--;
        iupdate(ip);
        iunlockput(ip);

        end_op();

        return 0;

        bad:
        iunlockput(dp);
        end_op();
        return -1;
    }

    uint64
    sys_open(void)
    {
        char path[MAXPATH];
        int fd, omode;
        struct file *f;
        struct inode *ip;
        int n;

        if((n = argstr(0, path, MAXPATH)) < 0 || argint(1, &omode) < 0)
            return -1;

        begin_op();

        if(omode & O_CREATE){
            ip = create(path, T_FILE, 0, 0);
            if(ip == 0){
            end_op();
            return -1;
            }
        } else {
            if((ip = namei(path)) == 0){
            end_op();
            return -1;
            }
            ilock(ip);
            if(ip->type == T_DIR && omode != O_RDONLY){
            iunlockput(ip);
            end_op();
            return -1;
            }
        }

        if(ip->type == T_DEVICE && (ip->major < 0 || ip->major >= NDEV)){
            iunlockput(ip);
            end_op();
            return -1;
        }

        if((f = filealloc()) == 0 || (fd = fdalloc(f)) < 0){
            if(f)
            fileclose(f);
            iunlockput(ip);
            end_op();
            return -1;
        }

        if(ip->type == T_DEVICE){
            f->type = FD_DEVICE;
            f->major = ip->major;
        } else {
            f->type = FD_INODE;
            f->off = 0;
        }
        f->ip = ip;
        f->readable = !(omode & O_WRONLY);
        f->writable = (omode & O_WRONLY) || (omode & O_RDWR);

        if((omode & O_TRUNC) && ip->type == T_FILE){
            itrunc(ip);
        }

        iunlock(ip);
        end_op();

        return fd;
    }

    uint64
    sys_mkdir(void)
    {
        char path[MAXPATH];
        struct inode *ip;

        begin_op();
        if(argstr(0, path, MAXPATH) < 0 || (ip = create(path, T_DIR, 0, 0)) == 0){
            end_op();
            return -1;
        }
        iunlockput(ip);
        end_op();
        return 0;
    }

    uint64
    sys_mknod(void)
    {
        struct inode *ip;
        char path[MAXPATH];
        int major, minor;

        begin_op();
        if((argstr(0, path, MAXPATH)) < 0 ||
            argint(1, &major) < 0 ||
            argint(2, &minor) < 0 ||
            (ip = create(path, T_DEVICE, major, minor)) == 0){
            end_op();
            return -1;
        }
        iunlockput(ip);
        end_op();
        return 0;
    }

    uint64
    sys_chdir(void)
    {
        char path[MAXPATH];
        struct inode *ip;
        struct proc *p = myproc();
        
        begin_op();
        if(argstr(0, path, MAXPATH) < 0 || (ip = namei(path)) == 0){
            end_op();
            return -1;
        }
        ilock(ip);
        if(ip->type != T_DIR){
            iunlockput(ip);
            end_op();
            return -1;
        }
        iunlock(ip);
        iput(p->cwd);
        end_op();
        p->cwd = ip;
        return 0;
    }

    uint64
    sys_exec(void)
    {
        char path[MAXPATH], *argv[MAXARG];
        int i;
        uint64 uargv, uarg;

        if(argstr(0, path, MAXPATH) < 0 || argaddr(1, &uargv) < 0){
            return -1;
        }
        memset(argv, 0, sizeof(argv));
        for(i=0;; i++){
            if(i >= NELEM(argv)){
            goto bad;
            }
            if(fetchaddr(uargv+sizeof(uint64)*i, (uint64*)&uarg) < 0){
            goto bad;
            }
            if(uarg == 0){
            argv[i] = 0;
            break;
            }
            argv[i] = kalloc();
            if(argv[i] == 0)
            goto bad;
            if(fetchstr(uarg, argv[i], PGSIZE) < 0)
            goto bad;
        }

        int ret = exec(path, argv);

        for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
            kfree(argv[i]);

        return ret;

        bad:
        for(i = 0; i < NELEM(argv) && argv[i] != 0; i++)
            kfree(argv[i]);
        return -1;
    }

    uint64
    sys_pipe(void)
    {
        uint64 fdarray; // user pointer to array of two integers
        struct file *rf, *wf;
        int fd0, fd1;
        struct proc *p = myproc();

        if(argaddr(0, &fdarray) < 0)
            return -1;
        if(pipealloc(&rf, &wf) < 0)
            return -1;
        fd0 = -1;
        if((fd0 = fdalloc(rf)) < 0 || (fd1 = fdalloc(wf)) < 0){
            if(fd0 >= 0)
            p->ofile[fd0] = 0;
            fileclose(rf);
            fileclose(wf);
            return -1;
        }
        if(copyout(p->pagetable, fdarray, (char*)&fd0, sizeof(fd0)) < 0 ||
            copyout(p->pagetable, fdarray+sizeof(fd0), (char *)&fd1, sizeof(fd1)) < 0){
            p->ofile[fd0] = 0;
            p->ofile[fd1] = 0;
            fileclose(rf);
            fileclose(wf);
            return -1;
        }
        return 0;
    }

学完文件系统回来更

XV6将所以系统调用就分为了这两类 -- sysproc和sysfile。全都在这里了。
</pre>

</body>